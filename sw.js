(function(){"use strict";const u="1.4.13",w=`ehagaki-cache-${u}`,p="ehagaki-profile-images",W="eHagakiSharedData",R=1,g=(()=>{const e=self.location.pathname.match(/^(\/[^/]+)\/sw\.js$/);return e&&e[1]!==""?e[1]:""})();console.log("SW: BASE_PATH detected:",g,"from",self.location.pathname);let f=[];try{f=[{"revision":"babe63f1867bfda88a54ea48714bacbf","url":"/ehagaki/apple-touch-icon.png"},{"revision":"ec3736d92ab689be676751646681c7bd","url":"/ehagaki/assets/en-DGQt_pRD.js"},{"revision":"207ef0aa44572cc7a0f971d6183dc470","url":"/ehagaki/assets/index-BGkPs4_G.css"},{"revision":"6d046141d7a51531f95b24ea128eeb36","url":"/ehagaki/assets/index-uvEBznDv.js"},{"revision":"67153dcb6cbcbc5ec2245e305b35b52f","url":"/ehagaki/assets/index.esm-B6zogCv1.js"},{"revision":"1e1ce09a1d5e2e2afc444920707baaf1","url":"/ehagaki/assets/ja-BWSuQG_i.js"},{"revision":"2efb2b5d5ece06117f31e3945b05ae1a","url":"/ehagaki/assets/workbox-window.prod.es5-CwtvwXb3.js"},{"revision":"29bad677c14a3d64f60f0a3aa18d8457","url":"/ehagaki/ehagaki_icon_circle.webp"},{"revision":"6fed39e02d6fc688225eddfb47cfd401","url":"/ehagaki/ehagaki_icon_x192.png"},{"revision":"85177035c770f4dd3355b5575874a7e1","url":"/ehagaki/ehagaki_icon_x512.png"},{"revision":"781b26f1ca16ee34e2a08db520649eb4","url":"/ehagaki/ehagaki_icon.svg"},{"revision":"8565f947bbd349fec9860aa811536476","url":"/ehagaki/ehagaki_icon.webp"},{"revision":"2bada714d92f8ac2c4775c7dd160ae4b","url":"/ehagaki/ehagaki_ogp.webp"},{"revision":"80772041a3d7706a49eaf42dac91f5ad","url":"/ehagaki/favicon.ico"},{"revision":"7bc2c70c1c45f1665dd3eff02957c2fd","url":"/ehagaki/icons/circle-info-solid-full.svg"},{"revision":"81b5daf7a062038ca927790a306a4f1d","url":"/ehagaki/icons/circle-user-solid-full.svg"},{"revision":"bb07a82a78fb6c0880c35878d14c3fc9","url":"/ehagaki/icons/copy-solid-full.svg"},{"revision":"cfe7c3589a1fd3dd297a0e12849d26f2","url":"/ehagaki/icons/expand-solid-full.svg"},{"revision":"97a01045245952c64a77bf467c91a979","url":"/ehagaki/icons/gear-solid-full.svg"},{"revision":"37d5908dc78c990de67476170ee51443","url":"/ehagaki/icons/github-mark.svg"},{"revision":"26330813975ae0a2c805089b709b4275","url":"/ehagaki/icons/image-solid-full.svg"},{"revision":"433f5bd2615322b08560d787c499dc3d","url":"/ehagaki/icons/language-solid-full.svg"},{"revision":"b02a88451d35ed40d647402c53868871","url":"/ehagaki/icons/nostr-login.svg"},{"revision":"2cb73309bb43ea470508684c229ec40f","url":"/ehagaki/icons/paper-plane-solid-full.svg"},{"revision":"8cff7ee8121e2dbc6a5ce539a9020bb7","url":"/ehagaki/icons/rotate-right-solid-full.svg"},{"revision":"5ece31773493febdbafeb032624e8b67","url":"/ehagaki/icons/trash-solid-full.svg"},{"revision":"75b796fdf72212cf9fbfd5cfa133267f","url":"/ehagaki/icons/xmark-solid-full.svg"},{"revision":"764c0ecc9d15caa9003d918c4527af36","url":"/ehagaki/index.html"},{"revision":"cb4ae2f1d456008a99af7e37c18d0c9a","url":"/ehagaki/manifest.webmanifest"},{"revision":"167bddd35a0ac0c3aaa141d18493fc0b","url":"/ehagaki/maskable_icon_x192.png"},{"revision":"7df370b1e96677f8862bc129b565156d","url":"/ehagaki/maskable_icon_x512.png"},{"revision":"cb4ae2f1d456008a99af7e37c18d0c9a","url":"manifest.webmanifest"}]||[],f.length===0?console.warn("SW: Precache manifest is empty"):(console.log(`SW: Precache manifest loaded with ${f.length} entries`),console.log("SW: First 3 manifest entries:",f.slice(0,3)))}catch(o){console.error("SW: Failed to load precache manifest:",o),f=[]}const m={sharedImageCache:null,precacheManifest:f,getSharedImageCache(){return this.sharedImageCache},setSharedImageCache(o){this.sharedImageCache=o},clearSharedImageCache(){this.sharedImageCache=null}},i={caches:self.caches,indexedDB:self.indexedDB,clients:self.clients,fetch:self.fetch.bind(self),console:self.console,location:self.location,navigator:self.navigator,setTimeout:self.setTimeout.bind(self)},P=new Uint8Array([137,80,78,71,13,10,26,10,0,0,0,13,73,72,68,82,0,0,0,1,0,0,0,1,8,6,0,0,0,31,21,196,137,0,0,0,10,73,68,65,84,120,156,99,0,1,0,0,5,0,1,13,10,45,180,0,0,0,0,73,69,78,68,174,66,96,130]),l={createTransparentImageResponse(o=200){return new Response(P,{status:o,statusText:o===200?"OK":"Error",headers:{"Content-Type":"image/png","Cache-Control":o===200?"max-age=31536000":"no-cache","Access-Control-Allow-Origin":"*"}})},createCorsRequest(o,e={}){const s=e.mode||"cors",t=new Headers({Accept:"image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8",...e.headers||{}});return new Request(o,{method:"GET",headers:t,mode:s,credentials:"omit",cache:e.cache||"default",redirect:"follow",...e})},getBaseUrl(o){const e=new URL(o);return`${e.origin}${e.pathname}`},createRedirectResponse(o,e=null,s=i.location){const t=o.startsWith(g)?o:`${g}${o}`,a=new URL(t,s.origin);return e&&(a.searchParams.set("shared","true"),a.searchParams.set("error",e)),Response.redirect(a.href,303)},isUploadRequest(o,e){const s=`${g}/upload`;return o.method==="POST"&&(e.pathname.endsWith("/upload")||e.pathname.includes("/upload")||e.pathname===s)},isProfileImageRequest(o){return o.method!=="GET"?!1:new URL(o.url).searchParams.get("profile")==="true"},async extractImageFromFormData(o){const e=o.get("image");return e?{image:e,metadata:{name:e.name,type:e.type,size:e.size,timestamp:new Date().toISOString()}}:null}};class S{constructor(e=i){this.indexedDB=e.indexedDB,this.console=e.console}async executeOperation(e){return new Promise((s,t)=>{try{const a=this.indexedDB.open(W,R);a.onupgradeneeded=c=>{const r=c.target.result;r.objectStoreNames.contains("flags")||r.createObjectStore("flags",{keyPath:"id"})},a.onerror=()=>t(new Error("IndexedDB open failed")),a.onsuccess=c=>{const r=c.target.result;try{e(r,s,t)}catch(n){r.close(),t(n)}}}catch(a){t(a)}})}async saveSharedFlag(){return this.executeOperation((e,s,t)=>{const a=e.transaction(["flags"],"readwrite"),c=a.objectStore("flags");c.put({id:"sharedImage",timestamp:Date.now(),value:!0}).onsuccess=()=>{e.close(),s()},a.onerror=()=>{e.close(),t(new Error("Failed to store shared flag"))}})}async clearSharedFlag(){try{await this.executeOperation((e,s)=>{if(!e.objectStoreNames.contains("flags")){e.close(),s();return}const t=e.transaction(["flags"],"readwrite"),a=t.objectStore("flags");a.delete("sharedImage").onsuccess=()=>{e.close(),s()},t.onerror=()=>{e.close(),s()}})}catch(e){this.console.error("IndexedDB error:",e)}}}class I{constructor(e=i){this.caches=e.caches,this.fetch=e.fetch,this.console=e.console}async precacheResources(e){if(!e||e.length===0){this.console.warn("SW: No resources to precache");return}try{const s=await this.caches.open(w),t=e.map(r=>typeof r=="string"?{url:r,revision:null}:r&&typeof r=="object"&&r.url?r:(this.console.warn("SW: Invalid manifest entry:",r),null)).filter(Boolean);if(t.length===0){this.console.warn("SW: No valid entries to cache");return}this.console.log("SW: Starting to cache",t.length,"resources");let a=0,c=0;for(const r of t){const n=r.url;if(g&&!n.startsWith(g)&&!n.startsWith("http")){this.console.warn(`SW: Skipping invalid URL without base path: ${n}`),c++;continue}try{const h=new URL(n,self.location.origin).href;this.console.log(`SW: Fetching: ${h}`);const d=await this.fetch(h);if(d.ok){const C=(r.revision,h);await s.put(C,d),a++,this.console.log(`SW: ✓ Cached: ${n}`)}else c++,this.console.error(`SW: ✗ Failed (${d.status}): ${n}`)}catch(h){c++,this.console.error(`SW: ✗ Error caching ${n}:`,h.message)}}this.console.log(`SW: Precache complete. Success: ${a}, Failed: ${c}`),c>a&&this.console.error(`SW: Too many failures (${c}/${t.length}). Check manifest URLs.`)}catch(s){this.console.error("SW: Precache error:",s)}}async cleanupOldCaches(){try{const e=await this.caches.keys();await Promise.all(e.map(s=>{if(s!==w&&s!==p)return this.caches.delete(s)}))}catch(e){this.console.error("キャッシュクリーンアップエラー:",e)}}async handleCacheFirst(e){try{const s=await this.caches.open(w),t=new URL(e.url);let a=await s.match(e);if(a)return this.console.log("SW: Cache hit (original):",e.url),a;if(g){let r;if(t.pathname.startsWith(g)?r=t.pathname.replace(g,""):r=`${g}${t.pathname}`,r){const n=new Request(new URL(r+t.search,t.origin).href,e);if(a=await s.match(n),a)return this.console.log("SW: Cache hit (alternate):",n.url),a}}this.console.log("SW: Cache miss, fetching from network:",e.url);const c=await this.fetch(e);return c.ok&&e.method==="GET"&&(await s.put(e,c.clone()),this.console.log("SW: Cached new resource:",e.url)),c}catch(s){return this.console.error("SW: Cache strategy error:",s),new Response("Not Found",{status:404})}}async handleProfileImageCache(e){try{const s=await this.caches.open(p),t=l.getBaseUrl(e.url),a=l.createCorsRequest(t,{mode:"no-cors"}),c=await s.match(a);if(c)return this.console.log("プロフィール画像をキャッシュから返却（ベースURL）:",t),c;const r=await s.match(e);return r?(this.console.log("プロフィール画像をキャッシュから返却（元URL）:",e.url),r):null}catch(s){return this.console.error("プロフィールキャッシュエラー:",s),null}}async fetchAndCacheProfileImage(e){if(i.navigator&&i.navigator.onLine===!1)return null;try{const s=l.getBaseUrl(e.url),t=l.createCorsRequest(s,{mode:"no-cors",headers:{"Cache-Control":"no-cache"},cache:"no-cache"});this.console.log("プロフィール画像をネットワークから取得中:",s);const a=await this.fetch(t);if(a&&(a.ok||a.type==="opaque")){const c=await this.caches.open(p),r=l.createCorsRequest(s,{mode:"no-cors"});try{await c.put(r,a.clone()),this.console.log("プロフィール画像をキャッシュに保存完了:",s)}catch(n){this.console.warn("プロフィール画像のキャッシュ保存に失敗:",n,s)}return a}else this.console.warn("プロフィール画像の取得に失敗または非OKレスポンス:",a&&a.type,a&&a.status,a&&a.statusText)}catch(s){this.console.log("プロフィール画像のネットワークエラー:",s&&s.message)}return null}async clearProfileCache(){try{const e=await this.caches.delete(p);return this.console.log("プロフィール画像キャッシュクリア:",e),{success:!0}}catch(e){return this.console.error("プロフィールキャッシュクリアエラー:",e),{success:!1,error:e.message}}}async cleanupDuplicateProfileCache(){try{const e=await this.caches.open(p),s=await e.keys(),t=new Set,a=[];s.forEach(r=>{const n=new URL(r.url),h=l.getBaseUrl(r.url);n.search?a.push(r):t.add(h)});let c=0;for(const r of a){const n=l.getBaseUrl(r.url);t.has(n)&&(await e.delete(r),c++,this.console.log("重複キャッシュを削除:",r.url))}return this.console.log(`重複プロフィールキャッシュクリーンアップ完了: ${c}件削除`),{success:!0,deletedCount:c}}catch(e){return this.console.error("重複キャッシュクリーンアップエラー:",e),{success:!1,error:e.message}}}}class y{constructor(e=i){this.clients=e.clients,this.console=e.console,this.location=e.location,this.setTimeout=e.setTimeout}async redirectClient(){try{const e=await this.clients.matchAll({type:"window",includeUncontrolled:!0});return e.length>0?await this.focusAndNotifyClient(e[0]):await this.openNewClient()}catch(e){return this.console.error("クライアント処理エラー:",e),l.createRedirectResponse("/","client-error",this.location)}}async focusAndNotifyClient(e){try{await e.focus();const s=m.getSharedImageCache();if(this.console.log("SW: Attempting to notify client",{hasClient:!!e,hasPostMessage:typeof e.postMessage=="function",hasSharedCache:!!s,clientId:e.id||"unknown"}),s)try{const t=new S;await this.persistSharedImageToIndexedDB(s,t),this.console.log("SW: Shared image persisted to IndexedDB for fallback")}catch(t){this.console.warn("SW: Failed to persist shared image to IndexedDB:",t)}if(e&&typeof e.postMessage=="function")try{e.postMessage({type:"SHARED_IMAGE",data:s,timestamp:Date.now(),requestId:`sw-${Date.now()}`}),this.console.log("SW: Message sent to client successfully")}catch(t){this.console.warn("SW: Failed to send message to client (will rely on IndexedDB fallback):",t)}return l.createRedirectResponse("/",null,this.location)}catch(s){return this.console.error("SW: Client focus/notification error:",s),l.createRedirectResponse("/","client-error",this.location)}}async persistSharedImageToIndexedDB(e,s){return s.executeOperation((t,a,c)=>{const r=t.transaction(["flags"],"readwrite"),n=r.objectStore("flags"),h={id:"sharedImageData",timestamp:Date.now(),data:{image:{name:e.image?.name,type:e.image?.type,size:e.image?.size,_isFile:!0},metadata:e.metadata}};e.image instanceof File?e.image.arrayBuffer().then(d=>{h.data.image.arrayBuffer=d,n.put(h).onsuccess=()=>{t.close(),a()}}).catch(d=>{t.close(),c(d)}):n.put(h).onsuccess=()=>{t.close(),a()},r.onerror=()=>{t.close(),c(new Error("Failed to persist shared image data"))}})}}class E{constructor(e=new S,s=i){this.indexedDBManager=e,this.console=s.console}respondSharedImage(e){const s=e.source,t=e.data.requestId||null,a=m.getSharedImageCache(),c={type:"SHARED_IMAGE",data:a,requestId:t,timestamp:Date.now()};e.ports?.[0]?e.ports[0].postMessage(c):s&&s.postMessage(c),a&&(m.clearSharedImageCache(),this.indexedDBManager.clearSharedFlag())}respondSharedImageForce(e){const s=e.source,t=e.data.requestId||null,a=m.getSharedImageCache();a||this.console.log("SW: No shared cache, client should try IndexedDB fallback");const c={type:"SHARED_IMAGE",data:a,requestId:t,timestamp:Date.now(),fallbackRequired:!a};e.ports?.[0]?e.ports[0].postMessage(c):s&&s.postMessage(c)}}class M{constructor(e=new I,s=new y,t=new S,a=i){this.cacheManager=e,this.clientManager=s,this.indexedDBManager=t,this.console=a.console,this.location=a.location}async handleUploadRequest(e){try{this.console.log("SW: Processing upload request",e.url);const s=await e.formData(),t=await l.extractImageFromFormData(s);if(!t)return this.console.warn("SW: No image data found in FormData"),l.createRedirectResponse("/","no-image",this.location);this.console.log("SW: Image data extracted successfully",{hasImage:!!t.image,imageType:t.image?.type,imageSize:t.image?.size,imageName:t.image?.name}),m.setSharedImageCache(t);try{await this.indexedDBManager.saveSharedFlag(),this.console.log("SW: Shared flag saved to IndexedDB")}catch(a){this.console.error("SW: IndexedDB save error:",a)}return await this.clientManager.redirectClient()}catch(s){return this.console.error("SW: Upload processing error:",s),l.createRedirectResponse("/","processing-error",this.location)}}async handleProfileImageRequest(e){try{this.console.log("プロフィール画像リクエスト処理開始:",e.url);const s=await this.cacheManager.handleProfileImageCache(e);if(s)return this.console.log("プロフィール画像をキャッシュから返却:",e.url),s;const t=await this.cacheManager.fetchAndCacheProfileImage(e);return t?(this.console.log("プロフィール画像をネットワークから返却:",e.url),t):(this.console.log("フォールバック画像を返却:",e.url),l.createTransparentImageResponse())}catch(s){return this.console.error("プロフィール画像処理エラー:",s),l.createTransparentImageResponse(404)}}}class D{constructor(){this.cacheManager=new I,this.indexedDBManager=new S,this.clientManager=new y,this.messageHandler=new E(this.indexedDBManager),this.requestHandler=new M(this.cacheManager,this.clientManager,this.indexedDBManager)}async handleInstall(e){i.console.log("SW installing...",u),await this.cacheManager.precacheResources(m.precacheManifest),i.console.log("SW installed, waiting for user action")}async handleActivate(e){i.console.log("SW activating...",u),await this.cacheManager.cleanupOldCaches(),await i.clients.claim()}async handleFetch(e){const s=new URL(e.request.url);return l.isUploadRequest(e.request,s)?(i.console.log("SW: 内部アップロードリクエストを処理",s.href),await this.requestHandler.handleUploadRequest(e.request)):l.isProfileImageRequest(e.request)?await this.requestHandler.handleProfileImageRequest(e.request):await this.cacheManager.handleCacheFirst(e.request)}async handleMessage(e){const s={SKIP_WAITING:()=>{i.console.log("SW received SKIP_WAITING, updating..."),self.skipWaiting()},GET_VERSION:()=>{e.ports?.[0]?.postMessage({version:u})},PING_TEST:()=>{const r={type:"PONG",timestamp:Date.now(),version:u};try{e.ports?.[0]?(e.ports[0].postMessage(r),i.console.log("SW: PING_TEST responded via MessageChannel")):e.source?(e.source.postMessage(r),i.console.log("SW: PING_TEST responded via source")):i.console.warn("SW: PING_TEST no response channel available")}catch(n){i.console.error("SW: PING_TEST response error:",n)}},DEBUG_CACHE:async()=>{try{const h=(await(await this.cacheManager.caches.open(w)).keys()).map(C=>C.url),d={version:u,basePath:g,manifestLength:f.length,manifestSample:f.slice(0,5),cachedUrls:h,cachedCount:h.length,location:self.location.href,origin:self.location.origin};e.ports?.[0]?e.ports[0].postMessage(d):e.source&&e.source.postMessage(d),i.console.log("SW: Cache debug info:",d)}catch(r){i.console.error("SW: Debug cache error:",r),e.ports?.[0]&&e.ports[0].postMessage({error:r.message})}}},t={getSharedImage:()=>this.messageHandler.respondSharedImage(e),getSharedImageForce:()=>this.messageHandler.respondSharedImageForce(e),clearProfileCache:async()=>{const r=await this.cacheManager.clearProfileCache();e.ports?.[0]?.postMessage(r)},cleanupDuplicateProfileCache:async()=>{const r=await this.cacheManager.cleanupDuplicateProfileCache();e.ports?.[0]?.postMessage(r)}},{type:a,action:c}=e.data||{};a&&s[a]?s[a]():c&&t[c]&&await t[c]()}}const x=new D;self.addEventListener("install",o=>{console.log("SW: Install event triggered for version",u),o.waitUntil(x.handleInstall(o).then(()=>(console.log("SW: Install completed, calling skipWaiting"),self.skipWaiting())))}),self.addEventListener("activate",o=>{console.log("SW: Activate event triggered for version",u),o.waitUntil(x.handleActivate(o).then(()=>(console.log("SW: Activate completed, claiming clients"),self.clients.claim())))}),self.addEventListener("fetch",o=>{if(new URL(o.request.url),o.request.url.startsWith(self.location.origin)){const e=x.handleFetch(o);e!==void 0&&o.respondWith(e)}else l.isProfileImageRequest(o.request)&&(console.log("SW: 外部プロフィール画像リクエストを処理:",o.request.url),o.respondWith(x.requestHandler.handleProfileImageRequest(o.request)))}),self.addEventListener("message",o=>{x.handleMessage(o)}),typeof module<"u"&&module.exports&&(module.exports={ServiceWorkerCore:D,ServiceWorkerState:m,ServiceWorkerDependencies:i,Utilities:l,IndexedDBManager:S,CacheManager:I,ClientManager:y,MessageHandler:E,RequestHandler:M,PRECACHE_VERSION:u,PRECACHE_NAME:w,PROFILE_CACHE_NAME:p,INDEXEDDB_NAME:W,INDEXEDDB_VERSION:R})})();

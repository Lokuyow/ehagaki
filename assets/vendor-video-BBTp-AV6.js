var H;(function(t){t.LOAD="LOAD",t.EXEC="EXEC",t.FFPROBE="FFPROBE",t.WRITE_FILE="WRITE_FILE",t.READ_FILE="READ_FILE",t.DELETE_FILE="DELETE_FILE",t.RENAME="RENAME",t.CREATE_DIR="CREATE_DIR",t.LIST_DIR="LIST_DIR",t.DELETE_DIR="DELETE_DIR",t.ERROR="ERROR",t.DOWNLOAD="DOWNLOAD",t.PROGRESS="PROGRESS",t.LOG="LOG",t.MOUNT="MOUNT",t.UNMOUNT="UNMOUNT"})(H||(H={}));const fn=(()=>{let t=0;return()=>t++})(),mn=new Error("ffmpeg is not loaded, call `await ffmpeg.load()` first"),pn=new Error("called FFmpeg.terminate()");class ml{#t=null;#i={};#r={};#s=[];#n=[];loaded=!1;#a=()=>{this.#t&&(this.#t.onmessage=({data:{id:e,type:r,data:i}})=>{switch(r){case H.LOAD:this.loaded=!0,this.#i[e](i);break;case H.MOUNT:case H.UNMOUNT:case H.EXEC:case H.FFPROBE:case H.WRITE_FILE:case H.READ_FILE:case H.DELETE_FILE:case H.RENAME:case H.CREATE_DIR:case H.LIST_DIR:case H.DELETE_DIR:this.#i[e](i);break;case H.LOG:this.#s.forEach(s=>s(i));break;case H.PROGRESS:this.#n.forEach(s=>s(i));break;case H.ERROR:this.#r[e](i);break}delete this.#i[e],delete this.#r[e]})};#e=({type:e,data:r},i=[],s)=>this.#t?new Promise((n,a)=>{const o=fn();this.#t&&this.#t.postMessage({id:o,type:e,data:r},i),this.#i[o]=n,this.#r[o]=a,s?.addEventListener("abort",()=>{a(new DOMException(`Message # ${o} was aborted`,"AbortError"))},{once:!0})}):Promise.reject(mn);on(e,r){e==="log"?this.#s.push(r):e==="progress"&&this.#n.push(r)}off(e,r){e==="log"?this.#s=this.#s.filter(i=>i!==r):e==="progress"&&(this.#n=this.#n.filter(i=>i!==r))}load=({classWorkerURL:e,...r}={},{signal:i}={})=>(this.#t||(this.#t=e?new Worker(new URL(e,import.meta.url),{type:"module"}):new Worker(new URL("/ehagaki/assets/worker-DYSz7Krg.js",import.meta.url),{type:"module"}),this.#a()),this.#e({type:H.LOAD,data:r},void 0,i));exec=(e,r=-1,{signal:i}={})=>this.#e({type:H.EXEC,data:{args:e,timeout:r}},void 0,i);ffprobe=(e,r=-1,{signal:i}={})=>this.#e({type:H.FFPROBE,data:{args:e,timeout:r}},void 0,i);terminate=()=>{const e=Object.keys(this.#r);for(const r of e)this.#r[r](pn),delete this.#r[r],delete this.#i[r];this.#t&&(this.#t.terminate(),this.#t=null,this.loaded=!1)};writeFile=(e,r,{signal:i}={})=>{const s=[];return r instanceof Uint8Array&&s.push(r.buffer),this.#e({type:H.WRITE_FILE,data:{path:e,data:r}},s,i)};mount=(e,r,i)=>{const s=[];return this.#e({type:H.MOUNT,data:{fsType:e,options:r,mountPoint:i}},s)};unmount=e=>{const r=[];return this.#e({type:H.UNMOUNT,data:{mountPoint:e}},r)};readFile=(e,r="binary",{signal:i}={})=>this.#e({type:H.READ_FILE,data:{path:e,encoding:r}},void 0,i);deleteFile=(e,{signal:r}={})=>this.#e({type:H.DELETE_FILE,data:{path:e}},void 0,r);rename=(e,r,{signal:i}={})=>this.#e({type:H.RENAME,data:{oldPath:e,newPath:r}},void 0,i);createDir=(e,{signal:r}={})=>this.#e({type:H.CREATE_DIR,data:{path:e}},void 0,r);listDir=(e,{signal:r}={})=>this.#e({type:H.LIST_DIR,data:{path:e}},void 0,r);deleteDir=(e,{signal:r}={})=>this.#e({type:H.DELETE_DIR,data:{path:e}},void 0,r)}var Ii;(function(t){t.MEMFS="MEMFS",t.NODEFS="NODEFS",t.NODERAWFS="NODERAWFS",t.IDBFS="IDBFS",t.WORKERFS="WORKERFS",t.PROXYFS="PROXYFS"})(Ii||(Ii={}));const gn=t=>new Promise((e,r)=>{const i=new FileReader;i.onload=()=>{const{result:s}=i;s instanceof ArrayBuffer?e(new Uint8Array(s)):e(new Uint8Array)},i.onerror=s=>{r(Error(`File could not be read! Code=${s?.target?.error?.code||-1}`))},i.readAsArrayBuffer(t)}),pl=async t=>{let e;if(typeof t=="string")/data:_data\/([a-zA-Z]*);base64,([^"]*)/.test(t)?e=atob(t.split(",")[1]).split("").map(r=>r.charCodeAt(0)):e=await(await fetch(t)).arrayBuffer();else if(t instanceof URL)e=await(await fetch(t)).arrayBuffer();else if(t instanceof File||t instanceof Blob)e=await gn(t);else return new Uint8Array;return new Uint8Array(e)};function m(t){if(!t)throw new Error("Assertion failed.")}const si=t=>{const e=(t%360+360)%360;if(e===0||e===90||e===180||e===270)return e;throw new Error(`Invalid rotation ${t}.`)},G=t=>t&&t[t.length-1],At=t=>t>=0&&t<2**32;class K{constructor(e){this.bytes=e,this.pos=0}seekToByte(e){this.pos=8*e}readBit(){const e=Math.floor(this.pos/8),r=this.bytes[e]??0,i=7-(this.pos&7),s=(r&1<<i)>>i;return this.pos++,s}readBits(e){if(e===1)return this.readBit();let r=0;for(let i=0;i<e;i++)r<<=1,r|=this.readBit();return r}writeBits(e,r){const i=this.pos+e;for(let s=this.pos;s<i;s++){const n=Math.floor(s/8);let a=this.bytes[n];const o=7-(s&7);a&=~(1<<o),a|=(r&1<<i-s-1)>>i-s-1<<o,this.bytes[n]=a}this.pos=i}readAlignedByte(){if(this.pos%8!==0)throw new Error("Bitstream is not byte-aligned.");const e=this.pos/8,r=this.bytes[e]??0;return this.pos+=8,r}skipBits(e){this.pos+=e}getBitsLeft(){return this.bytes.length*8-this.pos}clone(){const e=new K(this.bytes);return e.pos=this.pos,e}}const E=t=>{let e=0;for(;t.readBits(1)===0&&e<32;)e++;if(e>=32)throw new Error("Invalid exponential-Golomb code.");return(1<<e)-1+t.readBits(e)},Ue=t=>{const e=E(t);return(e&1)===0?-(e>>1):e+1>>1},fe=t=>t.constructor===Uint8Array?t:ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t),X=t=>t.constructor===DataView?t:ArrayBuffer.isView(t)?new DataView(t.buffer,t.byteOffset,t.byteLength):new DataView(t),ke=new TextDecoder,ve=new TextEncoder,ni=t=>Object.fromEntries(Object.entries(t).map(([e,r])=>[r,e])),Gt={bt709:1,bt470bg:5,smpte170m:6,bt2020:9,smpte432:12},ar=ni(Gt),Xt={bt709:1,smpte170m:6,linear:8,"iec61966-2-1":13,pq:16,hlg:18},or=ni(Xt),Yt={rgb:0,bt709:1,bt470bg:5,smpte170m:6,"bt2020-ncl":9},cr=ni(Yt),kn=t=>!!t&&!!t.primaries&&!!t.transfer&&!!t.matrix&&t.fullRange!==void 0,gr=t=>t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer||ArrayBuffer.isView(t);class ut{constructor(){this.currentPromise=Promise.resolve(),this.pending=0}async acquire(){let e;const r=new Promise(s=>{let n=!1;e=()=>{n||(s(),this.pending--,n=!0)}}),i=this.currentPromise;return this.currentPromise=r,this.pending++,await i,e}}const _i=t=>[...t].map(e=>e.toString(16).padStart(2,"0")).join(""),Ai=t=>(t=t>>1&1431655765|(t&1431655765)<<1,t=t>>2&858993459|(t&858993459)<<2,t=t>>4&252645135|(t&252645135)<<4,t=t>>8&16711935|(t&16711935)<<8,t=t>>16&65535|(t&65535)<<16,t>>>0),Zt=(t,e,r)=>{let i=0,s=t.length-1,n=-1;for(;i<=s;){const a=i+s>>1,o=r(t[a]);o===e?(n=a,s=a-1):o<e?i=a+1:s=a-1}return n},L=(t,e,r)=>{let i=0,s=t.length-1,n=-1;for(;i<=s;){const a=i+(s-i+1)/2|0;r(t[a])<=e?(n=a,i=a+1):s=a-1}return n},Fi=(t,e,r)=>{const i=L(t,r(e),r);t.splice(i+1,0,e)},ne=()=>{let t,e;return{promise:new Promise((i,s)=>{t=i,e=s}),resolve:t,reject:e}},cs=(t,e)=>{for(let r=t.length-1;r>=0;r--)if(e(t[r]))return t[r]},ai=(t,e)=>{for(let r=t.length-1;r>=0;r--)if(e(t[r]))return r;return-1},bn=async function*(t){Symbol.iterator in t?yield*t[Symbol.iterator]():yield*t[Symbol.asyncIterator]()},wn=t=>{if(!(Symbol.iterator in t)&&!(Symbol.asyncIterator in t))throw new TypeError("Argument must be an iterable or async iterable.")},Xe=t=>{throw new Error(`Unexpected value: ${t}`)},kr=(t,e,r)=>{const i=t.getUint8(e),s=t.getUint8(e+1),n=t.getUint8(e+2);return r?i|s<<8|n<<16:i<<16|s<<8|n},yn=(t,e,r)=>kr(t,e,r)<<8>>8,oi=(t,e,r,i)=>{r=r>>>0,r=r&16777215,i?(t.setUint8(e,r&255),t.setUint8(e+1,r>>>8&255),t.setUint8(e+2,r>>>16&255)):(t.setUint8(e,r>>>16&255),t.setUint8(e+1,r>>>8&255),t.setUint8(e+2,r&255))},Tn=(t,e,r,i)=>{r=te(r,-8388608,8388607),r<0&&(r=r+16777216&16777215),oi(t,e,r,i)},Bi=(t,e)=>({async next(){const r=await t.next();return r.done?{value:void 0,done:!0}:{value:e(r.value),done:!1}},return(){return t.return()},throw(r){return t.throw(r)},[Symbol.asyncIterator](){return this}}),te=(t,e,r)=>Math.max(e,Math.min(r,t)),he="und",Ht=t=>{const e=Math.round(t);return Math.abs(t/e-1)<10*Number.EPSILON?e:t},ls=(t,e)=>Math.round(t/e)*e,Sn=t=>{let e=0;for(;t;)e++,t>>=1;return e},Pn=/^[a-z]{3}$/,qt=t=>Pn.test(t),$e=1e6*(1+Number.EPSILON),xn=(t,e)=>{const r=t<0?-1:1;t=Math.abs(t);let i=0,s=1,n=1,a=0,o=t;for(;;){const c=Math.floor(o),l=c*n+i,u=c*a+s;if(u>e)return{numerator:r*n,denominator:a};if(i=n,s=a,n=l,a=u,o=1/(o-c),!isFinite(o))break}return{numerator:r*n,denominator:a}};class br{constructor(){this.currentPromise=Promise.resolve()}call(e){return this.currentPromise=this.currentPromise.then(e)}}let Sr=null;const Nt=()=>Sr!==null?Sr:Sr=!!(typeof navigator<"u"&&(navigator.vendor?.match(/apple/i)||/AppleWebKit/.test(navigator.userAgent)&&!/Chrome/.test(navigator.userAgent)||/\b(iPad|iPhone|iPod)\b/.test(navigator.userAgent)));let Pr=null;const Ft=()=>Pr!==null?Pr:Pr=typeof navigator<"u"&&navigator.userAgent?.includes("Firefox");let xr=null;const Hr=()=>xr!==null?xr:xr=!!(typeof navigator<"u"&&(navigator.vendor?.includes("Google Inc")||/Chrome/.test(navigator.userAgent)));let Cr=null;const Cn=()=>{if(Cr!==null)return Cr;if(typeof navigator>"u")return null;const t=/\bChrome\/(\d+)/.exec(navigator.userAgent);return t?Cr=Number(t[1]):null},pt=(t,e)=>t!==-1?t:e,Ri=(t,e,r,i)=>t<=i&&r<=e,us=function*(t){for(const e in t){const r=t[e];r!==void 0&&(yield{key:e,value:r})}},vn=t=>{const e=atob(t),r=new Uint8Array(e.length);for(let i=0;i<e.length;i++)r[i]=e.charCodeAt(i);return r},ds=()=>{Symbol.dispose??=Symbol("Symbol.dispose")},hs=t=>typeof t=="number"&&!Number.isNaN(t);class Et{constructor(e,r){if(this.data=e,this.mimeType=r,!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(typeof r!="string")throw new TypeError("mimeType must be a string.")}}class fs{constructor(e,r,i,s){if(this.data=e,this.mimeType=r,this.name=i,this.description=s,!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(r!==void 0&&typeof r!="string")throw new TypeError("mimeType, when provided, must be a string.");if(i!==void 0&&typeof i!="string")throw new TypeError("name, when provided, must be a string.");if(s!==void 0&&typeof s!="string")throw new TypeError("description, when provided, must be a string.")}}const qr=t=>{if(!t||typeof t!="object")throw new TypeError("tags must be an object.");if(t.title!==void 0&&typeof t.title!="string")throw new TypeError("tags.title, when provided, must be a string.");if(t.description!==void 0&&typeof t.description!="string")throw new TypeError("tags.description, when provided, must be a string.");if(t.artist!==void 0&&typeof t.artist!="string")throw new TypeError("tags.artist, when provided, must be a string.");if(t.album!==void 0&&typeof t.album!="string")throw new TypeError("tags.album, when provided, must be a string.");if(t.albumArtist!==void 0&&typeof t.albumArtist!="string")throw new TypeError("tags.albumArtist, when provided, must be a string.");if(t.trackNumber!==void 0&&(!Number.isInteger(t.trackNumber)||t.trackNumber<=0))throw new TypeError("tags.trackNumber, when provided, must be a positive integer.");if(t.tracksTotal!==void 0&&(!Number.isInteger(t.tracksTotal)||t.tracksTotal<=0))throw new TypeError("tags.tracksTotal, when provided, must be a positive integer.");if(t.discNumber!==void 0&&(!Number.isInteger(t.discNumber)||t.discNumber<=0))throw new TypeError("tags.discNumber, when provided, must be a positive integer.");if(t.discsTotal!==void 0&&(!Number.isInteger(t.discsTotal)||t.discsTotal<=0))throw new TypeError("tags.discsTotal, when provided, must be a positive integer.");if(t.genre!==void 0&&typeof t.genre!="string")throw new TypeError("tags.genre, when provided, must be a string.");if(t.date!==void 0&&(!(t.date instanceof Date)||Number.isNaN(t.date.getTime())))throw new TypeError("tags.date, when provided, must be a valid Date.");if(t.lyrics!==void 0&&typeof t.lyrics!="string")throw new TypeError("tags.lyrics, when provided, must be a string.");if(t.images!==void 0){if(!Array.isArray(t.images))throw new TypeError("tags.images, when provided, must be an array.");for(const e of t.images){if(!e||typeof e!="object")throw new TypeError("Each image in tags.images must be an object.");if(!(e.data instanceof Uint8Array))throw new TypeError("Each image.data must be a Uint8Array.");if(typeof e.mimeType!="string")throw new TypeError("Each image.mimeType must be a string.");if(!["coverFront","coverBack","unknown"].includes(e.kind))throw new TypeError("Each image.kind must be 'coverFront', 'coverBack', or 'unknown'.")}}if(t.comment!==void 0&&typeof t.comment!="string")throw new TypeError("tags.comment, when provided, must be a string.");if(t.raw!==void 0){if(!t.raw||typeof t.raw!="object")throw new TypeError("tags.raw, when provided, must be an object.");for(const e of Object.values(t.raw))if(e!==null&&typeof e!="string"&&!(e instanceof Uint8Array)&&!(e instanceof Et)&&!(e instanceof fs))throw new TypeError("Each value in tags.raw must be a string, Uint8Array, RichImageData, AttachedFile, or null.")}},Ye={default:!0,forced:!1,original:!1,commentary:!1,hearingImpaired:!1,visuallyImpaired:!1},En=t=>{if(!t||typeof t!="object")throw new TypeError("disposition must be an object.");if(t.default!==void 0&&typeof t.default!="boolean")throw new TypeError("disposition.default must be a boolean.");if(t.forced!==void 0&&typeof t.forced!="boolean")throw new TypeError("disposition.forced must be a boolean.");if(t.original!==void 0&&typeof t.original!="boolean")throw new TypeError("disposition.original must be a boolean.");if(t.commentary!==void 0&&typeof t.commentary!="boolean")throw new TypeError("disposition.commentary must be a boolean.");if(t.hearingImpaired!==void 0&&typeof t.hearingImpaired!="boolean")throw new TypeError("disposition.hearingImpaired must be a boolean.");if(t.visuallyImpaired!==void 0&&typeof t.visuallyImpaired!="boolean")throw new TypeError("disposition.visuallyImpaired must be a boolean.")};const Ie=["avc","hevc","vp9","av1","vp8"],ce=["pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be","pcm-u8","pcm-s8","ulaw","alaw"],Ut=["aac","opus","mp3","vorbis","flac"],_e=[...Ut,...ce],lr=["webvtt"],ur=[{maxMacroblocks:99,maxBitrate:64e3,maxDpbMbs:396,level:10},{maxMacroblocks:396,maxBitrate:192e3,maxDpbMbs:900,level:11},{maxMacroblocks:396,maxBitrate:384e3,maxDpbMbs:2376,level:12},{maxMacroblocks:396,maxBitrate:768e3,maxDpbMbs:2376,level:13},{maxMacroblocks:396,maxBitrate:2e6,maxDpbMbs:2376,level:20},{maxMacroblocks:792,maxBitrate:4e6,maxDpbMbs:4752,level:21},{maxMacroblocks:1620,maxBitrate:4e6,maxDpbMbs:8100,level:22},{maxMacroblocks:1620,maxBitrate:1e7,maxDpbMbs:8100,level:30},{maxMacroblocks:3600,maxBitrate:14e6,maxDpbMbs:18e3,level:31},{maxMacroblocks:5120,maxBitrate:2e7,maxDpbMbs:20480,level:32},{maxMacroblocks:8192,maxBitrate:2e7,maxDpbMbs:32768,level:40},{maxMacroblocks:8192,maxBitrate:5e7,maxDpbMbs:32768,level:41},{maxMacroblocks:8704,maxBitrate:5e7,maxDpbMbs:34816,level:42},{maxMacroblocks:22080,maxBitrate:135e6,maxDpbMbs:110400,level:50},{maxMacroblocks:36864,maxBitrate:24e7,maxDpbMbs:184320,level:51},{maxMacroblocks:36864,maxBitrate:24e7,maxDpbMbs:184320,level:52},{maxMacroblocks:139264,maxBitrate:24e7,maxDpbMbs:696320,level:60},{maxMacroblocks:139264,maxBitrate:48e7,maxDpbMbs:696320,level:61},{maxMacroblocks:139264,maxBitrate:8e8,maxDpbMbs:696320,level:62}],Di=[{maxPictureSize:36864,maxBitrate:128e3,tier:"L",level:30},{maxPictureSize:122880,maxBitrate:15e5,tier:"L",level:60},{maxPictureSize:245760,maxBitrate:3e6,tier:"L",level:63},{maxPictureSize:552960,maxBitrate:6e6,tier:"L",level:90},{maxPictureSize:983040,maxBitrate:1e7,tier:"L",level:93},{maxPictureSize:2228224,maxBitrate:12e6,tier:"L",level:120},{maxPictureSize:2228224,maxBitrate:3e7,tier:"H",level:120},{maxPictureSize:2228224,maxBitrate:2e7,tier:"L",level:123},{maxPictureSize:2228224,maxBitrate:5e7,tier:"H",level:123},{maxPictureSize:8912896,maxBitrate:25e6,tier:"L",level:150},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:150},{maxPictureSize:8912896,maxBitrate:4e7,tier:"L",level:153},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:153},{maxPictureSize:8912896,maxBitrate:6e7,tier:"L",level:156},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:156},{maxPictureSize:35651584,maxBitrate:6e7,tier:"L",level:180},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:180},{maxPictureSize:35651584,maxBitrate:12e7,tier:"L",level:183},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:183},{maxPictureSize:35651584,maxBitrate:24e7,tier:"L",level:186},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:186}],Qe=[{maxPictureSize:36864,maxBitrate:2e5,level:10},{maxPictureSize:73728,maxBitrate:8e5,level:11},{maxPictureSize:122880,maxBitrate:18e5,level:20},{maxPictureSize:245760,maxBitrate:36e5,level:21},{maxPictureSize:552960,maxBitrate:72e5,level:30},{maxPictureSize:983040,maxBitrate:12e6,level:31},{maxPictureSize:2228224,maxBitrate:18e6,level:40},{maxPictureSize:2228224,maxBitrate:3e7,level:41},{maxPictureSize:8912896,maxBitrate:6e7,level:50},{maxPictureSize:8912896,maxBitrate:12e7,level:51},{maxPictureSize:8912896,maxBitrate:18e7,level:52},{maxPictureSize:35651584,maxBitrate:18e7,level:60},{maxPictureSize:35651584,maxBitrate:24e7,level:61},{maxPictureSize:35651584,maxBitrate:48e7,level:62}],zi=[{maxPictureSize:147456,maxBitrate:15e5,tier:"M",level:0},{maxPictureSize:278784,maxBitrate:3e6,tier:"M",level:1},{maxPictureSize:665856,maxBitrate:6e6,tier:"M",level:4},{maxPictureSize:1065024,maxBitrate:1e7,tier:"M",level:5},{maxPictureSize:2359296,maxBitrate:12e6,tier:"M",level:8},{maxPictureSize:2359296,maxBitrate:3e7,tier:"H",level:8},{maxPictureSize:2359296,maxBitrate:2e7,tier:"M",level:9},{maxPictureSize:2359296,maxBitrate:5e7,tier:"H",level:9},{maxPictureSize:8912896,maxBitrate:3e7,tier:"M",level:12},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:12},{maxPictureSize:8912896,maxBitrate:4e7,tier:"M",level:13},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:13},{maxPictureSize:8912896,maxBitrate:6e7,tier:"M",level:14},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:14},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:15},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:15},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:16},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:16},{maxPictureSize:35651584,maxBitrate:1e8,tier:"M",level:17},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:17},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:18},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:18},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:19},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:19}],Mi=".01.01.01.01.00",Oi=".0.110.01.01.01.0",In=(t,e,r,i)=>{if(t==="avc"){const n=Math.ceil(e/16)*Math.ceil(r/16),a=ur.find(d=>n<=d.maxMacroblocks&&i<=d.maxBitrate)??G(ur),o=a?a.level:0,c="64".padStart(2,"0"),l="00",u=o.toString(16).padStart(2,"0");return`avc1.${c}${l}${u}`}else if(t==="hevc"){const o=e*r,c=Di.find(u=>o<=u.maxPictureSize&&i<=u.maxBitrate)??G(Di);return`hev1.1.6.${c.tier}${c.level}.B0`}else{if(t==="vp8")return"vp8";if(t==="vp9"){const n=e*r;return`vp09.00.${(Qe.find(c=>n<=c.maxPictureSize&&i<=c.maxBitrate)??G(Qe)).level.toString().padStart(2,"0")}.08`}else if(t==="av1"){const n=e*r,a=zi.find(l=>n<=l.maxPictureSize&&i<=l.maxBitrate)??G(zi);return`av01.0.${a.level.toString().padStart(2,"0")}${a.tier}.08`}}throw new TypeError(`Unhandled codec '${t}'.`)},_n=t=>{const e=t.split("."),s=(1<<7)+1,n=Number(e[1]),a=e[2],o=Number(a.slice(0,-1)),c=(n<<5)+o,l=a.slice(-1)==="H"?1:0,d=Number(e[3])===8?0:1,h=0,f=e[4]?Number(e[4]):0,p=e[5]?Number(e[5][0]):1,g=e[5]?Number(e[5][1]):1,k=e[5]?Number(e[5][2]):0,w=(l<<7)+(d<<6)+(h<<5)+(f<<4)+(p<<3)+(g<<2)+k;return[s,c,w,0]},ci=t=>{const{codec:e,codecDescription:r,colorSpace:i,avcCodecInfo:s,hevcCodecInfo:n,vp9CodecInfo:a,av1CodecInfo:o}=t;if(e==="avc"){if(m(t.avcType!==null),s){const c=new Uint8Array([s.avcProfileIndication,s.profileCompatibility,s.avcLevelIndication]);return`avc${t.avcType}.${_i(c)}`}if(!r||r.byteLength<4)throw new TypeError("AVC decoder description is not provided or is not at least 4 bytes long.");return`avc${t.avcType}.${_i(r.subarray(1,4))}`}else if(e==="hevc"){let c,l,u,d,h,f;if(n)c=n.generalProfileSpace,l=n.generalProfileIdc,u=Ai(n.generalProfileCompatibilityFlags),d=n.generalTierFlag,h=n.generalLevelIdc,f=[...n.generalConstraintIndicatorFlags];else{if(!r||r.byteLength<23)throw new TypeError("HEVC decoder description is not provided or is not at least 23 bytes long.");const g=X(r),k=g.getUint8(1);c=k>>6&3,l=k&31,u=Ai(g.getUint32(2)),d=k>>5&1,h=g.getUint8(12),f=[];for(let w=0;w<6;w++)f.push(g.getUint8(6+w))}let p="hev1.";for(p+=["","A","B","C"][c]+l,p+=".",p+=u.toString(16).toUpperCase(),p+=".",p+=d===0?"L":"H",p+=h;f.length>0&&f[f.length-1]===0;)f.pop();return f.length>0&&(p+=".",p+=f.map(g=>g.toString(16).toUpperCase()).join(".")),p}else{if(e==="vp8")return"vp8";if(e==="vp9"){if(!a){const w=t.width*t.height;let b=G(Qe).level;for(const y of Qe)if(w<=y.maxPictureSize){b=y.level;break}return`vp09.00.${b.toString().padStart(2,"0")}.08`}const c=a.profile.toString().padStart(2,"0"),l=a.level.toString().padStart(2,"0"),u=a.bitDepth.toString().padStart(2,"0"),d=a.chromaSubsampling.toString().padStart(2,"0"),h=a.colourPrimaries.toString().padStart(2,"0"),f=a.transferCharacteristics.toString().padStart(2,"0"),p=a.matrixCoefficients.toString().padStart(2,"0"),g=a.videoFullRangeFlag.toString().padStart(2,"0");let k=`vp09.${c}.${l}.${u}.${d}`;return k+=`.${h}.${f}.${p}.${g}`,k.endsWith(Mi)&&(k=k.slice(0,-Mi.length)),k}else if(e==="av1"){if(!o){const y=t.width*t.height;let T=G(Qe).level;for(const x of Qe)if(y<=x.maxPictureSize){T=x.level;break}return`av01.0.${T.toString().padStart(2,"0")}M.08`}const c=o.profile,l=o.level.toString().padStart(2,"0"),u=o.tier?"H":"M",d=o.bitDepth.toString().padStart(2,"0"),h=o.monochrome?"1":"0",f=100*o.chromaSubsamplingX+10*o.chromaSubsamplingY+1*(o.chromaSubsamplingX&&o.chromaSubsamplingY?o.chromaSamplePosition:0),p=i?.primaries?Gt[i.primaries]:1,g=i?.transfer?Xt[i.transfer]:1,k=i?.matrix?Yt[i.matrix]:1,w=i?.fullRange?1:0;let b=`av01.${c}.${l}${u}.${d}`;return b+=`.${h}.${f.toString().padStart(3,"0")}`,b+=`.${p.toString().padStart(2,"0")}`,b+=`.${g.toString().padStart(2,"0")}`,b+=`.${k.toString().padStart(2,"0")}`,b+=`.${w}`,b.endsWith(Oi)&&(b=b.slice(0,-Oi.length)),b}}throw new TypeError(`Unhandled codec '${e}'.`)},An=(t,e,r)=>{if(t==="aac")return e>=2&&r<=24e3?"mp4a.40.29":r<=24e3?"mp4a.40.5":"mp4a.40.2";if(t==="mp3")return"mp3";if(t==="opus")return"opus";if(t==="vorbis")return"vorbis";if(t==="flac")return"flac";if(ce.includes(t))return t;throw new TypeError(`Unhandled codec '${t}'.`)},li=t=>{const{codec:e,codecDescription:r,aacCodecInfo:i}=t;if(e==="aac"){if(!i)throw new TypeError("AAC codec info must be provided.");if(i.isMpeg2)return"mp4a.67";{let s;return i.objectType!==null?s=i.objectType:s=ui(r).objectType,`mp4a.40.${s}`}}else{if(e==="mp3")return"mp3";if(e==="opus")return"opus";if(e==="vorbis")return"vorbis";if(e==="flac")return"flac";if(e&&ce.includes(e))return e}throw new TypeError(`Unhandled codec '${e}'.`)},ot=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350],Jt=[-1,1,2,3,4,5,6,8],ui=t=>{if(!t||t.byteLength<2)throw new TypeError("AAC description must be at least 2 bytes long.");const e=new K(t);let r=e.readBits(5);r===31&&(r=32+e.readBits(6));const i=e.readBits(4);let s=null;i===15?s=e.readBits(24):i<ot.length&&(s=ot[i]);const n=e.readBits(4);let a=null;return n>=1&&n<=7&&(a=Jt[n]),{objectType:r,frequencyIndex:i,sampleRate:s,channelConfiguration:n,numberOfChannels:a}},ms=t=>{let e=ot.indexOf(t.sampleRate),r=null;e===-1&&(e=15,r=t.sampleRate);const i=Jt.indexOf(t.numberOfChannels);if(i===-1)throw new TypeError(`Unsupported number of channels: ${t.numberOfChannels}`);let s=13;t.objectType>=32&&(s+=6),e===15&&(s+=24);const n=Math.ceil(s/8),a=new Uint8Array(n),o=new K(a);return t.objectType<32?o.writeBits(5,t.objectType):(o.writeBits(5,31),o.writeBits(6,t.objectType-32)),o.writeBits(4,e),e===15&&o.writeBits(24,r),o.writeBits(4,i),a},wr=48e3,ps=/^pcm-([usf])(\d+)+(be)?$/,Ze=t=>{if(m(ce.includes(t)),t==="ulaw")return{dataType:"ulaw",sampleSize:1,littleEndian:!0,silentValue:255};if(t==="alaw")return{dataType:"alaw",sampleSize:1,littleEndian:!0,silentValue:213};const e=ps.exec(t);m(e);let r;e[1]==="u"?r="unsigned":e[1]==="s"?r="signed":r="float";const i=Number(e[2])/8,s=e[3]!=="be",n=t==="pcm-u8"?2**7:0;return{dataType:r,sampleSize:i,littleEndian:s,silentValue:n}},gs=t=>t.startsWith("avc1")||t.startsWith("avc3")?"avc":t.startsWith("hev1")||t.startsWith("hvc1")?"hevc":t==="vp8"?"vp8":t.startsWith("vp09")?"vp9":t.startsWith("av01")?"av1":t.startsWith("mp4a.40")||t==="mp4a.67"?"aac":t==="mp3"||t==="mp4a.69"||t==="mp4a.6B"||t==="mp4a.6b"?"mp3":t==="opus"?"opus":t==="vorbis"?"vorbis":t==="flac"?"flac":t==="ulaw"?"ulaw":t==="alaw"?"alaw":ps.test(t)?t:t==="webvtt"?"webvtt":null,Fn=t=>t==="avc"?{avc:{format:"avc"}}:t==="hevc"?{hevc:{format:"hevc"}}:{},Bn=t=>t==="aac"?{aac:{format:"aac"}}:t==="opus"?{opus:{format:"opus"}}:{},Rn=["avc1","avc3","hev1","hvc1","vp8","vp09","av01"],Dn=/^(avc1|avc3)\.[0-9a-fA-F]{6}$/,zn=/^(hev1|hvc1)\.(?:[ABC]?\d+)\.[0-9a-fA-F]{1,8}\.[LH]\d+(?:\.[0-9a-fA-F]{1,2}){0,6}$/,Mn=/^vp09(?:\.\d{2}){3}(?:(?:\.\d{2}){5})?$/,On=/^av01\.\d\.\d{2}[MH]\.\d{2}(?:\.\d\.\d{3}\.\d{2}\.\d{2}\.\d{2}\.\d)?$/,Nn=t=>{if(!t)throw new TypeError("Video chunk metadata must be provided.");if(typeof t!="object")throw new TypeError("Video chunk metadata must be an object.");if(!t.decoderConfig)throw new TypeError("Video chunk metadata must include a decoder configuration.");if(typeof t.decoderConfig!="object")throw new TypeError("Video chunk metadata decoder configuration must be an object.");if(typeof t.decoderConfig.codec!="string")throw new TypeError("Video chunk metadata decoder configuration must specify a codec string.");if(!Rn.some(e=>t.decoderConfig.codec.startsWith(e)))throw new TypeError("Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(t.decoderConfig.codedWidth)||t.decoderConfig.codedWidth<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).");if(!Number.isInteger(t.decoderConfig.codedHeight)||t.decoderConfig.codedHeight<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).");if(t.decoderConfig.description!==void 0&&!gr(t.decoderConfig.description))throw new TypeError("Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(t.decoderConfig.colorSpace!==void 0){const{colorSpace:e}=t.decoderConfig;if(typeof e!="object")throw new TypeError("Video chunk metadata decoder configuration colorSpace, when provided, must be an object.");const r=Object.keys(Gt);if(e.primaries!=null&&!r.includes(e.primaries))throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of ${r.join(", ")}.`);const i=Object.keys(Xt);if(e.transfer!=null&&!i.includes(e.transfer))throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of ${i.join(", ")}.`);const s=Object.keys(Yt);if(e.matrix!=null&&!s.includes(e.matrix))throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of ${s.join(", ")}.`);if(e.fullRange!=null&&typeof e.fullRange!="boolean")throw new TypeError("Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.")}if(t.decoderConfig.codec.startsWith("avc1")||t.decoderConfig.codec.startsWith("avc3")){if(!Dn.test(t.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as specified in Section 3.4 of RFC 6381.")}else if(t.decoderConfig.codec.startsWith("hev1")||t.decoderConfig.codec.startsWith("hvc1")){if(!zn.test(t.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as specified in Section E.3 of ISO 14496-15.")}else if(t.decoderConfig.codec.startsWith("vp8")){if(t.decoderConfig.codec!=="vp8")throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be "vp8".')}else if(t.decoderConfig.codec.startsWith("vp09")){if(!Mn.test(t.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as specified in Section "Codecs Parameter String" of https://www.webmproject.org/vp9/mp4/.')}else if(t.decoderConfig.codec.startsWith("av01")&&!On.test(t.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as specified in Section "Codecs Parameter String" of https://aomediacodec.github.io/av1-isobmff/.')},Un=["mp4a","mp3","opus","vorbis","flac","ulaw","alaw","pcm"],Vn=t=>{if(!t)throw new TypeError("Audio chunk metadata must be provided.");if(typeof t!="object")throw new TypeError("Audio chunk metadata must be an object.");if(!t.decoderConfig)throw new TypeError("Audio chunk metadata must include a decoder configuration.");if(typeof t.decoderConfig!="object")throw new TypeError("Audio chunk metadata decoder configuration must be an object.");if(typeof t.decoderConfig.codec!="string")throw new TypeError("Audio chunk metadata decoder configuration must specify a codec string.");if(!Un.some(e=>t.decoderConfig.codec.startsWith(e)))throw new TypeError("Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(t.decoderConfig.sampleRate)||t.decoderConfig.sampleRate<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).");if(!Number.isInteger(t.decoderConfig.numberOfChannels)||t.decoderConfig.numberOfChannels<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).");if(t.decoderConfig.description!==void 0&&!gr(t.decoderConfig.description))throw new TypeError("Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(t.decoderConfig.codec.startsWith("mp4a")&&t.decoderConfig.codec!=="mp4a.69"&&t.decoderConfig.codec!=="mp4a.6B"&&t.decoderConfig.codec!=="mp4a.6b"){if(!["mp4a.40.2","mp4a.40.02","mp4a.40.5","mp4a.40.05","mp4a.40.29","mp4a.67"].includes(t.decoderConfig.codec))throw new TypeError("Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.")}else if(t.decoderConfig.codec.startsWith("mp3")||t.decoderConfig.codec.startsWith("mp4a")){if(t.decoderConfig.codec!=="mp3"&&t.decoderConfig.codec!=="mp4a.69"&&t.decoderConfig.codec!=="mp4a.6B"&&t.decoderConfig.codec!=="mp4a.6b")throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be "mp3", "mp4a.69" or "mp4a.6B".')}else if(t.decoderConfig.codec.startsWith("opus")){if(t.decoderConfig.codec!=="opus")throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be "opus".');if(t.decoderConfig.description&&t.decoderConfig.description.byteLength<18)throw new TypeError("Audio chunk metadata decoder configuration description, when specified, is expected to be an Identification Header as specified in Section 5.1 of RFC 7845.")}else if(t.decoderConfig.codec.startsWith("vorbis")){if(t.decoderConfig.codec!=="vorbis")throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be "vorbis".');if(!t.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.")}else if(t.decoderConfig.codec.startsWith("flac")){if(t.decoderConfig.codec!=="flac")throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be "flac".');if(!t.decoderConfig.description||t.decoderConfig.description.byteLength<42)throw new TypeError("Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.")}else if((t.decoderConfig.codec.startsWith("pcm")||t.decoderConfig.codec.startsWith("ulaw")||t.decoderConfig.codec.startsWith("alaw"))&&!ce.includes(t.decoderConfig.codec))throw new TypeError(`Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM codecs (${ce.join(", ")}).`)},Ln=t=>{if(!t)throw new TypeError("Subtitle metadata must be provided.");if(typeof t!="object")throw new TypeError("Subtitle metadata must be an object.");if(!t.config)throw new TypeError("Subtitle metadata must include a config object.");if(typeof t.config!="object")throw new TypeError("Subtitle metadata config must be an object.");if(typeof t.config.description!="string")throw new TypeError("Subtitle metadata config description must be a string.")};class Wn{constructor(e){this.mutex=new ut,this.firstMediaStreamTimestamp=null,this.trackTimestampInfo=new WeakMap,this.output=e}onTrackClose(e){}validateAndNormalizeTimestamp(e,r,i){r+=e.source._timestampOffset;let s=this.trackTimestampInfo.get(e);if(!s){if(!i)throw new Error("First packet must be a key packet.");s={maxTimestamp:r,maxTimestampBeforeLastKeyPacket:r},this.trackTimestampInfo.set(e,s)}if(r<0)throw new Error(`Timestamps must be non-negative (got ${r}s).`);if(i&&(s.maxTimestampBeforeLastKeyPacket=s.maxTimestamp),r<s.maxTimestampBeforeLastKeyPacket)throw new Error(`Timestamps cannot be smaller than the largest timestamp of the previous GOP (a GOP begins with a key packet and ends right before the next key packet). Got ${r}s, but largest timestamp is ${s.maxTimestampBeforeLastKeyPacket}s.`);return s.maxTimestamp=Math.max(s.maxTimestamp,r),r}}var Ee;(function(t){t[t.NON_IDR_SLICE=1]="NON_IDR_SLICE",t[t.SLICE_DPA=2]="SLICE_DPA",t[t.SLICE_DPB=3]="SLICE_DPB",t[t.SLICE_DPC=4]="SLICE_DPC",t[t.IDR=5]="IDR",t[t.SEI=6]="SEI",t[t.SPS=7]="SPS",t[t.PPS=8]="PPS",t[t.AUD=9]="AUD",t[t.SPS_EXT=13]="SPS_EXT"})(Ee||(Ee={}));var ae;(function(t){t[t.RASL_N=8]="RASL_N",t[t.RASL_R=9]="RASL_R",t[t.BLA_W_LP=16]="BLA_W_LP",t[t.RSV_IRAP_VCL23=23]="RSV_IRAP_VCL23",t[t.VPS_NUT=32]="VPS_NUT",t[t.SPS_NUT=33]="SPS_NUT",t[t.PPS_NUT=34]="PPS_NUT",t[t.AUD_NUT=35]="AUD_NUT",t[t.PREFIX_SEI_NUT=39]="PREFIX_SEI_NUT",t[t.SUFFIX_SEI_NUT=40]="SUFFIX_SEI_NUT"})(ae||(ae={}));const er=function*(t){let e=0,r=-1;for(;e<t.length-2;){const i=t.indexOf(0,e);if(i===-1||i>=t.length-2)break;e=i;let s=0;if(e+3<t.length&&t[e+1]===0&&t[e+2]===0&&t[e+3]===1?s=4:t[e+1]===0&&t[e+2]===1&&(s=3),s===0){e++;continue}r!==-1&&e>r&&(yield{offset:r,length:e-r}),r=e+s,e=r}r!==-1&&r<t.length&&(yield{offset:r,length:t.length-r})},ks=function*(t,e){let r=0;const i=new DataView(t.buffer,t.byteOffset,t.byteLength);for(;r+e<=t.length;){let s;e===1?s=i.getUint8(r):e===2?s=i.getUint16(r,!1):e===3?s=kr(i,r,!1):(m(e===4),s=i.getUint32(r,!1)),r+=e,yield{offset:r,length:s},r+=s}},bs=(t,e)=>{if(e.description){const s=(fe(e.description)[4]&3)+1;return ks(t,s)}else return er(t)},Hn=function*(t){yield*er(t)},yr=t=>t&31,Tr=t=>{const e=[],r=t.length;for(let i=0;i<r;i++)i+2<r&&t[i]===0&&t[i+1]===0&&t[i+2]===3?(e.push(0,0),i+=2):e.push(t[i]);return new Uint8Array(e)},vr=new Uint8Array([0,0,0,1]),qn=t=>{const e=t.reduce((s,n)=>s+vr.byteLength+n.byteLength,0),r=new Uint8Array(e);let i=0;for(const s of t)r.set(vr,i),i+=vr.byteLength,r.set(s,i),i+=s.byteLength;return r},ws=(t,e)=>{const r=t.reduce((n,a)=>n+e+a.byteLength,0),i=new Uint8Array(r);let s=0;for(const n of t){const a=new DataView(i.buffer,i.byteOffset,i.byteLength);switch(e){case 1:a.setUint8(s,n.byteLength);break;case 2:a.setUint16(s,n.byteLength,!1);break;case 3:oi(a,s,n.byteLength,!1);break;case 4:a.setUint32(s,n.byteLength,!1);break}s+=e,i.set(n,s),s+=n.byteLength}return i},jn=(t,e)=>{if(e.description){const s=(fe(e.description)[4]&3)+1;return ws(t,s)}else return qn(t)},di=t=>{try{const e=[],r=[],i=[];for(const o of Hn(t)){const c=t.subarray(o.offset,o.offset+o.length),l=yr(c[0]);l===Ee.SPS?e.push(c):l===Ee.PPS?r.push(c):l===Ee.SPS_EXT&&i.push(c)}if(e.length===0||r.length===0)return null;const s=e[0],n=hi(s);m(n!==null);const a=n.profileIdc===100||n.profileIdc===110||n.profileIdc===122||n.profileIdc===144;return{configurationVersion:1,avcProfileIndication:n.profileIdc,profileCompatibility:n.constraintFlags,avcLevelIndication:n.levelIdc,lengthSizeMinusOne:3,sequenceParameterSets:e,pictureParameterSets:r,chromaFormat:a?n.chromaFormatIdc:null,bitDepthLumaMinus8:a?n.bitDepthLumaMinus8:null,bitDepthChromaMinus8:a?n.bitDepthChromaMinus8:null,sequenceParameterSetExt:a?i:null}}catch(e){return console.error("Error building AVC Decoder Configuration Record:",e),null}},$n=t=>{const e=[];e.push(t.configurationVersion),e.push(t.avcProfileIndication),e.push(t.profileCompatibility),e.push(t.avcLevelIndication),e.push(252|t.lengthSizeMinusOne&3),e.push(224|t.sequenceParameterSets.length&31);for(const r of t.sequenceParameterSets){const i=r.byteLength;e.push(i>>8),e.push(i&255);for(let s=0;s<i;s++)e.push(r[s])}e.push(t.pictureParameterSets.length);for(const r of t.pictureParameterSets){const i=r.byteLength;e.push(i>>8),e.push(i&255);for(let s=0;s<i;s++)e.push(r[s])}if(t.avcProfileIndication===100||t.avcProfileIndication===110||t.avcProfileIndication===122||t.avcProfileIndication===144){m(t.chromaFormat!==null),m(t.bitDepthLumaMinus8!==null),m(t.bitDepthChromaMinus8!==null),m(t.sequenceParameterSetExt!==null),e.push(252|t.chromaFormat&3),e.push(248|t.bitDepthLumaMinus8&7),e.push(248|t.bitDepthChromaMinus8&7),e.push(t.sequenceParameterSetExt.length);for(const r of t.sequenceParameterSetExt){const i=r.byteLength;e.push(i>>8),e.push(i&255);for(let s=0;s<i;s++)e.push(r[s])}}return new Uint8Array(e)},Qn=t=>{try{const e=X(t);let r=0;const i=e.getUint8(r++),s=e.getUint8(r++),n=e.getUint8(r++),a=e.getUint8(r++),o=e.getUint8(r++)&3,c=e.getUint8(r++)&31,l=[];for(let f=0;f<c;f++){const p=e.getUint16(r,!1);r+=2,l.push(t.subarray(r,r+p)),r+=p}const u=e.getUint8(r++),d=[];for(let f=0;f<u;f++){const p=e.getUint16(r,!1);r+=2,d.push(t.subarray(r,r+p)),r+=p}const h={configurationVersion:i,avcProfileIndication:s,profileCompatibility:n,avcLevelIndication:a,lengthSizeMinusOne:o,sequenceParameterSets:l,pictureParameterSets:d,chromaFormat:null,bitDepthLumaMinus8:null,bitDepthChromaMinus8:null,sequenceParameterSetExt:null};if((s===100||s===110||s===122||s===144)&&r+4<=t.length){const f=e.getUint8(r++)&3,p=e.getUint8(r++)&7,g=e.getUint8(r++)&7,k=e.getUint8(r++);h.chromaFormat=f,h.bitDepthLumaMinus8=p,h.bitDepthChromaMinus8=g;const w=[];for(let b=0;b<k;b++){const y=e.getUint16(r,!1);r+=2,w.push(t.subarray(r,r+y)),r+=y}h.sequenceParameterSetExt=w}return h}catch(e){return console.error("Error deserializing AVC Decoder Configuration Record:",e),null}},hi=t=>{try{const e=new K(Tr(t));if(e.skipBits(1),e.skipBits(2),e.readBits(5)!==7)return null;const i=e.readAlignedByte(),s=e.readAlignedByte(),n=e.readAlignedByte();E(e);let a=1,o=0,c=0,l=0;if((i===100||i===110||i===122||i===244||i===44||i===83||i===86||i===118||i===128)&&(a=E(e),a===3&&(l=e.readBits(1)),o=E(e),c=E(e),e.skipBits(1),e.readBits(1))){for(let A=0;A<(a!==3?8:12);A++)if(e.readBits(1)){const W=A<6?16:64;let $=8,Q=8;for(let q=0;q<W;q++){if(Q!==0){const Z=Ue(e);Q=($+Z+256)%256}$=Q===0?$:Q}}}E(e);const u=E(e);if(u===0)E(e);else if(u===1){e.skipBits(1),Ue(e),Ue(e);const M=E(e);for(let A=0;A<M;A++)Ue(e)}E(e),e.skipBits(1);const d=E(e),h=E(e),f=16*(d+1),p=16*(h+1);let g=f,k=p;const w=e.readBits(1);if(w||e.skipBits(1),e.skipBits(1),e.readBits(1)){const M=E(e),A=E(e),z=E(e),W=E(e);let $,Q;if((l===0?a:0)===0)$=1,Q=2-w;else{const Z=a===3?1:2,ie=a===1?2:1;$=Z,Q=ie*(2-w)}g-=$*(M+A),k-=Q*(z+W)}let y=2,T=2,x=2,P=0,_=null,C=null;if(e.readBits(1)){e.readBits(1)&&e.readBits(8)===255&&(e.skipBits(16),e.skipBits(16)),e.readBits(1)&&e.skipBits(1),e.readBits(1)&&(e.skipBits(3),P=e.readBits(1),e.readBits(1)&&(y=e.readBits(8),T=e.readBits(8),x=e.readBits(8))),e.readBits(1)&&(E(e),E(e)),e.readBits(1)&&(e.skipBits(32),e.skipBits(32),e.skipBits(1));const Q=e.readBits(1);Q&&Ni(e);const q=e.readBits(1);q&&Ni(e),(Q||q)&&e.skipBits(1),e.skipBits(1),e.readBits(1)&&(e.skipBits(1),E(e),E(e),E(e),E(e),_=E(e),C=E(e))}if(_===null){m(C===null);const M=s&16;if((i===44||i===86||i===100||i===110||i===122||i===244)&&M)_=0,C=0;else{const A=d+1,z=h+1,W=(2-w)*z,$=ur.find(q=>q.level>=n)??G(ur),Q=Math.min(Math.floor($.maxDpbMbs/(A*W)),16);_=Q,C=Q}}return m(C!==null),{profileIdc:i,constraintFlags:s,levelIdc:n,frameMbsOnlyFlag:w,chromaFormatIdc:a,bitDepthLumaMinus8:o,bitDepthChromaMinus8:c,codedWidth:f,codedHeight:p,displayWidth:g,displayHeight:k,colourPrimaries:y,matrixCoefficients:x,transferCharacteristics:T,fullRangeFlag:P,numReorderFrames:_,maxDecFrameBuffering:C}}catch(e){return console.error("Error parsing AVC SPS:",e),null}},Ni=t=>{const e=E(t);t.skipBits(4),t.skipBits(4);for(let r=0;r<=e;r++)E(t),E(t),t.skipBits(1);t.skipBits(5),t.skipBits(5),t.skipBits(5),t.skipBits(5)},ys=(t,e)=>{if(e.description){const s=(fe(e.description)[21]&3)+1;return ks(t,s)}else return er(t)},Kn=function*(t){yield*er(t)},jt=t=>t>>1&63,Ts=t=>{try{const e=new K(Tr(t));e.skipBits(16),e.readBits(4);const r=e.readBits(3),i=e.readBits(1),{general_profile_space:s,general_tier_flag:n,general_profile_idc:a,general_profile_compatibility_flags:o,general_constraint_indicator_flags:c,general_level_idc:l}=Gn(e,r);E(e);const u=E(e);let d=0;u===3&&(d=e.readBits(1));const h=E(e),f=E(e);let p=h,g=f;if(e.readBits(1)){const A=E(e),z=E(e),W=E(e),$=E(e);let Q=1,q=1;const Z=d===0?u:0;Z===1?(Q=2,q=2):Z===2&&(Q=2,q=1),p-=(A+z)*Q,g-=(W+$)*q}const k=E(e),w=E(e);E(e);const y=e.readBits(1)?0:r;let T=0;for(let A=y;A<=r;A++)E(e),T=E(e),E(e);E(e),E(e),E(e),E(e),E(e),E(e),e.readBits(1)&&e.readBits(1)&&Xn(e),e.skipBits(1),e.skipBits(1),e.readBits(1)&&(e.skipBits(4),e.skipBits(4),E(e),E(e),e.skipBits(1));const x=E(e);if(Yn(e,x),e.readBits(1)){const A=E(e);for(let z=0;z<A;z++)E(e),e.skipBits(1)}e.skipBits(1),e.skipBits(1);let P=2,_=2,C=2,R=0,M=0;if(e.readBits(1)){const A=Jn(e,r);P=A.colourPrimaries,_=A.transferCharacteristics,C=A.matrixCoefficients,R=A.fullRangeFlag,M=A.minSpatialSegmentationIdc}return{displayWidth:p,displayHeight:g,colourPrimaries:P,transferCharacteristics:_,matrixCoefficients:C,fullRangeFlag:R,maxDecFrameBuffering:T+1,spsMaxSubLayersMinus1:r,spsTemporalIdNestingFlag:i,generalProfileSpace:s,generalTierFlag:n,generalProfileIdc:a,generalProfileCompatibilityFlags:o,generalConstraintIndicatorFlags:c,generalLevelIdc:l,chromaFormatIdc:u,bitDepthLumaMinus8:k,bitDepthChromaMinus8:w,minSpatialSegmentationIdc:M}}catch(e){return console.error("Error parsing HEVC SPS:",e),null}},fi=t=>{try{const e=[],r=[],i=[],s=[];for(const l of Kn(t)){const u=t.subarray(l.offset,l.offset+l.length),d=jt(u[0]);d===ae.VPS_NUT?e.push(u):d===ae.SPS_NUT?r.push(u):d===ae.PPS_NUT?i.push(u):(d===ae.PREFIX_SEI_NUT||d===ae.SUFFIX_SEI_NUT)&&s.push(u)}if(r.length===0||i.length===0)return null;const n=Ts(r[0]);if(!n)return null;let a=0;if(i.length>0){const l=i[0],u=new K(Tr(l));u.skipBits(16),E(u),E(u),u.skipBits(1),u.skipBits(1),u.skipBits(3),u.skipBits(1),u.skipBits(1),E(u),E(u),Ue(u),u.skipBits(1),u.skipBits(1),u.readBits(1)&&E(u),Ue(u),Ue(u),u.skipBits(1),u.skipBits(1),u.skipBits(1),u.skipBits(1);const d=u.readBits(1),h=u.readBits(1);!d&&!h?a=0:d&&!h?a=2:!d&&h?a=3:a=0}const o=[...e.length?[{arrayCompleteness:1,nalUnitType:ae.VPS_NUT,nalUnits:e}]:[],...r.length?[{arrayCompleteness:1,nalUnitType:ae.SPS_NUT,nalUnits:r}]:[],...i.length?[{arrayCompleteness:1,nalUnitType:ae.PPS_NUT,nalUnits:i}]:[],...s.length?[{arrayCompleteness:1,nalUnitType:jt(s[0][0]),nalUnits:s}]:[]];return{configurationVersion:1,generalProfileSpace:n.generalProfileSpace,generalTierFlag:n.generalTierFlag,generalProfileIdc:n.generalProfileIdc,generalProfileCompatibilityFlags:n.generalProfileCompatibilityFlags,generalConstraintIndicatorFlags:n.generalConstraintIndicatorFlags,generalLevelIdc:n.generalLevelIdc,minSpatialSegmentationIdc:n.minSpatialSegmentationIdc,parallelismType:a,chromaFormatIdc:n.chromaFormatIdc,bitDepthLumaMinus8:n.bitDepthLumaMinus8,bitDepthChromaMinus8:n.bitDepthChromaMinus8,avgFrameRate:0,constantFrameRate:0,numTemporalLayers:n.spsMaxSubLayersMinus1+1,temporalIdNested:n.spsTemporalIdNestingFlag,lengthSizeMinusOne:3,arrays:o}}catch(e){return console.error("Error building HEVC Decoder Configuration Record:",e),null}},Gn=(t,e)=>{const r=t.readBits(2),i=t.readBits(1),s=t.readBits(5);let n=0;for(let u=0;u<32;u++)n=n<<1|t.readBits(1);const a=new Uint8Array(6);for(let u=0;u<6;u++)a[u]=t.readBits(8);const o=t.readBits(8),c=[],l=[];for(let u=0;u<e;u++)c.push(t.readBits(1)),l.push(t.readBits(1));if(e>0)for(let u=e;u<8;u++)t.skipBits(2);for(let u=0;u<e;u++)c[u]&&t.skipBits(88),l[u]&&t.skipBits(8);return{general_profile_space:r,general_tier_flag:i,general_profile_idc:s,general_profile_compatibility_flags:n,general_constraint_indicator_flags:a,general_level_idc:o}},Xn=t=>{for(let e=0;e<4;e++)for(let r=0;r<(e===3?2:6);r++)if(!t.readBits(1))E(t);else{const s=Math.min(64,1<<4+(e<<1));e>1&&Ue(t);for(let n=0;n<s;n++)Ue(t)}},Yn=(t,e)=>{const r=[];for(let i=0;i<e;i++)r[i]=Zn(t,i,e,r)},Zn=(t,e,r,i)=>{let s=0,n=0,a=0;if(e!==0&&(n=t.readBits(1)),n){if(e===r){const c=E(t);a=e-(c+1)}else a=e-1;t.readBits(1),E(t);const o=i[a]??0;for(let c=0;c<=o;c++)t.readBits(1)||t.readBits(1);s=i[a]}else{const o=E(t),c=E(t);for(let l=0;l<o;l++)E(t),t.readBits(1);for(let l=0;l<c;l++)E(t),t.readBits(1);s=o+c}return s},Jn=(t,e)=>{let r=2,i=2,s=2,n=0,a=0;return t.readBits(1)&&t.readBits(8)===255&&(t.readBits(16),t.readBits(16)),t.readBits(1)&&t.readBits(1),t.readBits(1)&&(t.readBits(3),n=t.readBits(1),t.readBits(1)&&(r=t.readBits(8),i=t.readBits(8),s=t.readBits(8))),t.readBits(1)&&(E(t),E(t)),t.readBits(1),t.readBits(1),t.readBits(1),t.readBits(1)&&(E(t),E(t),E(t),E(t)),t.readBits(1)&&(t.readBits(32),t.readBits(32),t.readBits(1)&&E(t),t.readBits(1)&&ea(t,!0,e)),t.readBits(1)&&(t.readBits(1),t.readBits(1),t.readBits(1),a=E(t),E(t),E(t),E(t),E(t)),{colourPrimaries:r,transferCharacteristics:i,matrixCoefficients:s,fullRangeFlag:n,minSpatialSegmentationIdc:a}},ea=(t,e,r)=>{let i=!1,s=!1,n=!1;i=t.readBits(1)===1,s=t.readBits(1)===1,(i||s)&&(n=t.readBits(1)===1,n&&(t.readBits(8),t.readBits(5),t.readBits(1),t.readBits(5)),t.readBits(4),t.readBits(4),n&&t.readBits(4),t.readBits(5),t.readBits(5),t.readBits(5));for(let a=0;a<=r;a++){const o=t.readBits(1)===1;let c=!0;o||(c=t.readBits(1)===1);let l=!1;c?E(t):l=t.readBits(1)===1;let u=1;l||(u=E(t)+1),i&&Ui(t,u,n),s&&Ui(t,u,n)}},Ui=(t,e,r)=>{for(let i=0;i<e;i++)E(t),E(t),r&&(E(t),E(t)),t.readBits(1)},ta=t=>{const e=[];e.push(t.configurationVersion),e.push((t.generalProfileSpace&3)<<6|(t.generalTierFlag&1)<<5|t.generalProfileIdc&31),e.push(t.generalProfileCompatibilityFlags>>>24&255),e.push(t.generalProfileCompatibilityFlags>>>16&255),e.push(t.generalProfileCompatibilityFlags>>>8&255),e.push(t.generalProfileCompatibilityFlags&255),e.push(...t.generalConstraintIndicatorFlags),e.push(t.generalLevelIdc&255),e.push(240|t.minSpatialSegmentationIdc>>8&15),e.push(t.minSpatialSegmentationIdc&255),e.push(252|t.parallelismType&3),e.push(252|t.chromaFormatIdc&3),e.push(248|t.bitDepthLumaMinus8&7),e.push(248|t.bitDepthChromaMinus8&7),e.push(t.avgFrameRate>>8&255),e.push(t.avgFrameRate&255),e.push((t.constantFrameRate&3)<<6|(t.numTemporalLayers&7)<<3|(t.temporalIdNested&1)<<2|t.lengthSizeMinusOne&3),e.push(t.arrays.length&255);for(const r of t.arrays){e.push((r.arrayCompleteness&1)<<7|0|r.nalUnitType&63),e.push(r.nalUnits.length>>8&255),e.push(r.nalUnits.length&255);for(const i of r.nalUnits){e.push(i.length>>8&255),e.push(i.length&255);for(let s=0;s<i.length;s++)e.push(i[s])}}return new Uint8Array(e)},Ss=t=>{const e=new K(t);if(e.readBits(2)!==2)return null;const i=e.readBits(1),n=(e.readBits(1)<<1)+i;if(n===3&&e.skipBits(1),e.readBits(1)===1||e.readBits(1)!==0||(e.skipBits(2),e.readBits(24)!==4817730))return null;let l=8;n>=2&&(l=e.readBits(1)?12:10);const u=e.readBits(3);let d=0,h=0;if(u!==7)if(h=e.readBits(1),n===1||n===3){const _=e.readBits(1),C=e.readBits(1);d=!_&&!C?3:_&&!C?2:1,e.skipBits(1)}else d=1;else d=3,h=1;const f=e.readBits(16),p=e.readBits(16),g=f+1,k=p+1,w=g*k;let b=G(Qe).level;for(const P of Qe)if(w<=P.maxPictureSize){b=P.level;break}return{profile:n,level:b,bitDepth:l,chromaSubsampling:d,videoFullRangeFlag:h,colourPrimaries:u===2?1:u===1?6:2,transferCharacteristics:u===2?1:u===1?6:2,matrixCoefficients:u===7?0:u===2?1:u===1?6:2}},Ps=function*(t){const e=new K(t),r=()=>{let i=0;for(let s=0;s<8;s++){const n=e.readAlignedByte();if(i|=(n&127)<<s*7,!(n&128))break;if(s===7&&n&128)return null}return i>=2**32-1?null:i};for(;e.getBitsLeft()>=8;){e.skipBits(1);const i=e.readBits(4),s=e.readBits(1),n=e.readBits(1);e.skipBits(1),s&&e.skipBits(8);let a;if(n){const o=r();if(o===null)return;a=o}else a=Math.floor(e.getBitsLeft()/8);m(e.pos%8===0),yield{type:i,data:t.subarray(e.pos/8,e.pos/8+a)},e.skipBits(a*8)}},xs=t=>{for(const{type:e,data:r}of Ps(t)){if(e!==1)continue;const i=new K(r),s=i.readBits(3);i.readBits(1);const n=i.readBits(1);let a=0,o=0,c=0;if(n)a=i.readBits(5);else{if(i.readBits(1)&&(i.skipBits(32),i.skipBits(32),i.readBits(1)))return null;const x=i.readBits(1);x&&(c=i.readBits(5),i.skipBits(32),i.skipBits(5),i.skipBits(5));const P=i.readBits(5);for(let _=0;_<=P;_++){i.skipBits(12);const C=i.readBits(5);if(_===0&&(a=C),C>7){const M=i.readBits(1);_===0&&(o=M)}if(x&&i.readBits(1)){const A=c+1;i.skipBits(A),i.skipBits(A),i.skipBits(1)}i.readBits(1)&&i.skipBits(4)}}const l=i.readBits(4),u=i.readBits(4),d=l+1;i.skipBits(d);const h=u+1;i.skipBits(h);let f=0;if(n?f=0:f=i.readBits(1),f&&(i.skipBits(4),i.skipBits(3)),i.skipBits(1),i.skipBits(1),i.skipBits(1),!n){i.skipBits(1),i.skipBits(1),i.skipBits(1),i.skipBits(1);const T=i.readBits(1);T&&(i.skipBits(1),i.skipBits(1));const x=i.readBits(1);let P=0;x?P=2:P=i.readBits(1),P>0&&(i.readBits(1)||i.skipBits(1)),T&&i.skipBits(3)}i.skipBits(1),i.skipBits(1),i.skipBits(1);const p=i.readBits(1);let g=8;s===2&&p?g=i.readBits(1)?12:10:s<=2&&(g=p?10:8);let k=0;s!==1&&(k=i.readBits(1));let w=1,b=1,y=0;return k||(s===0?(w=1,b=1):s===1?(w=0,b=0):g===12&&(w=i.readBits(1),w&&(b=i.readBits(1))),w&&b&&(y=i.readBits(2))),{profile:s,level:a,tier:o,bitDepth:g,monochrome:k,chromaSubsamplingX:w,chromaSubsamplingY:b,chromaSamplePosition:y}}return null},Cs=t=>{const e=X(t),r=e.getUint8(9),i=e.getUint16(10,!0),s=e.getUint32(12,!0),n=e.getInt16(16,!0),a=e.getUint8(18);let o=null;return a&&(o=t.subarray(19,21+r)),{outputChannelCount:r,preSkip:i,inputSampleRate:s,outputGain:n,channelMappingFamily:a,channelMappingTable:o}},ra=[480,960,1920,2880,480,960,1920,2880,480,960,1920,2880,480,960,480,960,120,240,480,960,120,240,480,960,120,240,480,960,120,240,480,960],ia=t=>{const e=t[0]>>3;return{durationInSamples:ra[e]}},sa=t=>{if(t.length<7)throw new Error("Setup header is too short.");if(t[0]!==5)throw new Error("Wrong packet type in Setup header.");if(String.fromCharCode(...t.slice(1,7))!=="vorbis")throw new Error("Invalid packet signature in Setup header.");const r=t.length,i=new Uint8Array(r);for(let d=0;d<r;d++)i[d]=t[r-1-d];const s=new K(i);let n=0;for(;s.getBitsLeft()>97;)if(s.readBits(1)===1){n=s.pos;break}if(n===0)throw new Error("Invalid Setup header: framing bit not found.");let a=0,o=!1,c=0;for(;s.getBitsLeft()>=97;){const d=s.pos,h=s.readBits(8),f=s.readBits(16),p=s.readBits(16);if(h>63||f!==0||p!==0){s.pos=d;break}if(s.skipBits(1),a++,a>64)break;s.clone().readBits(6)+1===a&&(o=!0,c=a)}if(!o)throw new Error("Invalid Setup header: mode header not found.");if(c>63)throw new Error(`Unsupported mode count: ${c}.`);const l=c;s.pos=0,s.skipBits(n);const u=Array(l).fill(0);for(let d=l-1;d>=0;d--)s.skipBits(40),u[d]=s.readBits(1);return{modeBlockflags:u}},mi=(t,e,r)=>{switch(t){case"avc":{for(const i of bs(r,e)){const s=r[i.offset],n=yr(s);if(n>=Ee.NON_IDR_SLICE&&n<=Ee.SLICE_DPC)return"delta";if(n===Ee.IDR)return"key";if(n===Ee.SEI&&(!Hr()||Cn()>=144)){const a=r.subarray(i.offset,i.offset+i.length),o=Tr(a);let c=1;do{let l=0;for(;;){const h=o[c++];if(h===void 0||(l+=h,h<255))break}let u=0;for(;;){const h=o[c++];if(h===void 0||(u+=h,h<255))break}if(l===6){const h=new K(o);h.pos=8*c;const f=E(h),p=h.readBits(1);if(f===0&&p===1)return"key"}c+=u}while(c<o.length-1)}}return"delta"}case"hevc":{for(const i of ys(r,e)){const s=jt(r[i.offset]);if(s<ae.BLA_W_LP)return"delta";if(s<=ae.RSV_IRAP_VCL23)return"key"}return"delta"}case"vp8":return(r[0]&1)===0?"key":"delta";case"vp9":{const i=new K(r);if(i.readBits(2)!==2)return null;const s=i.readBits(1);return(i.readBits(1)<<1)+s===3&&i.skipBits(1),i.readBits(1)?null:i.readBits(1)===0?"key":"delta"}case"av1":{let i=!1;for(const{type:s,data:n}of Ps(r))if(s===1){const a=new K(n);a.skipBits(4),i=!!a.readBits(1)}else if(s===3||s===6||s===7){if(i)return"key";const a=new K(n);return a.readBits(1)?null:a.readBits(2)===0?"key":"delta"}return null}default:Xe(t),m(!1)}};var It;(function(t){t[t.STREAMINFO=0]="STREAMINFO",t[t.VORBIS_COMMENT=4]="VORBIS_COMMENT",t[t.PICTURE=6]="PICTURE"})(It||(It={}));const jr=(t,e)=>{const r=X(t);let i=0;const s=r.getUint32(i,!0);i+=4;const n=ke.decode(t.subarray(i,i+s));i+=s,s>0&&(e.raw??={},e.raw.vendor??=n);const a=r.getUint32(i,!0);i+=4;for(let o=0;o<a;o++){const c=r.getUint32(i,!0);i+=4;const l=ke.decode(t.subarray(i,i+c));i+=c;const u=l.indexOf("=");if(u===-1)continue;const d=l.slice(0,u).toUpperCase(),h=l.slice(u+1);switch(e.raw??={},e.raw[d]??=h,d){case"TITLE":e.title??=h;break;case"DESCRIPTION":e.description??=h;break;case"ARTIST":e.artist??=h;break;case"ALBUM":e.album??=h;break;case"ALBUMARTIST":e.albumArtist??=h;break;case"COMMENT":e.comment??=h;break;case"LYRICS":e.lyrics??=h;break;case"TRACKNUMBER":{const f=h.split("/"),p=Number.parseInt(f[0],10),g=f[1]&&Number.parseInt(f[1],10);Number.isInteger(p)&&p>0&&(e.trackNumber??=p),g&&Number.isInteger(g)&&g>0&&(e.tracksTotal??=g)}break;case"TRACKTOTAL":{const f=Number.parseInt(h,10);Number.isInteger(f)&&f>0&&(e.tracksTotal??=f)}break;case"DISCNUMBER":{const f=h.split("/"),p=Number.parseInt(f[0],10),g=f[1]&&Number.parseInt(f[1],10);Number.isInteger(p)&&p>0&&(e.discNumber??=p),g&&Number.isInteger(g)&&g>0&&(e.discsTotal??=g)}break;case"DISCTOTAL":{const f=Number.parseInt(h,10);Number.isInteger(f)&&f>0&&(e.discsTotal??=f)}break;case"DATE":{const f=new Date(h);Number.isNaN(f.getTime())||(e.date??=f)}break;case"GENRE":e.genre??=h;break;case"METADATA_BLOCK_PICTURE":{const f=vn(h),p=X(f),g=p.getUint32(0,!1),k=p.getUint32(4,!1),w=String.fromCharCode(...f.subarray(8,8+k)),b=p.getUint32(8+k,!1),y=ke.decode(f.subarray(12+k,12+k+b)),T=p.getUint32(k+b+28),x=f.subarray(k+b+32,k+b+32+T);e.images??=[],e.images.push({data:x,mimeType:w,kind:g===3?"coverFront":g===4?"coverBack":"unknown",name:void 0,description:y||void 0})}break}}};class Je{constructor(e){this.input=e}}const vs=[],Es=[],$r=[],Qr=[];const me=new Uint8Array(0);class j{constructor(e,r,i,s,n=-1,a,o){if(this.data=e,this.type=r,this.timestamp=i,this.duration=s,this.sequenceNumber=n,e===me&&a===void 0)throw new Error("Internal error: byteLength must be explicitly provided when constructing metadata-only packets.");if(a===void 0&&(a=e.byteLength),!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(r!=="key"&&r!=="delta")throw new TypeError('type must be either "key" or "delta".');if(!Number.isFinite(i))throw new TypeError("timestamp must be a number.");if(!Number.isFinite(s)||s<0)throw new TypeError("duration must be a non-negative number.");if(!Number.isFinite(n))throw new TypeError("sequenceNumber must be a number.");if(!Number.isInteger(a)||a<0)throw new TypeError("byteLength must be a non-negative integer.");if(o!==void 0&&(typeof o!="object"||!o))throw new TypeError("sideData, when provided, must be an object.");if(o?.alpha!==void 0&&!(o.alpha instanceof Uint8Array))throw new TypeError("sideData.alpha, when provided, must be a Uint8Array.");if(o?.alphaByteLength!==void 0&&(!Number.isInteger(o.alphaByteLength)||o.alphaByteLength<0))throw new TypeError("sideData.alphaByteLength, when provided, must be a non-negative integer.");this.byteLength=a,this.sideData=o??{},this.sideData.alpha&&this.sideData.alphaByteLength===void 0&&(this.sideData.alphaByteLength=this.sideData.alpha.byteLength)}get isMetadataOnly(){return this.data===me}get microsecondTimestamp(){return Math.trunc($e*this.timestamp)}get microsecondDuration(){return Math.trunc($e*this.duration)}toEncodedVideoChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if(typeof EncodedVideoChunk>"u")throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}alphaToEncodedVideoChunk(e=this.type){if(!this.sideData.alpha)throw new TypeError("This packet does not contain alpha side data.");if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if(typeof EncodedVideoChunk>"u")throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.sideData.alpha,type:e,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}toEncodedAudioChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to an audio chunk.");if(typeof EncodedAudioChunk>"u")throw new Error("Your browser does not support EncodedAudioChunk.");return new EncodedAudioChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}static fromEncodedChunk(e,r){if(!(e instanceof EncodedVideoChunk||e instanceof EncodedAudioChunk))throw new TypeError("chunk must be an EncodedVideoChunk or EncodedAudioChunk.");const i=new Uint8Array(e.byteLength);return e.copyTo(i),new j(i,e.type,e.timestamp/1e6,(e.duration??0)/1e6,void 0,void 0,r)}clone(e){if(e!==void 0&&(typeof e!="object"||e===null))throw new TypeError("options, when provided, must be an object.");if(e?.data!==void 0&&!(e.data instanceof Uint8Array))throw new TypeError("options.data, when provided, must be a Uint8Array.");if(e?.type!==void 0&&e.type!=="key"&&e.type!=="delta")throw new TypeError('options.type, when provided, must be either "key" or "delta".');if(e?.timestamp!==void 0&&!Number.isFinite(e.timestamp))throw new TypeError("options.timestamp, when provided, must be a number.");if(e?.duration!==void 0&&!Number.isFinite(e.duration))throw new TypeError("options.duration, when provided, must be a number.");if(e?.sequenceNumber!==void 0&&!Number.isFinite(e.sequenceNumber))throw new TypeError("options.sequenceNumber, when provided, must be a number.");if(e?.sideData!==void 0&&(typeof e.sideData!="object"||e.sideData===null))throw new TypeError("options.sideData, when provided, must be an object.");return new j(e?.data??this.data,e?.type??this.type,e?.timestamp??this.timestamp,e?.duration??this.duration,e?.sequenceNumber??this.sequenceNumber,this.byteLength,e?.sideData??this.sideData)}}const na=t=>{let i=t,s=4096,n=0,a=12,o=0;for(i<0&&(i=-i,n=128),i+=33,i>8191&&(i=8191);(i&s)!==s&&a>=5;)s>>=1,a--;return o=i>>a-4&15,~(n|a-5<<4|o)&255},aa=t=>{let r=0,i=0,s=~t;s&128&&(s&=-129,r=-1),i=((s&240)>>4)+5;const n=(1<<i|(s&15)<<i-4|1<<i-5)-33;return r===0?n:-n},oa=t=>{let r=2048,i=0,s=11,n=0,a=t;for(a<0&&(a=-a,i=128),a>4095&&(a=4095);(a&r)!==r&&s>=5;)r>>=1,s--;return n=a>>(s===4?1:s-4)&15,(i|s-4<<4|n)^85},ca=t=>{let e=0,r=0,i=t^85;i&128&&(i&=-129,e=-1),r=((i&240)>>4)+4;let s=0;return r!==4?s=1<<r|(i&15)<<r-4|1<<r-5:s=i<<1|1,e===0?s:-s};ds();let Vi=-1/0,Li=-1/0,$t=null;typeof FinalizationRegistry<"u"&&($t=new FinalizationRegistry(t=>{const e=Date.now();t.type==="video"?(e-Vi>=1e3&&(console.error("A VideoSample was garbage collected without first being closed. For proper resource management, make sure to call close() on all your VideoSamples as soon as you're done using them."),Vi=e),typeof VideoFrame<"u"&&t.data instanceof VideoFrame&&t.data.close()):(e-Li>=1e3&&(console.error("An AudioSample was garbage collected without first being closed. For proper resource management, make sure to call close() on all your AudioSamples as soon as you're done using them."),Li=e),typeof AudioData<"u"&&t.data instanceof AudioData&&t.data.close())}));const Is=["I420","I420P10","I420P12","I420A","I420AP10","I420AP12","I422","I422P10","I422P12","I422A","I422AP10","I422AP12","I444","I444P10","I444P12","I444A","I444AP10","I444AP12","NV12","RGBA","RGBX","BGRA","BGRX"],la=new Set(Is);class oe{get displayWidth(){return this.rotation%180===0?this.codedWidth:this.codedHeight}get displayHeight(){return this.rotation%180===0?this.codedHeight:this.codedWidth}get microsecondTimestamp(){return Math.trunc($e*this.timestamp)}get microsecondDuration(){return Math.trunc($e*this.duration)}get hasAlpha(){return this.format&&this.format.includes("A")}constructor(e,r){if(this._closed=!1,e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer||ArrayBuffer.isView(e)){if(!r||typeof r!="object")throw new TypeError("init must be an object.");if(r.format===void 0||!la.has(r.format))throw new TypeError("init.format must be one of: "+Is.join(", "));if(!Number.isInteger(r.codedWidth)||r.codedWidth<=0)throw new TypeError("init.codedWidth must be a positive integer.");if(!Number.isInteger(r.codedHeight)||r.codedHeight<=0)throw new TypeError("init.codedHeight must be a positive integer.");if(r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(r.timestamp))throw new TypeError("init.timestamp must be a number.");if(r.duration!==void 0&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=fe(e).slice(),this._layout=r.layout??ua(r.format,r.codedWidth,r.codedHeight),this.format=r.format,this.codedWidth=r.codedWidth,this.codedHeight=r.codedHeight,this.rotation=r.rotation??0,this.timestamp=r.timestamp,this.duration=r.duration??0,this.colorSpace=new Er(r.colorSpace)}else if(typeof VideoFrame<"u"&&e instanceof VideoFrame){if(r?.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(r?.timestamp!==void 0&&!Number.isFinite(r?.timestamp))throw new TypeError("init.timestamp, when provided, must be a number.");if(r?.duration!==void 0&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=e,this._layout=null,this.format=e.format,this.codedWidth=e.displayWidth,this.codedHeight=e.displayHeight,this.rotation=r?.rotation??0,this.timestamp=r?.timestamp??e.timestamp/1e6,this.duration=r?.duration??(e.duration??0)/1e6,this.colorSpace=new Er(e.colorSpace)}else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof SVGImageElement<"u"&&e instanceof SVGImageElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas){if(!r||typeof r!="object")throw new TypeError("init must be an object.");if(r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(r.timestamp))throw new TypeError("init.timestamp must be a number.");if(r.duration!==void 0&&(!Number.isFinite(r.duration)||r.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");if(typeof VideoFrame<"u")return new oe(new VideoFrame(e,{timestamp:Math.trunc(r.timestamp*$e),duration:Math.trunc((r.duration??0)*$e)||void 0}),r);let i=0,s=0;if("naturalWidth"in e?(i=e.naturalWidth,s=e.naturalHeight):"videoWidth"in e?(i=e.videoWidth,s=e.videoHeight):"width"in e&&(i=Number(e.width),s=Number(e.height)),!i||!s)throw new TypeError("Could not determine dimensions.");const n=new OffscreenCanvas(i,s),a=n.getContext("2d",{alpha:Ft(),willReadFrequently:!0});m(a),a.drawImage(e,0,0),this._data=n,this._layout=null,this.format="RGBX",this.codedWidth=i,this.codedHeight=s,this.rotation=r.rotation??0,this.timestamp=r.timestamp,this.duration=r.duration??0,this.colorSpace=new Er({matrix:"rgb",primaries:"bt709",transfer:"iec61966-2-1",fullRange:!0})}else throw new TypeError("Invalid data type: Must be a BufferSource or CanvasImageSource.");$t?.register(this,{type:"video",data:this._data},this)}clone(){if(this._closed)throw new Error("VideoSample is closed.");return m(this._data!==null),et(this._data)?new oe(this._data.clone(),{timestamp:this.timestamp,duration:this.duration,rotation:this.rotation}):this._data instanceof Uint8Array?(m(this._layout),new oe(this._data,{format:this.format,layout:this._layout,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation})):new oe(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation})}close(){this._closed||($t?.unregister(this),et(this._data)?this._data.close():this._data=null,this._closed=!0)}allocationSize(e={}){if(Wi(e),this._closed)throw new Error("VideoSample is closed.");if(this.format===null)throw new Error("Cannot get allocation size when format is null. Sorry!");if(m(this._data!==null),!et(this._data)&&(e.colorSpace||e.format&&e.format!==this.format||e.layout||e.rect)){const r=this.toVideoFrame(),i=r.allocationSize(e);return r.close(),i}return et(this._data)?this._data.allocationSize(e):this._data instanceof Uint8Array?this._data.byteLength:this.codedWidth*this.codedHeight*4}async copyTo(e,r={}){if(!gr(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(Wi(r),this._closed)throw new Error("VideoSample is closed.");if(this.format===null)throw new Error("Cannot copy video sample data when format is null. Sorry!");if(m(this._data!==null),!et(this._data)&&(r.colorSpace||r.format&&r.format!==this.format||r.layout||r.rect)){const i=this.toVideoFrame(),s=await i.copyTo(e,r);return i.close(),s}if(et(this._data))return this._data.copyTo(e,r);if(this._data instanceof Uint8Array)return m(this._layout),fe(e).set(this._data),this._layout;{const s=this._data.getContext("2d");m(s);const n=s.getImageData(0,0,this.codedWidth,this.codedHeight);return fe(e).set(n.data),[{offset:0,stride:4*this.codedWidth}]}}toVideoFrame(){if(this._closed)throw new Error("VideoSample is closed.");return m(this._data!==null),et(this._data)?new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0}):this._data instanceof Uint8Array?new VideoFrame(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0,colorSpace:this.colorSpace}):new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0})}draw(e,r,i,s,n,a,o,c,l){let u=0,d=0,h=this.displayWidth,f=this.displayHeight,p=0,g=0,k=this.displayWidth,w=this.displayHeight;if(a!==void 0?(u=r,d=i,h=s,f=n,p=a,g=o,c!==void 0?(k=c,w=l):(k=h,w=f)):(p=r,g=i,s!==void 0&&(k=s,w=n)),!(typeof CanvasRenderingContext2D<"u"&&e instanceof CanvasRenderingContext2D||typeof OffscreenCanvasRenderingContext2D<"u"&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!Number.isFinite(u))throw new TypeError("sx must be a number.");if(!Number.isFinite(d))throw new TypeError("sy must be a number.");if(!Number.isFinite(h)||h<0)throw new TypeError("sWidth must be a non-negative number.");if(!Number.isFinite(f)||f<0)throw new TypeError("sHeight must be a non-negative number.");if(!Number.isFinite(p))throw new TypeError("dx must be a number.");if(!Number.isFinite(g))throw new TypeError("dy must be a number.");if(!Number.isFinite(k)||k<0)throw new TypeError("dWidth must be a non-negative number.");if(!Number.isFinite(w)||w<0)throw new TypeError("dHeight must be a non-negative number.");if(this._closed)throw new Error("VideoSample is closed.");({sx:u,sy:d,sWidth:h,sHeight:f}=this._rotateSourceRegion(u,d,h,f,this.rotation));const b=this.toCanvasImageSource();e.save();const y=p+k/2,T=g+w/2;e.translate(y,T),e.rotate(this.rotation*Math.PI/180);const x=this.rotation%180===0?1:k/w;e.scale(1/x,x),e.drawImage(b,u,d,h,f,-k/2,-w/2,k,w),e.restore()}drawWithFit(e,r){if(!(typeof CanvasRenderingContext2D<"u"&&e instanceof CanvasRenderingContext2D||typeof OffscreenCanvasRenderingContext2D<"u"&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(!["fill","contain","cover"].includes(r.fit))throw new TypeError("options.fit must be 'fill', 'contain', or 'cover'.");if(r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("options.rotation, when provided, must be 0, 90, 180, or 270.");r.crop!==void 0&&gi(r.crop,"options.");const i=e.canvas.width,s=e.canvas.height,n=r.rotation??this.rotation,[a,o]=n%180===0?[this.codedWidth,this.codedHeight]:[this.codedHeight,this.codedWidth];r.crop&&pi(r.crop,a,o);let c,l,u,d;const{sx:h,sy:f,sWidth:p,sHeight:g}=this._rotateSourceRegion(r.crop?.left??0,r.crop?.top??0,r.crop?.width??a,r.crop?.height??o,n);if(r.fit==="fill")c=0,l=0,u=i,d=s;else{const[w,b]=r.crop?[r.crop.width,r.crop.height]:[a,o],y=r.fit==="contain"?Math.min(i/w,s/b):Math.max(i/w,s/b);u=w*y,d=b*y,c=(i-u)/2,l=(s-d)/2}e.save();const k=n%180===0?1:u/d;e.translate(i/2,s/2),e.rotate(n*Math.PI/180),e.scale(1/k,k),e.translate(-i/2,-s/2),e.drawImage(this.toCanvasImageSource(),h,f,p,g,c,l,u,d),e.restore()}_rotateSourceRegion(e,r,i,s,n){return n===90?[e,r,i,s]=[r,this.codedHeight-e-i,s,i]:n===180?[e,r]=[this.codedWidth-e-i,this.codedHeight-r-s]:n===270&&([e,r,i,s]=[this.codedWidth-r-s,e,s,i]),{sx:e,sy:r,sWidth:i,sHeight:s}}toCanvasImageSource(){if(this._closed)throw new Error("VideoSample is closed.");if(m(this._data!==null),this._data instanceof Uint8Array){const e=this.toVideoFrame();return queueMicrotask(()=>e.close()),e}else return this._data}setRotation(e){if(![0,90,180,270].includes(e))throw new TypeError("newRotation must be 0, 90, 180, or 270.");this.rotation=e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}setDuration(e){if(!Number.isFinite(e)||e<0)throw new TypeError("newDuration must be a non-negative number.");this.duration=e}[Symbol.dispose](){this.close()}}class Er{constructor(e){this.primaries=e?.primaries??null,this.transfer=e?.transfer??null,this.matrix=e?.matrix??null,this.fullRange=e?.fullRange??null}toJSON(){return{primaries:this.primaries,transfer:this.transfer,matrix:this.matrix,fullRange:this.fullRange}}}const et=t=>typeof VideoFrame<"u"&&t instanceof VideoFrame,pi=(t,e,r)=>{t.left=Math.min(t.left,e),t.top=Math.min(t.top,r),t.width=Math.min(t.width,e-t.left),t.height=Math.min(t.height,r-t.top),m(t.width>=0),m(t.height>=0)},gi=(t,e)=>{if(!t||typeof t!="object")throw new TypeError(e+"crop, when provided, must be an object.");if(!Number.isInteger(t.left)||t.left<0)throw new TypeError(e+"crop.left must be a non-negative integer.");if(!Number.isInteger(t.top)||t.top<0)throw new TypeError(e+"crop.top must be a non-negative integer.");if(!Number.isInteger(t.width)||t.width<0)throw new TypeError(e+"crop.width must be a non-negative integer.");if(!Number.isInteger(t.height)||t.height<0)throw new TypeError(e+"crop.height must be a non-negative integer.")},Wi=t=>{if(!t||typeof t!="object")throw new TypeError("options must be an object.");if(t.colorSpace!==void 0&&!["display-p3","srgb"].includes(t.colorSpace))throw new TypeError("options.colorSpace, when provided, must be 'display-p3' or 'srgb'.");if(t.format!==void 0&&typeof t.format!="string")throw new TypeError("options.format, when provided, must be a string.");if(t.layout!==void 0){if(!Array.isArray(t.layout))throw new TypeError("options.layout, when provided, must be an array.");for(const e of t.layout){if(!e||typeof e!="object")throw new TypeError("Each entry in options.layout must be an object.");if(!Number.isInteger(e.offset)||e.offset<0)throw new TypeError("plane.offset must be a non-negative integer.");if(!Number.isInteger(e.stride)||e.stride<0)throw new TypeError("plane.stride must be a non-negative integer.")}}if(t.rect!==void 0){if(!t.rect||typeof t.rect!="object")throw new TypeError("options.rect, when provided, must be an object.");if(t.rect.x!==void 0&&(!Number.isInteger(t.rect.x)||t.rect.x<0))throw new TypeError("options.rect.x, when provided, must be a non-negative integer.");if(t.rect.y!==void 0&&(!Number.isInteger(t.rect.y)||t.rect.y<0))throw new TypeError("options.rect.y, when provided, must be a non-negative integer.");if(t.rect.width!==void 0&&(!Number.isInteger(t.rect.width)||t.rect.width<0))throw new TypeError("options.rect.width, when provided, must be a non-negative integer.");if(t.rect.height!==void 0&&(!Number.isInteger(t.rect.height)||t.rect.height<0))throw new TypeError("options.rect.height, when provided, must be a non-negative integer.")}},ua=(t,e,r)=>{const i=da(t),s=[];let n=0;for(const a of i){const o=Math.ceil(e/a.widthDivisor),c=Math.ceil(r/a.heightDivisor),l=o*a.sampleBytes,u=l*c;s.push({offset:n,stride:l}),n+=u}return s},da=t=>{const e=(r,i,s,n,a)=>{const o=[{sampleBytes:r,widthDivisor:1,heightDivisor:1},{sampleBytes:i,widthDivisor:s,heightDivisor:n},{sampleBytes:i,widthDivisor:s,heightDivisor:n}];return a&&o.push({sampleBytes:r,widthDivisor:1,heightDivisor:1}),o};switch(t){case"I420":return e(1,1,2,2,!1);case"I420P10":case"I420P12":return e(2,2,2,2,!1);case"I420A":return e(1,1,2,2,!0);case"I420AP10":case"I420AP12":return e(2,2,2,2,!0);case"I422":return e(1,1,2,1,!1);case"I422P10":case"I422P12":return e(2,2,2,1,!1);case"I422A":return e(1,1,2,1,!0);case"I422AP10":case"I422AP12":return e(2,2,2,1,!0);case"I444":return e(1,1,1,1,!1);case"I444P10":case"I444P12":return e(2,2,1,1,!1);case"I444A":return e(1,1,1,1,!0);case"I444AP10":case"I444AP12":return e(2,2,1,1,!0);case"NV12":return[{sampleBytes:1,widthDivisor:1,heightDivisor:1},{sampleBytes:2,widthDivisor:2,heightDivisor:2}];case"RGBA":case"RGBX":case"BGRA":case"BGRX":return[{sampleBytes:4,widthDivisor:1,heightDivisor:1}];default:Xe(t),m(!1)}},Ir=new Set(["f32","f32-planar","s16","s16-planar","s32","s32-planar","u8","u8-planar"]);class ge{get microsecondTimestamp(){return Math.trunc($e*this.timestamp)}get microsecondDuration(){return Math.trunc($e*this.duration)}constructor(e){if(this._closed=!1,Rt(e)){if(e.format===null)throw new TypeError("AudioData with null format is not supported.");this._data=e,this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=e.numberOfFrames,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp/1e6,this.duration=e.numberOfFrames/e.sampleRate}else{if(!e||typeof e!="object")throw new TypeError("Invalid AudioDataInit: must be an object.");if(!Ir.has(e.format))throw new TypeError("Invalid AudioDataInit: invalid format.");if(!Number.isFinite(e.sampleRate)||e.sampleRate<=0)throw new TypeError("Invalid AudioDataInit: sampleRate must be > 0.");if(!Number.isInteger(e.numberOfChannels)||e.numberOfChannels===0)throw new TypeError("Invalid AudioDataInit: numberOfChannels must be an integer > 0.");if(!Number.isFinite(e?.timestamp))throw new TypeError("init.timestamp must be a number.");const r=e.data.byteLength/(rt(e.format)*e.numberOfChannels);if(!Number.isInteger(r))throw new TypeError("Invalid AudioDataInit: data size is not a multiple of frame size.");this.format=e.format,this.sampleRate=e.sampleRate,this.numberOfFrames=r,this.numberOfChannels=e.numberOfChannels,this.timestamp=e.timestamp,this.duration=r/e.sampleRate;let i;if(e.data instanceof ArrayBuffer)i=new Uint8Array(e.data);else if(ArrayBuffer.isView(e.data))i=new Uint8Array(e.data.buffer,e.data.byteOffset,e.data.byteLength);else throw new TypeError("Invalid AudioDataInit: data is not a BufferSource.");const s=this.numberOfFrames*this.numberOfChannels*rt(this.format);if(i.byteLength<s)throw new TypeError("Invalid AudioDataInit: insufficient data size.");this._data=i}$t?.register(this,{type:"audio",data:this._data},this)}allocationSize(e){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(!Number.isInteger(e.planeIndex)||e.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(e.format!==void 0&&!Ir.has(e.format))throw new TypeError("Invalid format.");if(e.frameOffset!==void 0&&(!Number.isInteger(e.frameOffset)||e.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(e.frameCount!==void 0&&(!Number.isInteger(e.frameCount)||e.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const r=e.format??this.format,i=e.frameOffset??0;if(i>=this.numberOfFrames)throw new RangeError("frameOffset out of range");const s=e.frameCount!==void 0?e.frameCount:this.numberOfFrames-i;if(s>this.numberOfFrames-i)throw new RangeError("frameCount out of range");const n=rt(r),a=yt(r);if(a&&e.planeIndex>=this.numberOfChannels)throw new RangeError("planeIndex out of range");if(!a&&e.planeIndex!==0)throw new RangeError("planeIndex out of range");return(a?s:s*this.numberOfChannels)*n}copyTo(e,r){if(!gr(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(!Number.isInteger(r.planeIndex)||r.planeIndex<0)throw new TypeError("planeIndex must be a non-negative integer.");if(r.format!==void 0&&!Ir.has(r.format))throw new TypeError("Invalid format.");if(r.frameOffset!==void 0&&(!Number.isInteger(r.frameOffset)||r.frameOffset<0))throw new TypeError("frameOffset must be a non-negative integer.");if(r.frameCount!==void 0&&(!Number.isInteger(r.frameCount)||r.frameCount<0))throw new TypeError("frameCount must be a non-negative integer.");if(this._closed)throw new Error("AudioSample is closed.");const{planeIndex:i,format:s,frameCount:n,frameOffset:a}=r,o=this.format,c=s??this.format;if(!c)throw new Error("Destination format not determined");const l=this.numberOfFrames,u=this.numberOfChannels,d=a??0;if(d>=l)throw new RangeError("frameOffset out of range");const h=n!==void 0?n:l-d;if(h>l-d)throw new RangeError("frameCount out of range");const f=rt(c),p=yt(c);if(p&&i>=u)throw new RangeError("planeIndex out of range");if(!p&&i!==0)throw new RangeError("planeIndex out of range");const k=(p?h:h*u)*f;if(e.byteLength<k)throw new RangeError("Destination buffer is too small");const w=X(e),b=As(c);if(Rt(this._data))Nt()&&u>2&&c!==o?ha(this._data,w,o,c,u,i,d,h):this._data.copyTo(e,{planeIndex:i,frameOffset:d,frameCount:h,format:c});else{const y=this._data,T=X(y),x=_s(o),P=rt(o),_=yt(o);for(let C=0;C<h;C++)if(p){const R=C*f;let M;_?M=(i*l+(C+d))*P:M=((C+d)*u+i)*P;const A=x(T,M);b(w,R,A)}else for(let R=0;R<u;R++){const A=(C*u+R)*f;let z;_?z=(R*l+(C+d))*P:z=((C+d)*u+R)*P;const W=x(T,z);b(w,A,W)}}}clone(){if(this._closed)throw new Error("AudioSample is closed.");if(Rt(this._data)){const e=new ge(this._data.clone());return e.setTimestamp(this.timestamp),e}else return new ge({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.timestamp,data:this._data})}close(){this._closed||($t?.unregister(this),Rt(this._data)?this._data.close():this._data=new Uint8Array(0),this._closed=!0)}toAudioData(){if(this._closed)throw new Error("AudioSample is closed.");if(Rt(this._data)){if(this._data.timestamp===this.microsecondTimestamp)return this._data.clone();if(yt(this.format)){const e=this.allocationSize({planeIndex:0,format:this.format}),r=new ArrayBuffer(e*this.numberOfChannels);for(let i=0;i<this.numberOfChannels;i++)this.copyTo(new Uint8Array(r,i*e,e),{planeIndex:i,format:this.format});return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:r})}else{const e=new ArrayBuffer(this.allocationSize({planeIndex:0,format:this.format}));return this.copyTo(e,{planeIndex:0,format:this.format}),new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:e})}}else return new AudioData({format:this.format,sampleRate:this.sampleRate,numberOfFrames:this.numberOfFrames,numberOfChannels:this.numberOfChannels,timestamp:this.microsecondTimestamp,data:this._data.buffer instanceof ArrayBuffer?this._data.buffer:this._data.slice()})}toAudioBuffer(){if(this._closed)throw new Error("AudioSample is closed.");const e=new AudioBuffer({numberOfChannels:this.numberOfChannels,length:this.numberOfFrames,sampleRate:this.sampleRate}),r=new Float32Array(this.allocationSize({planeIndex:0,format:"f32-planar"})/4);for(let i=0;i<this.numberOfChannels;i++)this.copyTo(r,{planeIndex:i,format:"f32-planar"}),e.copyToChannel(r,i);return e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}[Symbol.dispose](){this.close()}static*_fromAudioBuffer(e,r){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const i=48e3*5,s=e.numberOfChannels,n=e.sampleRate,a=e.length,o=Math.floor(i/s);let c=0,l=a;for(;l>0;){const u=Math.min(o,l),d=new Float32Array(s*u);for(let h=0;h<s;h++)e.copyFromChannel(d.subarray(h*u,(h+1)*u),h,c);yield new ge({format:"f32-planar",sampleRate:n,numberOfFrames:u,numberOfChannels:s,timestamp:r+c/n,data:d}),c+=u,l-=u}}static fromAudioBuffer(e,r){if(!(e instanceof AudioBuffer))throw new TypeError("audioBuffer must be an AudioBuffer.");const i=48e3*5,s=e.numberOfChannels,n=e.sampleRate,a=e.length,o=Math.floor(i/s);let c=0,l=a;const u=[];for(;l>0;){const d=Math.min(o,l),h=new Float32Array(s*d);for(let p=0;p<s;p++)e.copyFromChannel(h.subarray(p*d,(p+1)*d),p,c);const f=new ge({format:"f32-planar",sampleRate:n,numberOfFrames:d,numberOfChannels:s,timestamp:r+c/n,data:h});u.push(f),c+=d,l-=d}return u}}const rt=t=>{switch(t){case"u8":case"u8-planar":return 1;case"s16":case"s16-planar":return 2;case"s32":case"s32-planar":return 4;case"f32":case"f32-planar":return 4;default:throw new Error("Unknown AudioSampleFormat")}},yt=t=>{switch(t){case"u8-planar":case"s16-planar":case"s32-planar":case"f32-planar":return!0;default:return!1}},_s=t=>{switch(t){case"u8":case"u8-planar":return(e,r)=>(e.getUint8(r)-128)/128;case"s16":case"s16-planar":return(e,r)=>e.getInt16(r,!0)/32768;case"s32":case"s32-planar":return(e,r)=>e.getInt32(r,!0)/2147483648;case"f32":case"f32-planar":return(e,r)=>e.getFloat32(r,!0)}},As=t=>{switch(t){case"u8":case"u8-planar":return(e,r,i)=>e.setUint8(r,te((i+1)*127.5,0,255));case"s16":case"s16-planar":return(e,r,i)=>e.setInt16(r,te(Math.round(i*32767),-32768,32767),!0);case"s32":case"s32-planar":return(e,r,i)=>e.setInt32(r,te(Math.round(i*2147483647),-2147483648,2147483647),!0);case"f32":case"f32-planar":return(e,r,i)=>e.setFloat32(r,i,!0)}},Rt=t=>typeof AudioData<"u"&&t instanceof AudioData,ha=(t,e,r,i,s,n,a,o)=>{const c=_s(r),l=As(i),u=rt(r),d=rt(i),h=yt(r);if(yt(i))if(h){const p=new ArrayBuffer(o*u),g=X(p);t.copyTo(p,{planeIndex:n,frameOffset:a,frameCount:o,format:r});for(let k=0;k<o;k++){const w=k*u,b=k*d,y=c(g,w);l(e,b,y)}}else{const p=new ArrayBuffer(o*s*u),g=X(p);t.copyTo(p,{planeIndex:0,frameOffset:a,frameCount:o,format:r});for(let k=0;k<o;k++){const w=(k*s+n)*u,b=k*d,y=c(g,w);l(e,b,y)}}else if(h){const p=o*u,g=new ArrayBuffer(p),k=X(g);for(let w=0;w<s;w++){t.copyTo(g,{planeIndex:w,frameOffset:a,frameCount:o,format:r});for(let b=0;b<o;b++){const y=b*u,T=(b*s+w)*d,x=c(k,y);l(e,T,x)}}}else{const p=new ArrayBuffer(o*s*u),g=X(p);t.copyTo(p,{planeIndex:0,frameOffset:a,frameCount:o,format:r});for(let k=0;k<o;k++)for(let w=0;w<s;w++){const b=k*s+w,y=b*u,T=b*d,x=c(g,y);l(e,T,x)}}};const ht=t=>{if(!t||typeof t!="object")throw new TypeError("options must be an object.");if(t.metadataOnly!==void 0&&typeof t.metadataOnly!="boolean")throw new TypeError("options.metadataOnly, when defined, must be a boolean.");if(t.verifyKeyPackets!==void 0&&typeof t.verifyKeyPackets!="boolean")throw new TypeError("options.verifyKeyPackets, when defined, must be a boolean.");if(t.verifyKeyPackets&&t.metadataOnly)throw new TypeError("options.verifyKeyPackets and options.metadataOnly cannot be enabled together.")},Ge=t=>{if(!hs(t))throw new TypeError("timestamp must be a number.")},_r=(t,e,r)=>r.verifyKeyPackets?e.then(async i=>{if(!i||i.type==="delta")return i;const s=await t.determinePacketType(i);return s&&(i.type=s),i}):e;class Qt{constructor(e){if(!(e instanceof bi))throw new TypeError("track must be an InputTrack.");this._track=e}getFirstPacket(e={}){if(ht(e),this._track.input._disposed)throw new de;return _r(this._track,this._track._backing.getFirstPacket(e),e)}getPacket(e,r={}){if(Ge(e),ht(r),this._track.input._disposed)throw new de;return _r(this._track,this._track._backing.getPacket(e,r),r)}getNextPacket(e,r={}){if(!(e instanceof j))throw new TypeError("packet must be an EncodedPacket.");if(ht(r),this._track.input._disposed)throw new de;return _r(this._track,this._track._backing.getNextPacket(e,r),r)}async getKeyPacket(e,r={}){if(Ge(e),ht(r),this._track.input._disposed)throw new de;if(!r.verifyKeyPackets)return this._track._backing.getKeyPacket(e,r);const i=await this._track._backing.getKeyPacket(e,r);return i&&(m(i.type==="key"),await this._track.determinePacketType(i)==="delta"?this.getKeyPacket(i.timestamp-1/this._track.timeResolution,r):i)}async getNextKeyPacket(e,r={}){if(!(e instanceof j))throw new TypeError("packet must be an EncodedPacket.");if(ht(r),this._track.input._disposed)throw new de;if(!r.verifyKeyPackets)return this._track._backing.getNextKeyPacket(e,r);const i=await this._track._backing.getNextKeyPacket(e,r);return i&&(m(i.type==="key"),await this._track.determinePacketType(i)==="delta"?this.getNextKeyPacket(i,r):i)}packets(e,r,i={}){if(e!==void 0&&!(e instanceof j))throw new TypeError("startPacket must be an EncodedPacket.");if(e!==void 0&&e.isMetadataOnly&&!i?.metadataOnly)throw new TypeError("startPacket can only be metadata-only if options.metadataOnly is enabled.");if(r!==void 0&&!(r instanceof j))throw new TypeError("endPacket must be an EncodedPacket.");if(ht(i),this._track.input._disposed)throw new de;const s=[];let{promise:n,resolve:a}=ne(),{promise:o,resolve:c}=ne(),l=!1,u=!1,d=null;const h=[],f=()=>Math.max(2,h.length);(async()=>{let g=e??await this.getFirstPacket(i);for(;g&&!u&&!this._track.input._disposed&&!(r&&g.sequenceNumber>=r?.sequenceNumber);){if(s.length>f()){({promise:o,resolve:c}=ne()),await o;continue}s.push(g),a(),{promise:n,resolve:a}=ne(),g=await this.getNextPacket(g,i)}l=!0,a()})().catch(g=>{d||(d=g,a())});const p=this._track;return{async next(){for(;;){if(p.input._disposed)throw new de;if(u)return{value:void 0,done:!0};if(d)throw d;if(s.length>0){const g=s.shift(),k=performance.now();for(h.push(k);h.length>0&&k-h[0]>=1e3;)h.shift();return c(),{value:g,done:!1}}else{if(l)return{value:void 0,done:!0};await n}}},async return(){return u=!0,c(),a(),{value:void 0,done:!0}},async throw(g){throw g},[Symbol.asyncIterator](){return this}}}}class ki{constructor(e,r){this.onSample=e,this.onError=r}}class Fs{mediaSamplesInRange(e=0,r=1/0){Ge(e),Ge(r);const i=[];let s=!1,n=null,{promise:a,resolve:o}=ne(),{promise:c,resolve:l}=ne(),u=!1,d=!1,h=!1,f=null;(async()=>{const k=await this._createDecoder(P=>{if(l(),P.timestamp>=r&&(d=!0),d){P.close();return}n&&(P.timestamp>e?(i.push(n),s=!0):n.close()),P.timestamp>=e&&(i.push(P),s=!0),n=s?null:P,i.length>0&&(o(),{promise:a,resolve:o}=ne())},P=>{f||(f=P,o())}),w=this._createPacketSink(),b=await w.getKeyPacket(e,{verifyKeyPackets:!0})??await w.getFirstPacket();let y=b;const x=w.packets(b??void 0,void 0);for(await x.next();y&&!d&&!this._track.input._disposed;){const P=Hi(i.length);if(i.length+k.getDecodeQueueSize()>P){({promise:c,resolve:l}=ne()),await c;continue}k.decode(y);const _=await x.next();if(_.done)break;y=_.value}await x.return(),!h&&!this._track.input._disposed&&await k.flush(),k.close(),!s&&n&&i.push(n),u=!0,o()})().catch(k=>{f||(f=k,o())});const p=this._track,g=()=>{n?.close();for(const k of i)k.close()};return{async next(){for(;;){if(p.input._disposed)throw g(),new de;if(h)return{value:void 0,done:!0};if(f)throw g(),f;if(i.length>0){const k=i.shift();return l(),{value:k,done:!1}}else if(!u)await a;else return{value:void 0,done:!0}}},async return(){return h=!0,d=!0,l(),o(),g(),{value:void 0,done:!0}},async throw(k){throw k},[Symbol.asyncIterator](){return this}}}mediaSamplesAtTimestamps(e){wn(e);const r=bn(e),i=[],s=[];let{promise:n,resolve:a}=ne(),{promise:o,resolve:c}=ne(),l=!1,u=!1,d=null;const h=g=>{s.push(g),a(),{promise:n,resolve:a}=ne()};(async()=>{const g=await this._createDecoder(P=>{if(c(),u){P.close();return}let _=0;for(;i.length>0&&P.timestamp-i[0]>-1e-10;)_++,i.shift();if(_>0)for(let C=0;C<_;C++)h(C<_-1?P.clone():P);else P.close()},P=>{d||(d=P,a())}),k=this._createPacketSink();let w=null,b=null,y=-1;const T=async()=>{m(b);let P=b;for(g.decode(P);P.sequenceNumber<y;){const _=Hi(s.length);for(;s.length+g.getDecodeQueueSize()>_&&!u;)({promise:o,resolve:c}=ne()),await o;if(u)break;const C=await k.getNextPacket(P);m(C),g.decode(C),P=C}y=-1},x=async()=>{await g.flush();for(let P=0;P<i.length;P++)h(null);i.length=0};for await(const P of r){if(Ge(P),u||this._track.input._disposed)break;const _=await k.getPacket(P),C=_&&await k.getKeyPacket(P,{verifyKeyPackets:!0});if(!C){y!==-1&&(await T(),await x()),h(null),w=null;continue}w&&(C.sequenceNumber!==b.sequenceNumber||_.timestamp<w.timestamp)&&(await T(),await x()),i.push(_.timestamp),y=Math.max(_.sequenceNumber,y),w=_,b=C}!u&&!this._track.input._disposed&&(y!==-1&&await T(),await x()),g.close(),l=!0,a()})().catch(g=>{d||(d=g,a())});const f=this._track,p=()=>{for(const g of s)g?.close()};return{async next(){for(;;){if(f.input._disposed)throw p(),new de;if(u)return{value:void 0,done:!0};if(d)throw p(),d;if(s.length>0){const g=s.shift();return m(g!==void 0),c(),{value:g,done:!1}}else if(!l)await n;else return{value:void 0,done:!0}}},async return(){return u=!0,c(),a(),p(),{value:void 0,done:!0}},async throw(g){throw g},[Symbol.asyncIterator](){return this}}}}const Hi=t=>t===0?40:8;class fa extends ki{constructor(e,r,i,s,n,a){super(e,r),this.codec=i,this.decoderConfig=s,this.rotation=n,this.timeResolution=a,this.decoder=null,this.customDecoder=null,this.customDecoderCallSerializer=new br,this.customDecoderQueueSize=0,this.inputTimestamps=[],this.sampleQueue=[],this.currentPacketIndex=0,this.raslSkipped=!1,this.alphaDecoder=null,this.alphaHadKeyframe=!1,this.colorQueue=[],this.alphaQueue=[],this.merger=null,this.mergerCreationFailed=!1,this.decodedAlphaChunkCount=0,this.alphaDecoderQueueSize=0,this.nullAlphaFrameQueue=[],this.currentAlphaPacketIndex=0,this.alphaRaslSkipped=!1;const o=vs.find(c=>c.supports(i,s));if(o)this.customDecoder=new o,this.customDecoder.codec=i,this.customDecoder.config=s,this.customDecoder.onSample=c=>{if(!(c instanceof oe))throw new TypeError("The argument passed to onSample must be a VideoSample.");this.finalizeAndEmitSample(c)},this.customDecoderCallSerializer.call(()=>this.customDecoder.init());else{const c=u=>{if(this.alphaQueue.length>0){const d=this.alphaQueue.shift();m(d!==void 0),this.mergeAlpha(u,d)}else this.colorQueue.push(u)};if(i==="avc"&&this.decoderConfig.description&&Hr()){const u=Qn(fe(this.decoderConfig.description));if(u&&u.sequenceParameterSets.length>0){const d=hi(u.sequenceParameterSets[0]);d&&d.frameMbsOnlyFlag===0&&(this.decoderConfig={...this.decoderConfig,hardwareAcceleration:"prefer-software"})}}const l=new Error("Decoding error").stack;this.decoder=new VideoDecoder({output:u=>{try{c(u)}catch(d){this.onError(d)}},error:u=>{u.stack=l,this.onError(u)}}),this.decoder.configure(this.decoderConfig)}}getDecodeQueueSize(){return this.customDecoder?this.customDecoderQueueSize:(m(this.decoder),Math.max(this.decoder.decodeQueueSize,this.alphaDecoder?.decodeQueueSize??0))}decode(e){if(this.codec==="hevc"&&this.currentPacketIndex>0&&!this.raslSkipped){if(this.hasHevcRaslPicture(e.data))return;this.raslSkipped=!0}if(this.customDecoder)this.customDecoderQueueSize++,this.customDecoderCallSerializer.call(()=>this.customDecoder.decode(e)).then(()=>this.customDecoderQueueSize--);else{if(m(this.decoder),Nt()||Fi(this.inputTimestamps,e.timestamp,r=>r),Hr()&&this.currentPacketIndex===0&&this.codec==="avc"){const r=[];for(const s of bs(e.data,this.decoderConfig)){const n=yr(e.data[s.offset]);n>=20&&n<=31||r.push(e.data.subarray(s.offset,s.offset+s.length))}const i=jn(r,this.decoderConfig);e=new j(i,e.type,e.timestamp,e.duration)}this.decoder.decode(e.toEncodedVideoChunk()),this.decodeAlphaData(e)}this.currentPacketIndex++}decodeAlphaData(e){if(!e.sideData.alpha||this.mergerCreationFailed){this.pushNullAlphaFrame();return}if(!this.merger)try{this.merger=new ma}catch(i){console.error("Due to an error, only color data will be decoded.",i),this.mergerCreationFailed=!0,this.decodeAlphaData(e);return}if(!this.alphaDecoder){const i=n=>{if(this.alphaDecoderQueueSize--,this.colorQueue.length>0){const a=this.colorQueue.shift();m(a!==void 0),this.mergeAlpha(a,n)}else this.alphaQueue.push(n);for(this.decodedAlphaChunkCount++;this.nullAlphaFrameQueue.length>0&&this.nullAlphaFrameQueue[0]===this.decodedAlphaChunkCount;)if(this.nullAlphaFrameQueue.shift(),this.colorQueue.length>0){const a=this.colorQueue.shift();m(a!==void 0),this.mergeAlpha(a,null)}else this.alphaQueue.push(null)},s=new Error("Decoding error").stack;this.alphaDecoder=new VideoDecoder({output:n=>{try{i(n)}catch(a){this.onError(a)}},error:n=>{n.stack=s,this.onError(n)}}),this.alphaDecoder.configure(this.decoderConfig)}const r=mi(this.codec,this.decoderConfig,e.sideData.alpha);if(this.alphaHadKeyframe||(this.alphaHadKeyframe=r==="key"),this.alphaHadKeyframe){if(this.codec==="hevc"&&this.currentAlphaPacketIndex>0&&!this.alphaRaslSkipped){if(this.hasHevcRaslPicture(e.sideData.alpha)){this.pushNullAlphaFrame();return}this.alphaRaslSkipped=!0}this.currentAlphaPacketIndex++,this.alphaDecoder.decode(e.alphaToEncodedVideoChunk(r??e.type)),this.alphaDecoderQueueSize++}else this.pushNullAlphaFrame()}pushNullAlphaFrame(){this.alphaDecoderQueueSize===0?this.alphaQueue.push(null):this.nullAlphaFrameQueue.push(this.decodedAlphaChunkCount+this.alphaDecoderQueueSize)}hasHevcRaslPicture(e){for(const r of ys(e,this.decoderConfig)){const i=jt(e[r.offset]);if(i===ae.RASL_N||i===ae.RASL_R)return!0}return!1}sampleHandler(e){if(Nt()){if(this.sampleQueue.length>0&&e.timestamp>=G(this.sampleQueue).timestamp){for(const r of this.sampleQueue)this.finalizeAndEmitSample(r);this.sampleQueue.length=0}Fi(this.sampleQueue,e,r=>r.timestamp)}else{const r=this.inputTimestamps.shift();m(r!==void 0),e.setTimestamp(r),this.finalizeAndEmitSample(e)}}finalizeAndEmitSample(e){e.setTimestamp(Math.round(e.timestamp*this.timeResolution)/this.timeResolution),e.setDuration(Math.round(e.duration*this.timeResolution)/this.timeResolution),e.setRotation(this.rotation),this.onSample(e)}mergeAlpha(e,r){if(!r){const n=new oe(e);this.sampleHandler(n);return}m(this.merger),this.merger.update(e,r),e.close(),r.close();const i=new VideoFrame(this.merger.canvas,{timestamp:e.timestamp,duration:e.duration??void 0}),s=new oe(i);this.sampleHandler(s)}async flush(){if(this.customDecoder?await this.customDecoderCallSerializer.call(()=>this.customDecoder.flush()):(m(this.decoder),await Promise.all([this.decoder.flush(),this.alphaDecoder?.flush()]),this.colorQueue.forEach(e=>e.close()),this.colorQueue.length=0,this.alphaQueue.forEach(e=>e?.close()),this.alphaQueue.length=0,this.alphaHadKeyframe=!1,this.decodedAlphaChunkCount=0,this.alphaDecoderQueueSize=0,this.nullAlphaFrameQueue.length=0,this.currentAlphaPacketIndex=0,this.alphaRaslSkipped=!1),Nt()){for(const e of this.sampleQueue)this.finalizeAndEmitSample(e);this.sampleQueue.length=0}this.currentPacketIndex=0,this.raslSkipped=!1}close(){this.customDecoder?this.customDecoderCallSerializer.call(()=>this.customDecoder.close()):(m(this.decoder),this.decoder.close(),this.alphaDecoder?.close(),this.colorQueue.forEach(e=>e.close()),this.colorQueue.length=0,this.alphaQueue.forEach(e=>e?.close()),this.alphaQueue.length=0,this.merger?.close());for(const e of this.sampleQueue)e.close();this.sampleQueue.length=0}}class ma{constructor(){typeof OffscreenCanvas<"u"?this.canvas=new OffscreenCanvas(300,150):this.canvas=document.createElement("canvas");const e=this.canvas.getContext("webgl2",{premultipliedAlpha:!1});if(!e)throw new Error("Couldn't acquire WebGL 2 context.");this.gl=e,this.program=this.createProgram(),this.vao=this.createVAO(),this.colorTexture=this.createTexture(),this.alphaTexture=this.createTexture(),this.gl.useProgram(this.program),this.gl.uniform1i(this.gl.getUniformLocation(this.program,"u_colorTexture"),0),this.gl.uniform1i(this.gl.getUniformLocation(this.program,"u_alphaTexture"),1)}createProgram(){const e=this.createShader(this.gl.VERTEX_SHADER,`#version 300 es
			in vec2 a_position;
			in vec2 a_texCoord;
			out vec2 v_texCoord;
			
			void main() {
				gl_Position = vec4(a_position, 0.0, 1.0);
				v_texCoord = a_texCoord;
			}
		`),r=this.createShader(this.gl.FRAGMENT_SHADER,`#version 300 es
			precision highp float;
			
			uniform sampler2D u_colorTexture;
			uniform sampler2D u_alphaTexture;
			in vec2 v_texCoord;
			out vec4 fragColor;
			
			void main() {
				vec3 color = texture(u_colorTexture, v_texCoord).rgb;
				float alpha = texture(u_alphaTexture, v_texCoord).r;
				fragColor = vec4(color, alpha);
			}
		`),i=this.gl.createProgram();return this.gl.attachShader(i,e),this.gl.attachShader(i,r),this.gl.linkProgram(i),i}createShader(e,r){const i=this.gl.createShader(e);return this.gl.shaderSource(i,r),this.gl.compileShader(i),i}createVAO(){const e=this.gl.createVertexArray();this.gl.bindVertexArray(e);const r=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,1,1,1,0]),i=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,i),this.gl.bufferData(this.gl.ARRAY_BUFFER,r,this.gl.STATIC_DRAW);const s=this.gl.getAttribLocation(this.program,"a_position"),n=this.gl.getAttribLocation(this.program,"a_texCoord");return this.gl.enableVertexAttribArray(s),this.gl.vertexAttribPointer(s,2,this.gl.FLOAT,!1,16,0),this.gl.enableVertexAttribArray(n),this.gl.vertexAttribPointer(n,2,this.gl.FLOAT,!1,16,8),e}createTexture(){const e=this.gl.createTexture();return this.gl.bindTexture(this.gl.TEXTURE_2D,e),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),e}update(e,r){(e.displayWidth!==this.canvas.width||e.displayHeight!==this.canvas.height)&&(this.canvas.width=e.displayWidth,this.canvas.height=e.displayHeight),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,this.colorTexture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,e),this.gl.activeTexture(this.gl.TEXTURE1),this.gl.bindTexture(this.gl.TEXTURE_2D,this.alphaTexture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,r),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(this.vao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4)}close(){this.gl.getExtension("WEBGL_lose_context")?.loseContext(),this.gl=null}}class Kr extends Fs{constructor(e){if(!(e instanceof Bt))throw new TypeError("videoTrack must be an InputVideoTrack.");super(),this._track=e}async _createDecoder(e,r){if(!await this._track.canDecode())throw new Error("This video track cannot be decoded by this browser. Make sure to check decodability before using a track.");const i=this._track.codec,s=this._track.rotation,n=await this._track.getDecoderConfig(),a=this._track.timeResolution;return m(i&&n),new fa(e,r,i,n,s,a)}_createPacketSink(){return new Qt(this._track)}async getSample(e){Ge(e);for await(const r of this.mediaSamplesAtTimestamps([e]))return r;throw new Error("Internal error: Iterator returned nothing.")}samples(e=0,r=1/0){return this.mediaSamplesInRange(e,r)}samplesAtTimestamps(e){return this.mediaSamplesAtTimestamps(e)}}class pa{constructor(e,r={}){if(this._nextCanvasIndex=0,!(e instanceof Bt))throw new TypeError("videoTrack must be an InputVideoTrack.");if(r&&typeof r!="object")throw new TypeError("options must be an object.");if(r.alpha!==void 0&&typeof r.alpha!="boolean")throw new TypeError("options.alpha, when provided, must be a boolean.");if(r.width!==void 0&&(!Number.isInteger(r.width)||r.width<=0))throw new TypeError("options.width, when defined, must be a positive integer.");if(r.height!==void 0&&(!Number.isInteger(r.height)||r.height<=0))throw new TypeError("options.height, when defined, must be a positive integer.");if(r.fit!==void 0&&!["fill","contain","cover"].includes(r.fit))throw new TypeError('options.fit, when provided, must be one of "fill", "contain", or "cover".');if(r.width!==void 0&&r.height!==void 0&&r.fit===void 0)throw new TypeError("When both options.width and options.height are provided, options.fit must also be provided.");if(r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError("options.rotation, when provided, must be 0, 90, 180 or 270.");if(r.crop!==void 0&&gi(r.crop,"options."),r.poolSize!==void 0&&(typeof r.poolSize!="number"||!Number.isInteger(r.poolSize)||r.poolSize<0))throw new TypeError("poolSize must be a non-negative integer.");const i=r.rotation??e.rotation,[s,n]=i%180===0?[e.codedWidth,e.codedHeight]:[e.codedHeight,e.codedWidth],a=r.crop;a&&pi(a,s,n);let[o,c]=a?[a.width,a.height]:[s,n];const l=o/c;r.width!==void 0&&r.height===void 0?(o=r.width,c=Math.round(o/l)):r.width===void 0&&r.height!==void 0?(c=r.height,o=Math.round(c*l)):r.width!==void 0&&r.height!==void 0&&(o=r.width,c=r.height),this._videoTrack=e,this._alpha=r.alpha??!1,this._width=o,this._height=c,this._rotation=i,this._crop=a,this._fit=r.fit??"fill",this._videoSampleSink=new Kr(e),this._canvasPool=Array.from({length:r.poolSize??0},()=>null)}_videoSampleToWrappedCanvas(e){let r=this._canvasPool[this._nextCanvasIndex],i=!1;r||(typeof document<"u"?(r=document.createElement("canvas"),r.width=this._width,r.height=this._height):r=new OffscreenCanvas(this._width,this._height),this._canvasPool.length>0&&(this._canvasPool[this._nextCanvasIndex]=r),i=!0),this._canvasPool.length>0&&(this._nextCanvasIndex=(this._nextCanvasIndex+1)%this._canvasPool.length);const s=r.getContext("2d",{alpha:this._alpha||Ft()});m(s),s.resetTransform(),i||(!this._alpha&&Ft()?(s.fillStyle="black",s.fillRect(0,0,this._width,this._height)):s.clearRect(0,0,this._width,this._height)),e.drawWithFit(s,{fit:this._fit,rotation:this._rotation,crop:this._crop});const n={canvas:r,timestamp:e.timestamp,duration:e.duration};return e.close(),n}async getCanvas(e){Ge(e);const r=await this._videoSampleSink.getSample(e);return r&&this._videoSampleToWrappedCanvas(r)}canvases(e=0,r=1/0){return Bi(this._videoSampleSink.samples(e,r),i=>this._videoSampleToWrappedCanvas(i))}canvasesAtTimestamps(e){return Bi(this._videoSampleSink.samplesAtTimestamps(e),r=>r&&this._videoSampleToWrappedCanvas(r))}}class ga extends ki{constructor(e,r,i,s){super(e,r),this.decoder=null,this.customDecoder=null,this.customDecoderCallSerializer=new br,this.customDecoderQueueSize=0,this.currentTimestamp=null;const n=o=>{(this.currentTimestamp===null||Math.abs(o.timestamp-this.currentTimestamp)>=o.duration)&&(this.currentTimestamp=o.timestamp);const c=this.currentTimestamp;if(this.currentTimestamp+=o.duration,o.numberOfFrames===0){o.close();return}const l=s.sampleRate;o.setTimestamp(Math.round(c*l)/l),e(o)},a=Es.find(o=>o.supports(i,s));if(a)this.customDecoder=new a,this.customDecoder.codec=i,this.customDecoder.config=s,this.customDecoder.onSample=o=>{if(!(o instanceof ge))throw new TypeError("The argument passed to onSample must be an AudioSample.");n(o)},this.customDecoderCallSerializer.call(()=>this.customDecoder.init());else{const o=new Error("Decoding error").stack;this.decoder=new AudioDecoder({output:c=>{try{n(new ge(c))}catch(l){this.onError(l)}},error:c=>{c.stack=o,this.onError(c)}}),this.decoder.configure(s)}}getDecodeQueueSize(){return this.customDecoder?this.customDecoderQueueSize:(m(this.decoder),this.decoder.decodeQueueSize)}decode(e){this.customDecoder?(this.customDecoderQueueSize++,this.customDecoderCallSerializer.call(()=>this.customDecoder.decode(e)).then(()=>this.customDecoderQueueSize--)):(m(this.decoder),this.decoder.decode(e.toEncodedAudioChunk()))}flush(){return this.customDecoder?this.customDecoderCallSerializer.call(()=>this.customDecoder.flush()):(m(this.decoder),this.decoder.flush())}close(){this.customDecoder?this.customDecoderCallSerializer.call(()=>this.customDecoder.close()):(m(this.decoder),this.decoder.close())}}class ka extends ki{constructor(e,r,i){super(e,r),this.decoderConfig=i,this.currentTimestamp=null,m(ce.includes(i.codec)),this.codec=i.codec;const{dataType:s,sampleSize:n,littleEndian:a}=Ze(this.codec);switch(this.inputSampleSize=n,n){case 1:s==="unsigned"?this.readInputValue=(o,c)=>o.getUint8(c)-2**7:s==="signed"?this.readInputValue=(o,c)=>o.getInt8(c):s==="ulaw"?this.readInputValue=(o,c)=>aa(o.getUint8(c)):s==="alaw"?this.readInputValue=(o,c)=>ca(o.getUint8(c)):m(!1);break;case 2:s==="unsigned"?this.readInputValue=(o,c)=>o.getUint16(c,a)-2**15:s==="signed"?this.readInputValue=(o,c)=>o.getInt16(c,a):m(!1);break;case 3:s==="unsigned"?this.readInputValue=(o,c)=>kr(o,c,a)-2**23:s==="signed"?this.readInputValue=(o,c)=>yn(o,c,a):m(!1);break;case 4:s==="unsigned"?this.readInputValue=(o,c)=>o.getUint32(c,a)-2**31:s==="signed"?this.readInputValue=(o,c)=>o.getInt32(c,a):s==="float"?this.readInputValue=(o,c)=>o.getFloat32(c,a):m(!1);break;case 8:s==="float"?this.readInputValue=(o,c)=>o.getFloat64(c,a):m(!1);break;default:Xe(n),m(!1)}switch(n){case 1:s==="ulaw"||s==="alaw"?(this.outputSampleSize=2,this.outputFormat="s16",this.writeOutputValue=(o,c,l)=>o.setInt16(c,l,!0)):(this.outputSampleSize=1,this.outputFormat="u8",this.writeOutputValue=(o,c,l)=>o.setUint8(c,l+2**7));break;case 2:this.outputSampleSize=2,this.outputFormat="s16",this.writeOutputValue=(o,c,l)=>o.setInt16(c,l,!0);break;case 3:this.outputSampleSize=4,this.outputFormat="s32",this.writeOutputValue=(o,c,l)=>o.setInt32(c,l<<8,!0);break;case 4:this.outputSampleSize=4,s==="float"?(this.outputFormat="f32",this.writeOutputValue=(o,c,l)=>o.setFloat32(c,l,!0)):(this.outputFormat="s32",this.writeOutputValue=(o,c,l)=>o.setInt32(c,l,!0));break;case 8:this.outputSampleSize=4,this.outputFormat="f32",this.writeOutputValue=(o,c,l)=>o.setFloat32(c,l,!0);break;default:Xe(n),m(!1)}}getDecodeQueueSize(){return 0}decode(e){const r=X(e.data),i=e.byteLength/this.decoderConfig.numberOfChannels/this.inputSampleSize,s=i*this.decoderConfig.numberOfChannels*this.outputSampleSize,n=new ArrayBuffer(s),a=new DataView(n);for(let u=0;u<i*this.decoderConfig.numberOfChannels;u++){const d=u*this.inputSampleSize,h=u*this.outputSampleSize,f=this.readInputValue(r,d);this.writeOutputValue(a,h,f)}const o=i/this.decoderConfig.sampleRate;(this.currentTimestamp===null||Math.abs(e.timestamp-this.currentTimestamp)>=o)&&(this.currentTimestamp=e.timestamp);const c=this.currentTimestamp;this.currentTimestamp+=o;const l=new ge({format:this.outputFormat,data:n,numberOfChannels:this.decoderConfig.numberOfChannels,sampleRate:this.decoderConfig.sampleRate,numberOfFrames:i,timestamp:c});this.onSample(l)}async flush(){}close(){}}class qi extends Fs{constructor(e){if(!(e instanceof Fe))throw new TypeError("audioTrack must be an InputAudioTrack.");super(),this._track=e}async _createDecoder(e,r){if(!await this._track.canDecode())throw new Error("This audio track cannot be decoded by this browser. Make sure to check decodability before using a track.");const i=this._track.codec,s=await this._track.getDecoderConfig();return m(i&&s),ce.includes(s.codec)?new ka(e,r,s):new ga(e,r,i,s)}_createPacketSink(){return new Qt(this._track)}async getSample(e){Ge(e);for await(const r of this.mediaSamplesAtTimestamps([e]))return r;throw new Error("Internal error: Iterator returned nothing.")}samples(e=0,r=1/0){return this.mediaSamplesInRange(e,r)}samplesAtTimestamps(e){return this.mediaSamplesAtTimestamps(e)}}class bi{constructor(e,r){this.input=e,this._backing=r}isVideoTrack(){return this instanceof Bt}isAudioTrack(){return this instanceof Fe}get id(){return this._backing.getId()}get internalCodecId(){return this._backing.getInternalCodecId()}get languageCode(){return this._backing.getLanguageCode()}get name(){return this._backing.getName()}get timeResolution(){return this._backing.getTimeResolution()}get disposition(){return this._backing.getDisposition()}getFirstTimestamp(){return this._backing.getFirstTimestamp()}computeDuration(){return this._backing.computeDuration()}async computePacketStats(e=1/0){const r=new Qt(this);let i=1/0,s=-1/0,n=0,a=0;for await(const o of r.packets(void 0,void 0,{metadataOnly:!0})){if(n>=e&&o.timestamp>=s)break;i=Math.min(i,o.timestamp),s=Math.max(s,o.timestamp+o.duration),n++,a+=o.byteLength}return{packetCount:n,averagePacketRate:n?Number((n/(s-i)).toPrecision(16)):0,averageBitrate:n?Number((8*a/(s-i)).toPrecision(16)):0}}}class Bt extends bi{constructor(e,r){super(e,r),this._backing=r}get type(){return"video"}get codec(){return this._backing.getCodec()}get codedWidth(){return this._backing.getCodedWidth()}get codedHeight(){return this._backing.getCodedHeight()}get rotation(){return this._backing.getRotation()}get displayWidth(){return this._backing.getRotation()%180===0?this._backing.getCodedWidth():this._backing.getCodedHeight()}get displayHeight(){return this._backing.getRotation()%180===0?this._backing.getCodedHeight():this._backing.getCodedWidth()}getColorSpace(){return this._backing.getColorSpace()}async hasHighDynamicRange(){const e=await this._backing.getColorSpace();return e.primaries==="bt2020"||e.primaries==="smpte432"||e.transfer==="pg"||e.transfer==="hlg"||e.matrix==="bt2020-ncl"}canBeTransparent(){return this._backing.canBeTransparent()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecParameterString(){return(await this._backing.getDecoderConfig())?.codec??null}async canDecode(){try{const e=await this._backing.getDecoderConfig();if(!e)return!1;const r=this._backing.getCodec();return m(r!==null),vs.some(s=>s.supports(r,e))?!0:typeof VideoDecoder>"u"?!1:(await VideoDecoder.isConfigSupported(e)).supported===!0}catch(e){return console.error("Error during decodability check:",e),!1}}async determinePacketType(e){if(!(e instanceof j))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("packet must not be metadata-only to determine its type.");if(this.codec===null)return null;const r=await this.getDecoderConfig();return m(r),mi(this.codec,r,e.data)}}class Fe extends bi{constructor(e,r){super(e,r),this._backing=r}get type(){return"audio"}get codec(){return this._backing.getCodec()}get numberOfChannels(){return this._backing.getNumberOfChannels()}get sampleRate(){return this._backing.getSampleRate()}getDecoderConfig(){return this._backing.getDecoderConfig()}async getCodecParameterString(){return(await this._backing.getDecoderConfig())?.codec??null}async canDecode(){try{const e=await this._backing.getDecoderConfig();if(!e)return!1;const r=this._backing.getCodec();return m(r!==null),Es.some(i=>i.supports(r,e))||e.codec.startsWith("pcm-")?!0:typeof AudioDecoder>"u"?!1:(await AudioDecoder.isConfigSupported(e)).supported===!0}catch(e){return console.error("Error during decodability check:",e),!1}}async determinePacketType(e){if(!(e instanceof j))throw new TypeError("packet must be an EncodedPacket.");return this.codec===null?null:"key"}}const Bs=t=>{let r=(t.hasVideo?"video/":t.hasAudio?"audio/":"application/")+(t.isQuickTime?"quicktime":"mp4");if(t.codecStrings.length>0){const i=[...new Set(t.codecStrings)];r+=`; codecs="${i.join(", ")}"`}return r};const Oe=8,it=16,qe=t=>{let e=I(t);const r=re(t,4);let i=8;e===1&&(e=we(t),i=16);const n=e-i;return n<0?null:{name:r,totalSize:e,headerSize:i,contentSize:n}},tt=t=>nt(t)/65536,Ar=t=>nt(t)/1073741824,Fr=t=>{let e=0;for(let r=0;r<4;r++){e<<=7;const i=F(t);if(e|=i&127,(i&128)===0)break}return e},Se=t=>{let e=ee(t);return t.skip(2),e=Math.min(e,t.remainingLength),ke.decode(O(t,e))},ba=t=>{const e=qe(t);if(!e||e.name!=="data"||t.remainingLength<8)return null;const r=I(t);t.skip(4);const i=O(t,e.contentSize-8);switch(r){case 1:return ke.decode(i);case 2:return new TextDecoder("utf-16be").decode(i);case 13:return new Et(i,"image/jpeg");case 14:return new Et(i,"image/png");case 27:return new Et(i,"image/bmp");default:return i}};class wa extends Je{constructor(e){super(e),this.moovSlice=null,this.currentTrack=null,this.tracks=[],this.metadataPromise=null,this.movieTimescale=-1,this.movieDurationInTimescale=-1,this.isQuickTime=!1,this.metadataTags={},this.currentMetadataKeys=null,this.isFragmented=!1,this.fragmentTrackDefaults=[],this.currentFragment=null,this.lastReadFragment=null,this.reader=e._reader}async computeDuration(){const e=await this.getTracks(),r=await Promise.all(e.map(i=>i.computeDuration()));return Math.max(0,...r)}async getTracks(){return await this.readMetadata(),this.tracks.map(e=>e.inputTrack)}async getMimeType(){await this.readMetadata();const e=await Promise.all(this.tracks.map(r=>r.inputTrack.getCodecParameterString()));return Bs({isQuickTime:this.isQuickTime,hasVideo:this.tracks.some(r=>r.info?.type==="video"),hasAudio:this.tracks.some(r=>r.info?.type==="audio"),codecStrings:e.filter(Boolean)})}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}readMetadata(){return this.metadataPromise??=(async()=>{let e=0;for(;;){let r=this.reader.requestSliceRange(e,Oe,it);if(r instanceof Promise&&(r=await r),!r)break;const i=e,s=qe(r);if(!s)break;if(s.name==="ftyp"){const n=re(r,4);this.isQuickTime=n==="qt  "}else if(s.name==="moov"){let n=this.reader.requestSlice(r.filePos,s.contentSize);if(n instanceof Promise&&(n=await n),!n)break;this.moovSlice=n,this.readContiguousBoxes(this.moovSlice),this.tracks.sort((a,o)=>Number(o.disposition.default)-Number(a.disposition.default));for(const a of this.tracks){const o=a.editListPreviousSegmentDurations/this.movieTimescale;a.editListOffset-=Math.round(o*a.timescale)}break}e=i+s.totalSize}if(this.isFragmented&&this.reader.fileSize!==null){let r=this.reader.requestSlice(this.reader.fileSize-4,4);r instanceof Promise&&(r=await r),m(r);const i=I(r),s=this.reader.fileSize-i;if(s>=0&&s<=this.reader.fileSize-it){let n=this.reader.requestSliceRange(s,Oe,it);if(n instanceof Promise&&(n=await n),n){const a=qe(n);if(a&&a.name==="mfra"){let o=this.reader.requestSlice(n.filePos,a.contentSize);o instanceof Promise&&(o=await o),o&&this.readContiguousBoxes(o)}}}}})()}getSampleTableForTrack(e){if(e.sampleTable)return e.sampleTable;const r={sampleTimingEntries:[],sampleCompositionTimeOffsets:[],sampleSizes:[],keySampleIndices:null,chunkOffsets:[],sampleToChunk:[],presentationTimestamps:null,presentationTimestampIndexMap:null};e.sampleTable=r,m(this.moovSlice);const i=this.moovSlice.slice(e.sampleTableByteOffset);if(this.currentTrack=e,this.traverseBox(i),this.currentTrack=null,e.info?.type==="audio"&&e.info.codec&&ce.includes(e.info.codec)&&r.sampleCompositionTimeOffsets.length===0){m(e.info?.type==="audio");const n=Ze(e.info.codec),a=[],o=[];for(let c=0;c<r.sampleToChunk.length;c++){const l=r.sampleToChunk[c],u=r.sampleToChunk[c+1],d=(u?u.startChunkIndex:r.chunkOffsets.length)-l.startChunkIndex;for(let h=0;h<d;h++){const f=l.startSampleIndex+h*l.samplesPerChunk,p=f+l.samplesPerChunk,g=L(r.sampleTimingEntries,f,C=>C.startIndex),k=r.sampleTimingEntries[g],w=L(r.sampleTimingEntries,p,C=>C.startIndex),b=r.sampleTimingEntries[w],y=k.startDecodeTimestamp+(f-k.startIndex)*k.delta,x=b.startDecodeTimestamp+(p-b.startIndex)*b.delta-y,P=G(a);P&&P.delta===x?P.count++:a.push({startIndex:l.startChunkIndex+h,startDecodeTimestamp:y,count:1,delta:x});const _=l.samplesPerChunk*n.sampleSize*e.info.numberOfChannels;o.push(_)}l.startSampleIndex=l.startChunkIndex,l.samplesPerChunk=1}r.sampleTimingEntries=a,r.sampleSizes=o}if(r.sampleCompositionTimeOffsets.length>0){r.presentationTimestamps=[];for(const n of r.sampleTimingEntries)for(let a=0;a<n.count;a++)r.presentationTimestamps.push({presentationTimestamp:n.startDecodeTimestamp+a*n.delta,sampleIndex:n.startIndex+a});for(const n of r.sampleCompositionTimeOffsets)for(let a=0;a<n.count;a++){const o=n.startIndex+a,c=r.presentationTimestamps[o];c&&(c.presentationTimestamp+=n.offset)}r.presentationTimestamps.sort((n,a)=>n.presentationTimestamp-a.presentationTimestamp),r.presentationTimestampIndexMap=Array(r.presentationTimestamps.length).fill(-1);for(let n=0;n<r.presentationTimestamps.length;n++)r.presentationTimestampIndexMap[r.presentationTimestamps[n].sampleIndex]=n}return r}async readFragment(e){if(this.lastReadFragment?.moofOffset===e)return this.lastReadFragment;let r=this.reader.requestSliceRange(e,Oe,it);r instanceof Promise&&(r=await r),m(r);const i=qe(r);m(i?.name==="moof");let s=this.reader.requestSlice(e,i.totalSize);s instanceof Promise&&(s=await s),m(s),this.traverseBox(s);const n=this.lastReadFragment;m(n&&n.moofOffset===e);for(const[,a]of n.trackData){const o=a.track,{fragmentPositionCache:c}=o;if(!a.startTimestampIsFinal){const u=o.fragmentLookupTable.find(d=>d.moofOffset===n.moofOffset);if(u)Br(a,u.timestamp);else{const d=L(c,n.moofOffset-1,h=>h.moofOffset);if(d!==-1){const h=c[d];Br(a,h.endTimestamp)}}a.startTimestampIsFinal=!0}const l=L(c,a.startTimestamp,u=>u.startTimestamp);(l===-1||c[l].moofOffset!==n.moofOffset)&&c.splice(l+1,0,{moofOffset:n.moofOffset,startTimestamp:a.startTimestamp,endTimestamp:a.endTimestamp})}return n}readContiguousBoxes(e){const r=e.filePos;for(;e.filePos-r<=e.length-Oe&&this.traverseBox(e););}*iterateContiguousBoxes(e){const r=e.filePos;for(;e.filePos-r<=e.length-Oe;){const i=e.filePos,s=qe(e);if(!s)break;yield{boxInfo:s,slice:e},e.filePos=i+s.totalSize}}traverseBox(e){const r=e.filePos,i=qe(e);if(!i)return!1;const s=e.filePos,n=r+i.totalSize;switch(i.name){case"mdia":case"minf":case"dinf":case"mfra":case"edts":this.readContiguousBoxes(e.slice(s,i.contentSize));break;case"mvhd":{const a=F(e);e.skip(3),a===1?(e.skip(16),this.movieTimescale=I(e),this.movieDurationInTimescale=we(e)):(e.skip(8),this.movieTimescale=I(e),this.movieDurationInTimescale=I(e))}break;case"trak":{const a={id:-1,demuxer:this,inputTrack:null,disposition:{...Ye},info:null,timescale:-1,durationInMovieTimescale:-1,durationInMediaTimescale:-1,rotation:0,internalCodecId:null,name:null,languageCode:he,sampleTableByteOffset:-1,sampleTable:null,fragmentLookupTable:[],currentFragmentState:null,fragmentPositionCache:[],editListPreviousSegmentDurations:0,editListOffset:0};if(this.currentTrack=a,this.readContiguousBoxes(e.slice(s,i.contentSize)),a.id!==-1&&a.timescale!==-1&&a.info!==null){if(a.info.type==="video"&&a.info.width!==-1){const o=a;a.inputTrack=new Bt(this.input,new ya(o)),this.tracks.push(a)}else if(a.info.type==="audio"&&a.info.numberOfChannels!==-1){const o=a;a.inputTrack=new Fe(this.input,new Ta(o)),this.tracks.push(a)}}this.currentTrack=null}break;case"tkhd":{const a=this.currentTrack;if(!a)break;const o=F(e),l=!!(wt(e)&1);if(a.disposition.default=l,o===0)e.skip(8),a.id=I(e),e.skip(4),a.durationInMovieTimescale=I(e);else if(o===1)e.skip(16),a.id=I(e),e.skip(4),a.durationInMovieTimescale=we(e);else throw new Error(`Incorrect track header version ${o}.`);e.skip(16);const u=[tt(e),tt(e),Ar(e),tt(e),tt(e),Ar(e),tt(e),tt(e),Ar(e)],d=si(ls(Ca(u),90));m(d===0||d===90||d===180||d===270),a.rotation=d}break;case"elst":{const a=this.currentTrack;if(!a)break;const o=F(e);e.skip(3);let c=!1,l=0;const u=I(e);for(let d=0;d<u;d++){const h=o===1?we(e):I(e),f=o===1?Oo(e):nt(e),p=tt(e);if(h!==0){if(c){console.warn("Unsupported edit list: multiple edits are not currently supported. Only using first edit.");break}if(f===-1){l+=h;continue}if(p!==1){console.warn("Unsupported edit list entry: media rate must be 1.");break}a.editListPreviousSegmentDurations=l,a.editListOffset=f,c=!0}}}break;case"mdhd":{const a=this.currentTrack;if(!a)break;const o=F(e);e.skip(3),o===0?(e.skip(8),a.timescale=I(e),a.durationInMediaTimescale=I(e)):o===1&&(e.skip(16),a.timescale=I(e),a.durationInMediaTimescale=we(e));let c=ee(e);if(c>0){a.languageCode="";for(let l=0;l<3;l++)a.languageCode=String.fromCharCode(96+(c&31))+a.languageCode,c>>=5;qt(a.languageCode)||(a.languageCode=he)}}break;case"hdlr":{const a=this.currentTrack;if(!a)break;e.skip(8);const o=re(e,4);o==="vide"?a.info={type:"video",width:-1,height:-1,codec:null,codecDescription:null,colorSpace:null,avcType:null,avcCodecInfo:null,hevcCodecInfo:null,vp9CodecInfo:null,av1CodecInfo:null}:o==="soun"&&(a.info={type:"audio",numberOfChannels:-1,sampleRate:-1,codec:null,codecDescription:null,aacCodecInfo:null})}break;case"stbl":{const a=this.currentTrack;if(!a)break;a.sampleTableByteOffset=r,this.readContiguousBoxes(e.slice(s,i.contentSize))}break;case"stsd":{const a=this.currentTrack;if(!a||a.info===null||a.sampleTable)break;const o=F(e);e.skip(3);const c=I(e);for(let l=0;l<c;l++){const u=e.filePos,d=qe(e);if(!d)break;a.internalCodecId=d.name;const h=d.name.toLowerCase();if(a.info.type==="video")h==="avc1"||h==="avc3"?(a.info.codec="avc",a.info.avcType=h==="avc1"?1:3):h==="hvc1"||h==="hev1"?a.info.codec="hevc":h==="vp08"?a.info.codec="vp8":h==="vp09"?a.info.codec="vp9":h==="av01"?a.info.codec="av1":console.warn(`Unsupported video codec (sample entry type '${d.name}').`),e.skip(24),a.info.width=ee(e),a.info.height=ee(e),e.skip(50),this.readContiguousBoxes(e.slice(e.filePos,u+d.totalSize-e.filePos));else{h==="mp4a"||(h==="opus"?a.info.codec="opus":h==="flac"?a.info.codec="flac":h==="twos"||h==="sowt"||h==="raw "||h==="in24"||h==="in32"||h==="fl32"||h==="fl64"||h==="lpcm"||h==="ipcm"||h==="fpcm"||(h==="ulaw"?a.info.codec="ulaw":h==="alaw"?a.info.codec="alaw":console.warn(`Unsupported audio codec (sample entry type '${d.name}').`))),e.skip(8);const f=ee(e);e.skip(6);let p=ee(e),g=ee(e);e.skip(4);let k=I(e)/65536;if(o===0&&f>0){if(f===1)e.skip(4),g=8*I(e),e.skip(8);else if(f===2){e.skip(4),k=$s(e),p=I(e),e.skip(4),g=I(e);const w=I(e);if(e.skip(8),h==="lpcm"){const b=g+7>>3,y=!!(w&1),T=!!(w&2),x=w&4?-1:0;g>0&&g<=64&&(y?g===32&&(a.info.codec=T?"pcm-f32be":"pcm-f32"):x&1<<b-1?b===1?a.info.codec="pcm-s8":b===2?a.info.codec=T?"pcm-s16be":"pcm-s16":b===3?a.info.codec=T?"pcm-s24be":"pcm-s24":b===4&&(a.info.codec=T?"pcm-s32be":"pcm-s32"):b===1&&(a.info.codec="pcm-u8")),a.info.codec===null&&console.warn("Unsupported PCM format.")}}}a.info.codec==="opus"&&(k=wr),a.info.numberOfChannels=p,a.info.sampleRate=k,h==="twos"?g===8?a.info.codec="pcm-s8":g===16?a.info.codec="pcm-s16be":(console.warn(`Unsupported sample size ${g} for codec 'twos'.`),a.info.codec=null):h==="sowt"?g===8?a.info.codec="pcm-s8":g===16?a.info.codec="pcm-s16":(console.warn(`Unsupported sample size ${g} for codec 'sowt'.`),a.info.codec=null):h==="raw "?a.info.codec="pcm-u8":h==="in24"?a.info.codec="pcm-s24be":h==="in32"?a.info.codec="pcm-s32be":h==="fl32"?a.info.codec="pcm-f32be":h==="fl64"?a.info.codec="pcm-f64be":h==="ipcm"?a.info.codec="pcm-s16be":h==="fpcm"&&(a.info.codec="pcm-f32be"),this.readContiguousBoxes(e.slice(e.filePos,u+d.totalSize-e.filePos))}}}break;case"avcC":{const a=this.currentTrack;if(!a)break;m(a.info),a.info.codecDescription=O(e,i.contentSize)}break;case"hvcC":{const a=this.currentTrack;if(!a)break;m(a.info),a.info.codecDescription=O(e,i.contentSize)}break;case"vpcC":{const a=this.currentTrack;if(!a)break;m(a.info?.type==="video"),e.skip(4);const o=F(e),c=F(e),l=F(e),u=l>>4,d=l>>1&7,h=l&1,f=F(e),p=F(e),g=F(e);a.info.vp9CodecInfo={profile:o,level:c,bitDepth:u,chromaSubsampling:d,videoFullRangeFlag:h,colourPrimaries:f,transferCharacteristics:p,matrixCoefficients:g}}break;case"av1C":{const a=this.currentTrack;if(!a)break;m(a.info?.type==="video"),e.skip(1);const o=F(e),c=o>>5,l=o&31,u=F(e),d=u>>7,h=u>>6&1,f=u>>5&1,p=u>>4&1,g=u>>3&1,k=u>>2&1,w=u&3,b=c===2&&h?f?12:10:h?10:8;a.info.av1CodecInfo={profile:c,level:l,tier:d,bitDepth:b,monochrome:p,chromaSubsamplingX:g,chromaSubsamplingY:k,chromaSamplePosition:w}}break;case"colr":{const a=this.currentTrack;if(!a||(m(a.info?.type==="video"),re(e,4)!=="nclx"))break;const c=ee(e),l=ee(e),u=ee(e),d=!!(F(e)&128);a.info.colorSpace={primaries:ar[c],transfer:or[l],matrix:cr[u],fullRange:d}}break;case"wave":this.readContiguousBoxes(e.slice(s,i.contentSize));break;case"esds":{const a=this.currentTrack;if(!a)break;m(a.info?.type==="audio"),e.skip(4);const o=F(e);m(o===3),Fr(e),e.skip(2);const c=F(e),l=(c&128)!==0,u=(c&64)!==0,d=(c&32)!==0;if(l&&e.skip(2),u){const k=F(e);e.skip(k)}d&&e.skip(2);const h=F(e);m(h===4);const f=Fr(e),p=e.filePos,g=F(e);if(g===64||g===103?(a.info.codec="aac",a.info.aacCodecInfo={isMpeg2:g===103,objectType:null}):g===105||g===107?a.info.codec="mp3":g===221?a.info.codec="vorbis":console.warn(`Unsupported audio codec (objectTypeIndication ${g}) - discarding track.`),e.skip(12),f>e.filePos-p){const k=F(e);m(k===5);const w=Fr(e);if(a.info.codecDescription=O(e,w),a.info.codec==="aac"){const b=ui(a.info.codecDescription);b.numberOfChannels!==null&&(a.info.numberOfChannels=b.numberOfChannels),b.sampleRate!==null&&(a.info.sampleRate=b.sampleRate)}}}break;case"enda":{const a=this.currentTrack;if(!a)break;m(a.info?.type==="audio"),ee(e)&255&&(a.info.codec==="pcm-s16be"?a.info.codec="pcm-s16":a.info.codec==="pcm-s24be"?a.info.codec="pcm-s24":a.info.codec==="pcm-s32be"?a.info.codec="pcm-s32":a.info.codec==="pcm-f32be"?a.info.codec="pcm-f32":a.info.codec==="pcm-f64be"&&(a.info.codec="pcm-f64"))}break;case"pcmC":{const a=this.currentTrack;if(!a)break;m(a.info?.type==="audio"),e.skip(4);const c=!!(F(e)&1),l=F(e);a.info.codec==="pcm-s16be"?c?l===16?a.info.codec="pcm-s16":l===24?a.info.codec="pcm-s24":l===32?a.info.codec="pcm-s32":(console.warn(`Invalid ipcm sample size ${l}.`),a.info.codec=null):l===16?a.info.codec="pcm-s16be":l===24?a.info.codec="pcm-s24be":l===32?a.info.codec="pcm-s32be":(console.warn(`Invalid ipcm sample size ${l}.`),a.info.codec=null):a.info.codec==="pcm-f32be"&&(c?l===32?a.info.codec="pcm-f32":l===64?a.info.codec="pcm-f64":(console.warn(`Invalid fpcm sample size ${l}.`),a.info.codec=null):l===32?a.info.codec="pcm-f32be":l===64?a.info.codec="pcm-f64be":(console.warn(`Invalid fpcm sample size ${l}.`),a.info.codec=null));break}case"dOps":{const a=this.currentTrack;if(!a)break;m(a.info?.type==="audio"),e.skip(1);const o=F(e),c=ee(e),l=I(e),u=ei(e),d=F(e);let h;d!==0?h=O(e,2+o):h=new Uint8Array(0);const f=new Uint8Array(19+h.byteLength),p=new DataView(f.buffer);p.setUint32(0,1332770163,!1),p.setUint32(4,1214603620,!1),p.setUint8(8,1),p.setUint8(9,o),p.setUint16(10,c,!0),p.setUint32(12,l,!0),p.setInt16(16,u,!0),p.setUint8(18,d),f.set(h,19),a.info.codecDescription=f,a.info.numberOfChannels=o}break;case"dfLa":{const a=this.currentTrack;if(!a)break;m(a.info?.type==="audio"),e.skip(4);const o=127,c=128,l=e.filePos;for(;e.filePos<n;){const p=F(e),g=wt(e);if((p&o)===It.STREAMINFO){e.skip(10);const w=I(e),b=w>>>12,y=(w>>9&7)+1;a.info.sampleRate=b,a.info.numberOfChannels=y,e.skip(20)}else e.skip(g);if(p&c)break}const u=e.filePos;e.filePos=l;const d=O(e,u-l),h=new Uint8Array(4+d.byteLength);new DataView(h.buffer).setUint32(0,1716281667,!1),h.set(d,4),a.info.codecDescription=h}break;case"stts":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4);const o=I(e);let c=0,l=0;for(let u=0;u<o;u++){const d=I(e),h=I(e);a.sampleTable.sampleTimingEntries.push({startIndex:c,startDecodeTimestamp:l,count:d,delta:h}),c+=d,l+=d*h}}break;case"ctts":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4);const o=I(e);let c=0;for(let l=0;l<o;l++){const u=I(e),d=nt(e);a.sampleTable.sampleCompositionTimeOffsets.push({startIndex:c,count:u,offset:d}),c+=u}}break;case"stsz":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4);const o=I(e),c=I(e);if(o===0)for(let l=0;l<c;l++){const u=I(e);a.sampleTable.sampleSizes.push(u)}else a.sampleTable.sampleSizes.push(o)}break;case"stz2":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4),e.skip(3);const o=F(e),c=I(e),l=O(e,Math.ceil(c*o/8)),u=new K(l);for(let d=0;d<c;d++){const h=u.readBits(o);a.sampleTable.sampleSizes.push(h)}}break;case"stss":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4),a.sampleTable.keySampleIndices=[];const o=I(e);for(let c=0;c<o;c++){const l=I(e)-1;a.sampleTable.keySampleIndices.push(l)}a.sampleTable.keySampleIndices[0]!==0&&a.sampleTable.keySampleIndices.unshift(0)}break;case"stsc":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4);const o=I(e);for(let l=0;l<o;l++){const u=I(e)-1,d=I(e),h=I(e);a.sampleTable.sampleToChunk.push({startSampleIndex:-1,startChunkIndex:u,samplesPerChunk:d,sampleDescriptionIndex:h})}let c=0;for(let l=0;l<a.sampleTable.sampleToChunk.length;l++)if(a.sampleTable.sampleToChunk[l].startSampleIndex=c,l<a.sampleTable.sampleToChunk.length-1){const d=a.sampleTable.sampleToChunk[l+1].startChunkIndex-a.sampleTable.sampleToChunk[l].startChunkIndex;c+=d*a.sampleTable.sampleToChunk[l].samplesPerChunk}}break;case"stco":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4);const o=I(e);for(let c=0;c<o;c++){const l=I(e);a.sampleTable.chunkOffsets.push(l)}}break;case"co64":{const a=this.currentTrack;if(!a||!a.sampleTable)break;e.skip(4);const o=I(e);for(let c=0;c<o;c++){const l=we(e);a.sampleTable.chunkOffsets.push(l)}}break;case"mvex":this.isFragmented=!0,this.readContiguousBoxes(e.slice(s,i.contentSize));break;case"mehd":{const a=F(e);e.skip(3);const o=a===1?we(e):I(e);this.movieDurationInTimescale=o}break;case"trex":{e.skip(4);const a=I(e),o=I(e),c=I(e),l=I(e),u=I(e);this.fragmentTrackDefaults.push({trackId:a,defaultSampleDescriptionIndex:o,defaultSampleDuration:c,defaultSampleSize:l,defaultSampleFlags:u})}break;case"tfra":{const a=F(e);e.skip(3);const o=I(e),c=this.tracks.find(b=>b.id===o);if(!c)break;const l=I(e),u=(l&48)>>4,d=(l&12)>>2,h=l&3,f=[F,ee,wt,I],p=f[u],g=f[d],k=f[h],w=I(e);for(let b=0;b<w;b++){const y=a===1?we(e):I(e),T=a===1?we(e):I(e);p(e),g(e),k(e),c.fragmentLookupTable.push({timestamp:y,moofOffset:T})}c.fragmentLookupTable.sort((b,y)=>b.timestamp-y.timestamp);for(let b=0;b<c.fragmentLookupTable.length-1;b++){const y=c.fragmentLookupTable[b],T=c.fragmentLookupTable[b+1];y.timestamp===T.timestamp&&(c.fragmentLookupTable.splice(b+1,1),b--)}}break;case"moof":this.currentFragment={moofOffset:r,moofSize:i.totalSize,implicitBaseDataOffset:r,trackData:new Map},this.readContiguousBoxes(e.slice(s,i.contentSize)),this.lastReadFragment=this.currentFragment,this.currentFragment=null;break;case"traf":if(m(this.currentFragment),this.readContiguousBoxes(e.slice(s,i.contentSize)),this.currentTrack){const a=this.currentFragment.trackData.get(this.currentTrack.id);if(a){const{currentFragmentState:o}=this.currentTrack;m(o),o.startTimestamp!==null&&(Br(a,o.startTimestamp),a.startTimestampIsFinal=!0)}this.currentTrack.currentFragmentState=null,this.currentTrack=null}break;case"tfhd":{m(this.currentFragment),e.skip(1);const a=wt(e),o=!!(a&1),c=!!(a&2),l=!!(a&8),u=!!(a&16),d=!!(a&32),h=!!(a&65536),f=!!(a&131072),p=I(e),g=this.tracks.find(w=>w.id===p);if(!g)break;const k=this.fragmentTrackDefaults.find(w=>w.trackId===p);this.currentTrack=g,g.currentFragmentState={baseDataOffset:this.currentFragment.implicitBaseDataOffset,sampleDescriptionIndex:k?.defaultSampleDescriptionIndex??null,defaultSampleDuration:k?.defaultSampleDuration??null,defaultSampleSize:k?.defaultSampleSize??null,defaultSampleFlags:k?.defaultSampleFlags??null,startTimestamp:null},o?g.currentFragmentState.baseDataOffset=we(e):f&&(g.currentFragmentState.baseDataOffset=this.currentFragment.moofOffset),c&&(g.currentFragmentState.sampleDescriptionIndex=I(e)),l&&(g.currentFragmentState.defaultSampleDuration=I(e)),u&&(g.currentFragmentState.defaultSampleSize=I(e)),d&&(g.currentFragmentState.defaultSampleFlags=I(e)),h&&(g.currentFragmentState.defaultSampleDuration=0)}break;case"tfdt":{const a=this.currentTrack;if(!a)break;m(a.currentFragmentState);const o=F(e);e.skip(3);const c=o===0?I(e):we(e);a.currentFragmentState.startTimestamp=c}break;case"trun":{const a=this.currentTrack;if(!a)break;if(m(this.currentFragment),m(a.currentFragmentState),this.currentFragment.trackData.has(a.id)){console.warn("Can't have two trun boxes for the same track in one fragment. Ignoring...");break}const o=F(e),c=wt(e),l=!!(c&1),u=!!(c&4),d=!!(c&256),h=!!(c&512),f=!!(c&1024),p=!!(c&2048),g=I(e);let k=a.currentFragmentState.baseDataOffset;l&&(k+=nt(e));let w=null;u&&(w=I(e));let b=k;if(g===0){this.currentFragment.implicitBaseDataOffset=b;break}let y=0;const T={track:a,startTimestamp:0,endTimestamp:0,firstKeyFrameTimestamp:null,samples:[],presentationTimestamps:[],startTimestampIsFinal:!1};this.currentFragment.trackData.set(a.id,T);for(let _=0;_<g;_++){let C;d?C=I(e):(m(a.currentFragmentState.defaultSampleDuration!==null),C=a.currentFragmentState.defaultSampleDuration);let R;h?R=I(e):(m(a.currentFragmentState.defaultSampleSize!==null),R=a.currentFragmentState.defaultSampleSize);let M;f?M=I(e):(m(a.currentFragmentState.defaultSampleFlags!==null),M=a.currentFragmentState.defaultSampleFlags),_===0&&w!==null&&(M=w);let A=0;p&&(o===0?A=I(e):A=nt(e));const z=!(M&65536);T.samples.push({presentationTimestamp:y+A,duration:C,byteOffset:b,byteSize:R,isKeyFrame:z}),b+=R,y+=C}T.presentationTimestamps=T.samples.map((_,C)=>({presentationTimestamp:_.presentationTimestamp,sampleIndex:C})).sort((_,C)=>_.presentationTimestamp-C.presentationTimestamp);for(let _=0;_<T.presentationTimestamps.length;_++){const C=T.presentationTimestamps[_],R=T.samples[C.sampleIndex];if(T.firstKeyFrameTimestamp===null&&R.isKeyFrame&&(T.firstKeyFrameTimestamp=R.presentationTimestamp),_<T.presentationTimestamps.length-1){const M=T.presentationTimestamps[_+1];R.duration=M.presentationTimestamp-C.presentationTimestamp}}const x=T.samples[T.presentationTimestamps[0].sampleIndex],P=T.samples[G(T.presentationTimestamps).sampleIndex];T.startTimestamp=x.presentationTimestamp,T.endTimestamp=P.presentationTimestamp+P.duration,this.currentFragment.implicitBaseDataOffset=b}break;case"udta":{const a=this.iterateContiguousBoxes(e.slice(s,i.contentSize));for(const{boxInfo:o,slice:c}of a){if(o.name!=="meta"&&!this.currentTrack){const l=c.filePos;this.metadataTags.raw??={},o.name[0]===""?this.metadataTags.raw[o.name]??=Se(c):this.metadataTags.raw[o.name]??=O(c,o.contentSize),c.filePos=l}switch(o.name){case"meta":c.skip(-o.headerSize),this.traverseBox(c);break;case"nam":case"name":this.currentTrack?this.currentTrack.name=ke.decode(O(c,o.contentSize)):this.metadataTags.title??=Se(c);break;case"des":this.currentTrack||(this.metadataTags.description??=Se(c));break;case"ART":this.currentTrack||(this.metadataTags.artist??=Se(c));break;case"alb":this.currentTrack||(this.metadataTags.album??=Se(c));break;case"albr":this.currentTrack||(this.metadataTags.albumArtist??=Se(c));break;case"gen":this.currentTrack||(this.metadataTags.genre??=Se(c));break;case"day":if(!this.currentTrack){const l=new Date(Se(c));Number.isNaN(l.getTime())||(this.metadataTags.date??=l)}break;case"cmt":this.currentTrack||(this.metadataTags.comment??=Se(c));break;case"lyr":this.currentTrack||(this.metadataTags.lyrics??=Se(c));break}}}break;case"meta":{if(this.currentTrack)break;const o=I(e)!==0;this.currentMetadataKeys=new Map,o?this.readContiguousBoxes(e.slice(s,i.contentSize)):this.readContiguousBoxes(e.slice(s+4,i.contentSize-4)),this.currentMetadataKeys=null}break;case"keys":{if(!this.currentMetadataKeys)break;e.skip(4);const a=I(e);for(let o=0;o<a;o++){const c=I(e);e.skip(4);const l=ke.decode(O(e,c-8));this.currentMetadataKeys.set(o+1,l)}}break;case"ilst":{if(!this.currentMetadataKeys)break;const a=this.iterateContiguousBoxes(e.slice(s,i.contentSize));for(const{boxInfo:o,slice:c}of a){let l=o.name;const u=(l.charCodeAt(0)<<24)+(l.charCodeAt(1)<<16)+(l.charCodeAt(2)<<8)+l.charCodeAt(3);this.currentMetadataKeys.has(u)&&(l=this.currentMetadataKeys.get(u));const d=ba(c);switch(this.metadataTags.raw??={},this.metadataTags.raw[l]??=d,l){case"nam":case"titl":case"com.apple.quicktime.title":case"title":typeof d=="string"&&(this.metadataTags.title??=d);break;case"des":case"desc":case"dscp":case"com.apple.quicktime.description":case"description":typeof d=="string"&&(this.metadataTags.description??=d);break;case"ART":case"com.apple.quicktime.artist":case"artist":typeof d=="string"&&(this.metadataTags.artist??=d);break;case"alb":case"albm":case"com.apple.quicktime.album":case"album":typeof d=="string"&&(this.metadataTags.album??=d);break;case"aART":case"album_artist":typeof d=="string"&&(this.metadataTags.albumArtist??=d);break;case"cmt":case"com.apple.quicktime.comment":case"comment":typeof d=="string"&&(this.metadataTags.comment??=d);break;case"gen":case"gnre":case"com.apple.quicktime.genre":case"genre":typeof d=="string"&&(this.metadataTags.genre??=d);break;case"lyr":case"lyrics":typeof d=="string"&&(this.metadataTags.lyrics??=d);break;case"day":case"rldt":case"com.apple.quicktime.creationdate":case"date":if(typeof d=="string"){const h=new Date(d);Number.isNaN(h.getTime())||(this.metadataTags.date??=h)}break;case"covr":case"com.apple.quicktime.artwork":d instanceof Et?(this.metadataTags.images??=[],this.metadataTags.images.push({data:d.data,kind:"coverFront",mimeType:d.mimeType})):d instanceof Uint8Array&&(this.metadataTags.images??=[],this.metadataTags.images.push({data:d,kind:"coverFront",mimeType:"image/*"}));break;case"track":if(typeof d=="string"){const h=d.split("/"),f=Number.parseInt(h[0],10),p=h[1]&&Number.parseInt(h[1],10);Number.isInteger(f)&&f>0&&(this.metadataTags.trackNumber??=f),p&&Number.isInteger(p)&&p>0&&(this.metadataTags.tracksTotal??=p)}break;case"trkn":if(d instanceof Uint8Array&&d.length>=6){const h=X(d),f=h.getUint16(2,!1),p=h.getUint16(4,!1);f>0&&(this.metadataTags.trackNumber??=f),p>0&&(this.metadataTags.tracksTotal??=p)}break;case"disc":case"disk":if(d instanceof Uint8Array&&d.length>=6){const h=X(d),f=h.getUint16(2,!1),p=h.getUint16(4,!1);f>0&&(this.metadataTags.discNumber??=f),p>0&&(this.metadataTags.discsTotal??=p)}break}}}break}return e.filePos=n,!0}}class Rs{constructor(e){this.internalTrack=e,this.packetToSampleIndex=new WeakMap,this.packetToFragmentLocation=new WeakMap}getId(){return this.internalTrack.id}getCodec(){throw new Error("Not implemented on base class.")}getInternalCodecId(){return this.internalTrack.internalCodecId}getName(){return this.internalTrack.name}getLanguageCode(){return this.internalTrack.languageCode}getTimeResolution(){return this.internalTrack.timescale}getDisposition(){return this.internalTrack.disposition}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}async getFirstTimestamp(){return(await this.getFirstPacket({metadataOnly:!0}))?.timestamp??0}async getFirstPacket(e){const r=await this.fetchPacketForSampleIndex(0,e);return r||!this.internalTrack.demuxer.isFragmented?r:this.performFragmentedLookup(null,i=>i.trackData.get(this.internalTrack.id)?{sampleIndex:0,correctSampleFound:!0}:{sampleIndex:-1,correctSampleFound:!1},-1/0,1/0,e)}mapTimestampIntoTimescale(e){return Ht(e*this.internalTrack.timescale)+this.internalTrack.editListOffset}async getPacket(e,r){const i=this.mapTimestampIntoTimescale(e),s=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),n=Gr(s,i),a=await this.fetchPacketForSampleIndex(n,r);return!ji(s)||!this.internalTrack.demuxer.isFragmented?a:this.performFragmentedLookup(null,o=>{const c=o.trackData.get(this.internalTrack.id);if(!c)return{sampleIndex:-1,correctSampleFound:!1};const l=L(c.presentationTimestamps,i,h=>h.presentationTimestamp),u=l!==-1?c.presentationTimestamps[l].sampleIndex:-1,d=l!==-1&&i<c.endTimestamp;return{sampleIndex:u,correctSampleFound:d}},i,i,r)}async getNextPacket(e,r){const i=this.packetToSampleIndex.get(e);if(i!==void 0)return this.fetchPacketForSampleIndex(i+1,r);const s=this.packetToFragmentLocation.get(e);if(s===void 0)throw new Error("Packet was not created from this track.");return this.performFragmentedLookup(s.fragment,n=>{if(n===s.fragment){const a=n.trackData.get(this.internalTrack.id);if(s.sampleIndex+1<a.samples.length)return{sampleIndex:s.sampleIndex+1,correctSampleFound:!0}}else if(n.trackData.get(this.internalTrack.id))return{sampleIndex:0,correctSampleFound:!0};return{sampleIndex:-1,correctSampleFound:!1}},-1/0,1/0,r)}async getKeyPacket(e,r){const i=this.mapTimestampIntoTimescale(e),s=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),n=Sa(s,i),a=await this.fetchPacketForSampleIndex(n,r);return!ji(s)||!this.internalTrack.demuxer.isFragmented?a:this.performFragmentedLookup(null,o=>{const c=o.trackData.get(this.internalTrack.id);if(!c)return{sampleIndex:-1,correctSampleFound:!1};const l=ai(c.presentationTimestamps,h=>c.samples[h.sampleIndex].isKeyFrame&&h.presentationTimestamp<=i),u=l!==-1?c.presentationTimestamps[l].sampleIndex:-1,d=l!==-1&&i<c.endTimestamp;return{sampleIndex:u,correctSampleFound:d}},i,i,r)}async getNextKeyPacket(e,r){const i=this.packetToSampleIndex.get(e);if(i!==void 0){const n=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),a=xa(n,i);return this.fetchPacketForSampleIndex(a,r)}const s=this.packetToFragmentLocation.get(e);if(s===void 0)throw new Error("Packet was not created from this track.");return this.performFragmentedLookup(s.fragment,n=>{if(n===s.fragment){const o=n.trackData.get(this.internalTrack.id).samples.findIndex((c,l)=>c.isKeyFrame&&l>s.sampleIndex);if(o!==-1)return{sampleIndex:o,correctSampleFound:!0}}else{const a=n.trackData.get(this.internalTrack.id);if(a&&a.firstKeyFrameTimestamp!==null){const o=a.samples.findIndex(c=>c.isKeyFrame);return m(o!==-1),{sampleIndex:o,correctSampleFound:!0}}}return{sampleIndex:-1,correctSampleFound:!1}},-1/0,1/0,r)}async fetchPacketForSampleIndex(e,r){if(e===-1)return null;const i=this.internalTrack.demuxer.getSampleTableForTrack(this.internalTrack),s=Pa(i,e);if(!s)return null;let n;if(r.metadataOnly)n=me;else{let l=this.internalTrack.demuxer.reader.requestSlice(s.sampleOffset,s.sampleSize);l instanceof Promise&&(l=await l),m(l),n=O(l,s.sampleSize)}const a=(s.presentationTimestamp-this.internalTrack.editListOffset)/this.internalTrack.timescale,o=s.duration/this.internalTrack.timescale,c=new j(n,s.isKeyFrame?"key":"delta",a,o,e,s.sampleSize);return this.packetToSampleIndex.set(c,e),c}async fetchPacketInFragment(e,r,i){if(r===-1)return null;const n=e.trackData.get(this.internalTrack.id).samples[r];m(n);let a;if(i.metadataOnly)a=me;else{let u=this.internalTrack.demuxer.reader.requestSlice(n.byteOffset,n.byteSize);u instanceof Promise&&(u=await u),m(u),a=O(u,n.byteSize)}const o=(n.presentationTimestamp-this.internalTrack.editListOffset)/this.internalTrack.timescale,c=n.duration/this.internalTrack.timescale,l=new j(a,n.isKeyFrame?"key":"delta",o,c,e.moofOffset+r,n.byteSize);return this.packetToFragmentLocation.set(l,{fragment:e,sampleIndex:r}),l}async performFragmentedLookup(e,r,i,s,n){const a=this.internalTrack.demuxer;let o=null,c=null,l=-1;if(e){const{sampleIndex:k,correctSampleFound:w}=r(e);if(w)return this.fetchPacketInFragment(e,k,n);k!==-1&&(c=e,l=k)}const u=L(this.internalTrack.fragmentLookupTable,i,k=>k.timestamp),d=u!==-1?this.internalTrack.fragmentLookupTable[u]:null,h=L(this.internalTrack.fragmentPositionCache,i,k=>k.startTimestamp),f=h!==-1?this.internalTrack.fragmentPositionCache[h]:null,p=Math.max(d?.moofOffset??0,f?.moofOffset??0)||null;let g;for(e?p===null||e.moofOffset>=p?(g=e.moofOffset+e.moofSize,o=e):g=p:g=p??0;;){if(o){const y=o.trackData.get(this.internalTrack.id);if(y&&y.startTimestamp>s)break}let k=a.reader.requestSliceRange(g,Oe,it);if(k instanceof Promise&&(k=await k),!k)break;const w=g,b=qe(k);if(!b)break;if(b.name==="moof"){o=await a.readFragment(w);const{sampleIndex:y,correctSampleFound:T}=r(o);if(T)return this.fetchPacketInFragment(o,y,n);y!==-1&&(c=o,l=y)}g=w+b.totalSize}if(d&&(!c||c.moofOffset<d.moofOffset)){const k=this.internalTrack.fragmentLookupTable[u-1];m(!k||k.timestamp<d.timestamp);const w=k?.timestamp??-1/0;return this.performFragmentedLookup(null,r,w,s,n)}return c?this.fetchPacketInFragment(c,l,n):null}}class ya extends Rs{constructor(e){super(e),this.decoderConfigPromise=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getCodedWidth(){return this.internalTrack.info.width}getCodedHeight(){return this.internalTrack.info.height}getRotation(){return this.internalTrack.rotation}async getColorSpace(){return{primaries:this.internalTrack.info.colorSpace?.primaries,transfer:this.internalTrack.info.colorSpace?.transfer,matrix:this.internalTrack.info.colorSpace?.matrix,fullRange:this.internalTrack.info.colorSpace?.fullRange}}async canBeTransparent(){return!1}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfigPromise??=(async()=>{if(this.internalTrack.info.codec==="vp9"&&!this.internalTrack.info.vp9CodecInfo){const e=await this.getFirstPacket({});this.internalTrack.info.vp9CodecInfo=e&&Ss(e.data)}else if(this.internalTrack.info.codec==="av1"&&!this.internalTrack.info.av1CodecInfo){const e=await this.getFirstPacket({});this.internalTrack.info.av1CodecInfo=e&&xs(e.data)}return{codec:ci(this.internalTrack.info),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}})():null}}class Ta extends Rs{constructor(e){super(e),this.decoderConfig=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfig??={codec:li(this.internalTrack.info),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}:null}}const Gr=(t,e)=>{if(t.presentationTimestamps){const r=L(t.presentationTimestamps,e,i=>i.presentationTimestamp);return r===-1?-1:t.presentationTimestamps[r].sampleIndex}else{const r=L(t.sampleTimingEntries,e,s=>s.startDecodeTimestamp);if(r===-1)return-1;const i=t.sampleTimingEntries[r];return i.startIndex+Math.min(Math.floor((e-i.startDecodeTimestamp)/i.delta),i.count-1)}},Sa=(t,e)=>{if(!t.keySampleIndices)return Gr(t,e);if(t.presentationTimestamps){const r=L(t.presentationTimestamps,e,i=>i.presentationTimestamp);if(r===-1)return-1;for(let i=r;i>=0;i--){const s=t.presentationTimestamps[i].sampleIndex;if(Zt(t.keySampleIndices,s,a=>a)!==-1)return s}return-1}else{const r=Gr(t,e),i=L(t.keySampleIndices,r,s=>s);return t.keySampleIndices[i]??-1}},Pa=(t,e)=>{const r=L(t.sampleTimingEntries,e,w=>w.startIndex),i=t.sampleTimingEntries[r];if(!i||i.startIndex+i.count<=e)return null;let n=i.startDecodeTimestamp+(e-i.startIndex)*i.delta;const a=L(t.sampleCompositionTimeOffsets,e,w=>w.startIndex),o=t.sampleCompositionTimeOffsets[a];o&&e-o.startIndex<o.count&&(n+=o.offset);const c=t.sampleSizes[Math.min(e,t.sampleSizes.length-1)],l=L(t.sampleToChunk,e,w=>w.startSampleIndex),u=t.sampleToChunk[l];m(u);const d=u.startChunkIndex+Math.floor((e-u.startSampleIndex)/u.samplesPerChunk),h=t.chunkOffsets[d],f=u.startSampleIndex+(d-u.startChunkIndex)*u.samplesPerChunk;let p=0,g=h;if(t.sampleSizes.length===1)g+=c*(e-f),p+=c*u.samplesPerChunk;else for(let w=f;w<f+u.samplesPerChunk;w++){const b=t.sampleSizes[w];w<e&&(g+=b),p+=b}let k=i.delta;if(t.presentationTimestamps){const w=t.presentationTimestampIndexMap[e];m(w!==void 0),w<t.presentationTimestamps.length-1&&(k=t.presentationTimestamps[w+1].presentationTimestamp-n)}return{presentationTimestamp:n,duration:k,sampleOffset:g,sampleSize:c,chunkOffset:h,chunkSize:p,isKeyFrame:t.keySampleIndices?Zt(t.keySampleIndices,e,w=>w)!==-1:!0}},xa=(t,e)=>{if(!t.keySampleIndices)return e+1;const r=L(t.keySampleIndices,e,i=>i);return t.keySampleIndices[r+1]??-1},Br=(t,e)=>{t.startTimestamp+=e,t.endTimestamp+=e;for(const r of t.samples)r.presentationTimestamp+=e;for(const r of t.presentationTimestamps)r.presentationTimestamp+=e},Ca=t=>{const[e,,,r]=t,i=Math.hypot(e,r),s=e/i,n=r/i,a=-Math.atan2(n,s)*(180/Math.PI);return Number.isFinite(a)?a:0},ji=t=>t.sampleSizes.length===0;var S;(function(t){t[t.EBML=440786851]="EBML",t[t.EBMLVersion=17030]="EBMLVersion",t[t.EBMLReadVersion=17143]="EBMLReadVersion",t[t.EBMLMaxIDLength=17138]="EBMLMaxIDLength",t[t.EBMLMaxSizeLength=17139]="EBMLMaxSizeLength",t[t.DocType=17026]="DocType",t[t.DocTypeVersion=17031]="DocTypeVersion",t[t.DocTypeReadVersion=17029]="DocTypeReadVersion",t[t.Void=236]="Void",t[t.Segment=408125543]="Segment",t[t.SeekHead=290298740]="SeekHead",t[t.Seek=19899]="Seek",t[t.SeekID=21419]="SeekID",t[t.SeekPosition=21420]="SeekPosition",t[t.Duration=17545]="Duration",t[t.Info=357149030]="Info",t[t.TimestampScale=2807729]="TimestampScale",t[t.MuxingApp=19840]="MuxingApp",t[t.WritingApp=22337]="WritingApp",t[t.Tracks=374648427]="Tracks",t[t.TrackEntry=174]="TrackEntry",t[t.TrackNumber=215]="TrackNumber",t[t.TrackUID=29637]="TrackUID",t[t.TrackType=131]="TrackType",t[t.FlagEnabled=185]="FlagEnabled",t[t.FlagDefault=136]="FlagDefault",t[t.FlagForced=21930]="FlagForced",t[t.FlagOriginal=21934]="FlagOriginal",t[t.FlagHearingImpaired=21931]="FlagHearingImpaired",t[t.FlagVisualImpaired=21932]="FlagVisualImpaired",t[t.FlagCommentary=21935]="FlagCommentary",t[t.FlagLacing=156]="FlagLacing",t[t.Name=21358]="Name",t[t.Language=2274716]="Language",t[t.LanguageBCP47=2274717]="LanguageBCP47",t[t.CodecID=134]="CodecID",t[t.CodecPrivate=25506]="CodecPrivate",t[t.CodecDelay=22186]="CodecDelay",t[t.SeekPreRoll=22203]="SeekPreRoll",t[t.DefaultDuration=2352003]="DefaultDuration",t[t.Video=224]="Video",t[t.PixelWidth=176]="PixelWidth",t[t.PixelHeight=186]="PixelHeight",t[t.AlphaMode=21440]="AlphaMode",t[t.Audio=225]="Audio",t[t.SamplingFrequency=181]="SamplingFrequency",t[t.Channels=159]="Channels",t[t.BitDepth=25188]="BitDepth",t[t.SimpleBlock=163]="SimpleBlock",t[t.BlockGroup=160]="BlockGroup",t[t.Block=161]="Block",t[t.BlockAdditions=30113]="BlockAdditions",t[t.BlockMore=166]="BlockMore",t[t.BlockAdditional=165]="BlockAdditional",t[t.BlockAddID=238]="BlockAddID",t[t.BlockDuration=155]="BlockDuration",t[t.ReferenceBlock=251]="ReferenceBlock",t[t.Cluster=524531317]="Cluster",t[t.Timestamp=231]="Timestamp",t[t.Cues=475249515]="Cues",t[t.CuePoint=187]="CuePoint",t[t.CueTime=179]="CueTime",t[t.CueTrackPositions=183]="CueTrackPositions",t[t.CueTrack=247]="CueTrack",t[t.CueClusterPosition=241]="CueClusterPosition",t[t.Colour=21936]="Colour",t[t.MatrixCoefficients=21937]="MatrixCoefficients",t[t.TransferCharacteristics=21946]="TransferCharacteristics",t[t.Primaries=21947]="Primaries",t[t.Range=21945]="Range",t[t.Projection=30320]="Projection",t[t.ProjectionType=30321]="ProjectionType",t[t.ProjectionPoseRoll=30325]="ProjectionPoseRoll",t[t.Attachments=423732329]="Attachments",t[t.AttachedFile=24999]="AttachedFile",t[t.FileDescription=18046]="FileDescription",t[t.FileName=18030]="FileName",t[t.FileMediaType=18016]="FileMediaType",t[t.FileData=18012]="FileData",t[t.FileUID=18094]="FileUID",t[t.Chapters=272869232]="Chapters",t[t.Tags=307544935]="Tags",t[t.Tag=29555]="Tag",t[t.Targets=25536]="Targets",t[t.TargetTypeValue=26826]="TargetTypeValue",t[t.TargetType=25546]="TargetType",t[t.TagTrackUID=25541]="TagTrackUID",t[t.TagEditionUID=25545]="TagEditionUID",t[t.TagChapterUID=25540]="TagChapterUID",t[t.TagAttachmentUID=25542]="TagAttachmentUID",t[t.SimpleTag=26568]="SimpleTag",t[t.TagName=17827]="TagName",t[t.TagLanguage=17530]="TagLanguage",t[t.TagString=17543]="TagString",t[t.TagBinary=17541]="TagBinary",t[t.ContentEncodings=28032]="ContentEncodings",t[t.ContentEncoding=25152]="ContentEncoding",t[t.ContentEncodingOrder=20529]="ContentEncodingOrder",t[t.ContentEncodingScope=20530]="ContentEncodingScope",t[t.ContentCompression=20532]="ContentCompression",t[t.ContentCompAlgo=16980]="ContentCompAlgo",t[t.ContentCompSettings=16981]="ContentCompSettings",t[t.ContentEncryption=20533]="ContentEncryption"})(S||(S={}));const va=[S.EBML,S.Segment],Kt=[S.SeekHead,S.Info,S.Cluster,S.Tracks,S.Cues,S.Attachments,S.Chapters,S.Tags],sr=[...va,...Kt],Xr=8,pe=2,Ne=2*Xr,Ds=t=>{if(t.remainingLength<1)return null;const e=F(t);if(t.skip(-1),e===0)return null;let r=1,i=128;for(;(e&i)===0;)r++,i>>=1;return t.remainingLength<r?null:r},Ot=t=>{if(t.remainingLength<1)return null;const e=F(t);if(e===0)return null;let r=1,i=128;for(;(e&i)===0;)r++,i>>=1;if(t.remainingLength<r-1)return null;let s=e&i-1;for(let n=1;n<r;n++)s*=256,s+=F(t);return s},N=(t,e)=>{if(e<1||e>8)throw new Error("Bad unsigned int size "+e);let r=0;for(let i=0;i<e;i++)r*=256,r+=F(t);return r},Ea=(t,e)=>{if(e<1)throw new Error("Bad unsigned int size "+e);let r=0n;for(let i=0;i<e;i++)r<<=8n,r+=BigInt(F(t));return r},wi=t=>{const e=Ds(t);return e===null||t.remainingLength<e?null:N(t,e)},zs=t=>{if(t.remainingLength<1)return null;if(F(t)===255)return;t.skip(-1);const r=Ot(t);if(r===null)return null;if(r!==72057594037927940)return r},ze=t=>{m(t.remainingLength>=pe);const e=wi(t);if(e===null)return null;const r=zs(t);return r===null?null:{id:e,size:r}},gt=(t,e)=>{const r=O(t,e);let i=0;for(;i<e&&r[i]!==0;)i+=1;return String.fromCharCode(...r.subarray(0,i))},Dt=(t,e)=>{const r=O(t,e);let i=0;for(;i<e&&r[i]!==0;)i+=1;return ke.decode(r.subarray(0,i))},Rr=(t,e)=>{if(e===0)return 0;if(e!==4&&e!==8)throw new Error("Bad float size "+e);return e===4?Uo(t):$s(t)},Yr=async(t,e,r,i)=>{const s=new Set(r);let n=e;for(;i===null||n<i;){let a=t.requestSliceRange(n,pe,Ne);if(a instanceof Promise&&(a=await a),!a)break;const o=ze(a);if(!o)break;if(s.has(o.id))return{pos:n,found:!0};He(o.size),n=a.filePos+o.size}return{pos:i!==null&&i>n?i:n,found:!1}},Ms=async(t,e,r,i)=>{const n=new Set(r);let a=e;for(;a<i;){let o=t.requestSliceRange(a,0,Math.min(65536,i-a));if(o instanceof Promise&&(o=await o),!o||o.length<Xr)break;for(let c=0;c<o.length-Xr;c++){o.filePos=a;const l=wi(o);if(l!==null&&n.has(l))return a;a++}}return null},Pe={avc:"V_MPEG4/ISO/AVC",hevc:"V_MPEGH/ISO/HEVC",vp8:"V_VP8",vp9:"V_VP9",av1:"V_AV1",aac:"A_AAC",mp3:"A_MPEG/L3",opus:"A_OPUS",vorbis:"A_VORBIS",flac:"A_FLAC"};function He(t){if(t===void 0)throw new Error("Undefined element size is used in a place where it is not supported.")}const Ia=t=>{let r=(t.hasVideo?"video/":t.hasAudio?"audio/":"application/")+(t.isWebM?"webm":"x-matroska");if(t.codecStrings.length>0){const i=[...new Set(t.codecStrings.filter(Boolean))];r+=`; codecs="${i.join(", ")}"`}return r};var Be;(function(t){t[t.None=0]="None",t[t.Xiph=1]="Xiph",t[t.FixedSize=2]="FixedSize",t[t.Ebml=3]="Ebml"})(Be||(Be={}));var dr;(function(t){t[t.Block=1]="Block",t[t.Private=2]="Private",t[t.Next=4]="Next"})(dr||(dr={}));var Vt;(function(t){t[t.Zlib=0]="Zlib",t[t.Bzlib=1]="Bzlib",t[t.lzo1x=2]="lzo1x",t[t.HeaderStripping=3]="HeaderStripping"})(Vt||(Vt={}));const Dr=[{id:S.SeekHead,flag:"seekHeadSeen"},{id:S.Info,flag:"infoSeen"},{id:S.Tracks,flag:"tracksSeen"},{id:S.Cues,flag:"cuesSeen"}],Os=10*2**20;class _a extends Je{constructor(e){super(e),this.readMetadataPromise=null,this.segments=[],this.currentSegment=null,this.currentTrack=null,this.currentCluster=null,this.currentBlock=null,this.currentBlockAdditional=null,this.currentCueTime=null,this.currentDecodingInstruction=null,this.currentTagTargetIsMovie=!0,this.currentSimpleTagName=null,this.currentAttachedFile=null,this.isWebM=!1,this.reader=e._reader}async computeDuration(){const e=await this.getTracks(),r=await Promise.all(e.map(i=>i.computeDuration()));return Math.max(0,...r)}async getTracks(){return await this.readMetadata(),this.segments.flatMap(e=>e.tracks.map(r=>r.inputTrack))}async getMimeType(){await this.readMetadata();const e=await this.getTracks(),r=await Promise.all(e.map(i=>i.getCodecParameterString()));return Ia({isWebM:this.isWebM,hasVideo:this.segments.some(i=>i.tracks.some(s=>s.info?.type==="video")),hasAudio:this.segments.some(i=>i.tracks.some(s=>s.info?.type==="audio")),codecStrings:r.filter(Boolean)})}async getMetadataTags(){await this.readMetadata();for(const r of this.segments)r.metadataTagsCollected||(this.reader.fileSize!==null&&await this.loadSegmentMetadata(r),r.metadataTagsCollected=!0);let e={};for(const r of this.segments)e={...e,...r.metadataTags};return e}readMetadata(){return this.readMetadataPromise??=(async()=>{let e=0;for(;;){let r=this.reader.requestSliceRange(e,pe,Ne);if(r instanceof Promise&&(r=await r),!r)break;const i=ze(r);if(!i)break;const s=i.id;let n=i.size;const a=r.filePos;if(s===S.EBML){He(n);let o=this.reader.requestSlice(a,n);if(o instanceof Promise&&(o=await o),!o)break;this.readContiguousElements(o)}else if(s===S.Segment){if(await this.readSegment(a,n),n===void 0||this.reader.fileSize===null)break}else if(s===S.Cluster){if(this.reader.fileSize===null)break;n===void 0&&(n=(await Yr(this.reader,a,sr,this.reader.fileSize)).pos-a);const o=G(this.segments);o&&(o.elementEndPos=a+n)}He(n),e=a+n}})()}async readSegment(e,r){this.currentSegment={seekHeadSeen:!1,infoSeen:!1,tracksSeen:!1,cuesSeen:!1,tagsSeen:!1,attachmentsSeen:!1,timestampScale:-1,timestampFactor:-1,duration:-1,seekEntries:[],tracks:[],cuePoints:[],dataStartPos:e,elementEndPos:r===void 0?null:e+r,clusterSeekStartPos:e,lastReadCluster:null,metadataTags:{},metadataTagsCollected:!1},this.segments.push(this.currentSegment);let i=e;for(;this.currentSegment.elementEndPos===null||i<this.currentSegment.elementEndPos;){let o=this.reader.requestSliceRange(i,pe,Ne);if(o instanceof Promise&&(o=await o),!o)break;const c=i,l=ze(o);if(!l||!Kt.includes(l.id)&&l.id!==S.Void){const p=await Ms(this.reader,c,Kt,Math.min(this.currentSegment.elementEndPos??1/0,c+Os));if(p){i=p;continue}else break}const{id:u,size:d}=l,h=o.filePos,f=Dr.findIndex(p=>p.id===u);if(f!==-1){const p=Dr[f].flag;this.currentSegment[p]=!0,He(d);let g=this.reader.requestSlice(h,d);g instanceof Promise&&(g=await g),g&&this.readContiguousElements(g)}else if(u===S.Tags||u===S.Attachments){u===S.Tags?this.currentSegment.tagsSeen=!0:this.currentSegment.attachmentsSeen=!0,He(d);let p=this.reader.requestSlice(h,d);p instanceof Promise&&(p=await p),p&&this.readContiguousElements(p)}else if(u===S.Cluster){this.currentSegment.clusterSeekStartPos=c;break}if(d===void 0)break;i=h+d}if(this.currentSegment.seekEntries.sort((o,c)=>o.segmentPosition-c.segmentPosition),this.reader.fileSize!==null)for(const o of this.currentSegment.seekEntries){const c=Dr.find(p=>p.id===o.id);if(!c||this.currentSegment[c.flag])continue;let l=this.reader.requestSliceRange(e+o.segmentPosition,pe,Ne);if(l instanceof Promise&&(l=await l),!l)continue;const u=ze(l);if(!u)continue;const{id:d,size:h}=u;if(d!==c.id)continue;He(h),this.currentSegment[c.flag]=!0;let f=this.reader.requestSlice(l.filePos,h);f instanceof Promise&&(f=await f),f&&this.readContiguousElements(f)}this.currentSegment.timestampScale===-1&&(this.currentSegment.timestampScale=1e6,this.currentSegment.timestampFactor=1e9/1e6);for(const o of this.currentSegment.tracks)o.defaultDurationNs!==null&&(o.defaultDuration=this.currentSegment.timestampFactor*o.defaultDurationNs/1e9);this.currentSegment.tracks.sort((o,c)=>Number(c.disposition.default)-Number(o.disposition.default));const s=new Map(this.currentSegment.tracks.map(o=>[o.id,o]));for(const o of this.currentSegment.cuePoints){const c=s.get(o.trackId);c&&c.cuePoints.push(o)}for(const o of this.currentSegment.tracks){o.cuePoints.sort((c,l)=>c.time-l.time);for(let c=0;c<o.cuePoints.length-1;c++){const l=o.cuePoints[c],u=o.cuePoints[c+1];l.time===u.time&&(o.cuePoints.splice(c+1,1),c--)}}let n=null,a=-1/0;for(const o of this.currentSegment.tracks)o.cuePoints.length>a&&(a=o.cuePoints.length,n=o);for(const o of this.currentSegment.tracks)o.cuePoints.length===0&&(o.cuePoints=n.cuePoints);this.currentSegment=null}async readCluster(e,r){if(r.lastReadCluster?.elementStartPos===e)return r.lastReadCluster;let i=this.reader.requestSliceRange(e,pe,Ne);i instanceof Promise&&(i=await i),m(i);const s=e,n=ze(i);m(n);const a=n.id;m(a===S.Cluster);let o=n.size;const c=i.filePos;o===void 0&&(o=(await Yr(this.reader,c,sr,r.elementEndPos)).pos-c);let l=this.reader.requestSlice(c,o);l instanceof Promise&&(l=await l);const u={segment:r,elementStartPos:s,elementEndPos:c+o,dataStartPos:c,timestamp:-1,trackData:new Map};if(this.currentCluster=u,l){const d=this.readContiguousElements(l,sr);u.elementEndPos=d}for(const[,d]of u.trackData){const h=d.track;m(d.blocks.length>0);let f=!1;for(let w=0;w<d.blocks.length;w++){const b=d.blocks[w];b.timestamp+=u.timestamp,f||=b.lacing!==Be.None}d.presentationTimestamps=d.blocks.map((w,b)=>({timestamp:w.timestamp,blockIndex:b})).sort((w,b)=>w.timestamp-b.timestamp);for(let w=0;w<d.presentationTimestamps.length;w++){const b=d.presentationTimestamps[w],y=d.blocks[b.blockIndex];if(d.firstKeyFrameTimestamp===null&&y.isKeyFrame&&(d.firstKeyFrameTimestamp=y.timestamp),w<d.presentationTimestamps.length-1){const T=d.presentationTimestamps[w+1];y.duration=T.timestamp-y.timestamp}else y.duration===0&&h.defaultDuration!=null&&y.lacing===Be.None&&(y.duration=h.defaultDuration)}f&&(this.expandLacedBlocks(d.blocks,h),d.presentationTimestamps=d.blocks.map((w,b)=>({timestamp:w.timestamp,blockIndex:b})).sort((w,b)=>w.timestamp-b.timestamp));const p=d.blocks[d.presentationTimestamps[0].blockIndex],g=d.blocks[G(d.presentationTimestamps).blockIndex];d.startTimestamp=p.timestamp,d.endTimestamp=g.timestamp+g.duration;const k=L(h.clusterPositionCache,d.startTimestamp,w=>w.startTimestamp);(k===-1||h.clusterPositionCache[k].elementStartPos!==s)&&h.clusterPositionCache.splice(k+1,0,{elementStartPos:u.elementStartPos,startTimestamp:d.startTimestamp})}return r.lastReadCluster=u,u}getTrackDataInCluster(e,r){let i=e.trackData.get(r);if(!i){const s=e.segment.tracks.find(n=>n.id===r);if(!s)return null;i={track:s,startTimestamp:0,endTimestamp:0,firstKeyFrameTimestamp:null,blocks:[],presentationTimestamps:[]},e.trackData.set(r,i)}return i}expandLacedBlocks(e,r){for(let i=0;i<e.length;i++){const s=e[i];if(s.lacing===Be.None)continue;s.decoded||(s.data=this.decodeBlockData(r,s.data),s.decoded=!0);const n=ye.tempFromBytes(s.data),a=[],o=F(n)+1;switch(s.lacing){case Be.Xiph:{let l=0;for(let u=0;u<o-1;u++){let d=0;for(;n.bufferPos<n.length;){const h=F(n);if(d+=h,h<255){a.push(d),l+=d;break}}}a.push(n.length-(n.bufferPos+l))}break;case Be.FixedSize:{const l=n.length-1,u=Math.floor(l/o);for(let d=0;d<o;d++)a.push(u)}break;case Be.Ebml:{const l=Ot(n);m(l!==null);let u=l;a.push(u);let d=u;for(let h=1;h<o-1;h++){const f=n.bufferPos,p=Ot(n);m(p!==null);const g=p,w=(1<<(n.bufferPos-f)*7-1)-1,b=g-w;u+=b,a.push(u),d+=u}a.push(n.length-(n.bufferPos+d))}break;default:m(!1)}m(a.length===o),e.splice(i,1);const c=s.duration||o*(r.defaultDuration??0);for(let l=0;l<o;l++){const u=a[l],d=O(n,u),h=s.timestamp+c*l/o,f=c/o;e.splice(i+l,0,{timestamp:h,duration:f,isKeyFrame:s.isKeyFrame,data:d,lacing:Be.None,decoded:!0,mainAdditional:s.mainAdditional})}i+=o,i--}}async loadSegmentMetadata(e){for(const r of e.seekEntries){if(!(r.id===S.Tags&&!e.tagsSeen)){if(!(r.id===S.Attachments&&!e.attachmentsSeen))continue}let i=this.reader.requestSliceRange(e.dataStartPos+r.segmentPosition,pe,Ne);if(i instanceof Promise&&(i=await i),!i)continue;const s=ze(i);if(!s||s.id!==r.id)continue;const{size:n}=s;He(n),m(!this.currentSegment),this.currentSegment=e;let a=this.reader.requestSlice(i.filePos,n);a instanceof Promise&&(a=await a),a&&this.readContiguousElements(a),this.currentSegment=null,r.id===S.Tags?e.tagsSeen=!0:r.id===S.Attachments&&(e.attachmentsSeen=!0)}}readContiguousElements(e,r){for(;e.remainingLength>=pe;){const i=e.filePos;if(!this.traverseElement(e,r))return i}return e.filePos}traverseElement(e,r){const i=ze(e);if(!i||r&&r.includes(i.id))return!1;const{id:s,size:n}=i,a=e.filePos;switch(He(n),s){case S.DocType:this.isWebM=gt(e,n)==="webm";break;case S.Seek:{if(!this.currentSegment)break;const o={id:-1,segmentPosition:-1};this.currentSegment.seekEntries.push(o),this.readContiguousElements(e.slice(a,n)),(o.id===-1||o.segmentPosition===-1)&&this.currentSegment.seekEntries.pop()}break;case S.SeekID:{const o=this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length-1];if(!o)break;o.id=N(e,n)}break;case S.SeekPosition:{const o=this.currentSegment?.seekEntries[this.currentSegment.seekEntries.length-1];if(!o)break;o.segmentPosition=N(e,n)}break;case S.TimestampScale:{if(!this.currentSegment)break;this.currentSegment.timestampScale=N(e,n),this.currentSegment.timestampFactor=1e9/this.currentSegment.timestampScale}break;case S.Duration:{if(!this.currentSegment)break;this.currentSegment.duration=Rr(e,n)}break;case S.TrackEntry:{if(!this.currentSegment||(this.currentTrack={id:-1,segment:this.currentSegment,demuxer:this,clusterPositionCache:[],cuePoints:[],disposition:{...Ye},inputTrack:null,codecId:null,codecPrivate:null,defaultDuration:null,defaultDurationNs:null,name:null,languageCode:he,decodingInstructions:[],info:null},this.readContiguousElements(e.slice(a,n)),!this.currentTrack))break;if(this.currentTrack.decodingInstructions.some(o=>o.data?.type!=="decompress"||o.scope!==dr.Block||o.data.algorithm!==Vt.HeaderStripping)&&(console.warn(`Track #${this.currentTrack.id} has an unsupported content encoding; dropping.`),this.currentTrack=null),this.currentTrack&&this.currentTrack.id!==-1&&this.currentTrack.codecId&&this.currentTrack.info){const o=this.currentTrack.codecId.indexOf("/"),c=o===-1?this.currentTrack.codecId:this.currentTrack.codecId.slice(0,o);if(this.currentTrack.info.type==="video"&&this.currentTrack.info.width!==-1&&this.currentTrack.info.height!==-1){this.currentTrack.codecId===Pe.avc?(this.currentTrack.info.codec="avc",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId===Pe.hevc?(this.currentTrack.info.codec="hevc",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):c===Pe.vp8?this.currentTrack.info.codec="vp8":c===Pe.vp9?this.currentTrack.info.codec="vp9":c===Pe.av1&&(this.currentTrack.info.codec="av1");const l=this.currentTrack,u=new Bt(this.input,new Aa(l));this.currentTrack.inputTrack=u,this.currentSegment.tracks.push(this.currentTrack)}else if(this.currentTrack.info.type==="audio"&&this.currentTrack.info.numberOfChannels!==-1&&this.currentTrack.info.sampleRate!==-1){c===Pe.aac?(this.currentTrack.info.codec="aac",this.currentTrack.info.aacCodecInfo={isMpeg2:this.currentTrack.codecId.includes("MPEG2"),objectType:null},this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId===Pe.mp3?this.currentTrack.info.codec="mp3":c===Pe.opus?(this.currentTrack.info.codec="opus",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate,this.currentTrack.info.sampleRate=wr):c===Pe.vorbis?(this.currentTrack.info.codec="vorbis",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):c===Pe.flac?(this.currentTrack.info.codec="flac",this.currentTrack.info.codecDescription=this.currentTrack.codecPrivate):this.currentTrack.codecId==="A_PCM/INT/LIT"?this.currentTrack.info.bitDepth===8?this.currentTrack.info.codec="pcm-u8":this.currentTrack.info.bitDepth===16?this.currentTrack.info.codec="pcm-s16":this.currentTrack.info.bitDepth===24?this.currentTrack.info.codec="pcm-s24":this.currentTrack.info.bitDepth===32&&(this.currentTrack.info.codec="pcm-s32"):this.currentTrack.codecId==="A_PCM/INT/BIG"?this.currentTrack.info.bitDepth===8?this.currentTrack.info.codec="pcm-u8":this.currentTrack.info.bitDepth===16?this.currentTrack.info.codec="pcm-s16be":this.currentTrack.info.bitDepth===24?this.currentTrack.info.codec="pcm-s24be":this.currentTrack.info.bitDepth===32&&(this.currentTrack.info.codec="pcm-s32be"):this.currentTrack.codecId==="A_PCM/FLOAT/IEEE"&&(this.currentTrack.info.bitDepth===32?this.currentTrack.info.codec="pcm-f32":this.currentTrack.info.bitDepth===64&&(this.currentTrack.info.codec="pcm-f64"));const l=this.currentTrack,u=new Fe(this.input,new Fa(l));this.currentTrack.inputTrack=u,this.currentSegment.tracks.push(this.currentTrack)}}this.currentTrack=null}break;case S.TrackNumber:{if(!this.currentTrack)break;this.currentTrack.id=N(e,n)}break;case S.TrackType:{if(!this.currentTrack)break;const o=N(e,n);o===1?this.currentTrack.info={type:"video",width:-1,height:-1,rotation:0,codec:null,codecDescription:null,colorSpace:null,alphaMode:!1}:o===2&&(this.currentTrack.info={type:"audio",numberOfChannels:-1,sampleRate:-1,bitDepth:-1,codec:null,codecDescription:null,aacCodecInfo:null})}break;case S.FlagEnabled:{if(!this.currentTrack)break;N(e,n)||(this.currentTrack=null)}break;case S.FlagDefault:{if(!this.currentTrack)break;this.currentTrack.disposition.default=!!N(e,n)}break;case S.FlagForced:{if(!this.currentTrack)break;this.currentTrack.disposition.forced=!!N(e,n)}break;case S.FlagOriginal:{if(!this.currentTrack)break;this.currentTrack.disposition.original=!!N(e,n)}break;case S.FlagHearingImpaired:{if(!this.currentTrack)break;this.currentTrack.disposition.hearingImpaired=!!N(e,n)}break;case S.FlagVisualImpaired:{if(!this.currentTrack)break;this.currentTrack.disposition.visuallyImpaired=!!N(e,n)}break;case S.FlagCommentary:{if(!this.currentTrack)break;this.currentTrack.disposition.commentary=!!N(e,n)}break;case S.CodecID:{if(!this.currentTrack)break;this.currentTrack.codecId=gt(e,n)}break;case S.CodecPrivate:{if(!this.currentTrack)break;this.currentTrack.codecPrivate=O(e,n)}break;case S.DefaultDuration:{if(!this.currentTrack)break;this.currentTrack.defaultDurationNs=N(e,n)}break;case S.Name:{if(!this.currentTrack)break;this.currentTrack.name=Dt(e,n)}break;case S.Language:{if(!this.currentTrack||this.currentTrack.languageCode!==he)break;this.currentTrack.languageCode=gt(e,n),qt(this.currentTrack.languageCode)||(this.currentTrack.languageCode=he)}break;case S.LanguageBCP47:{if(!this.currentTrack)break;const c=gt(e,n).split("-")[0];c?this.currentTrack.languageCode=c:this.currentTrack.languageCode=he}break;case S.Video:{if(this.currentTrack?.info?.type!=="video")break;this.readContiguousElements(e.slice(a,n))}break;case S.PixelWidth:{if(this.currentTrack?.info?.type!=="video")break;this.currentTrack.info.width=N(e,n)}break;case S.PixelHeight:{if(this.currentTrack?.info?.type!=="video")break;this.currentTrack.info.height=N(e,n)}break;case S.AlphaMode:{if(this.currentTrack?.info?.type!=="video")break;this.currentTrack.info.alphaMode=N(e,n)===1}break;case S.Colour:{if(this.currentTrack?.info?.type!=="video")break;this.currentTrack.info.colorSpace={},this.readContiguousElements(e.slice(a,n))}break;case S.MatrixCoefficients:{if(this.currentTrack?.info?.type!=="video"||!this.currentTrack.info.colorSpace)break;const o=N(e,n),c=cr[o]??null;this.currentTrack.info.colorSpace.matrix=c}break;case S.Range:{if(this.currentTrack?.info?.type!=="video"||!this.currentTrack.info.colorSpace)break;this.currentTrack.info.colorSpace.fullRange=N(e,n)===2}break;case S.TransferCharacteristics:{if(this.currentTrack?.info?.type!=="video"||!this.currentTrack.info.colorSpace)break;const o=N(e,n),c=or[o]??null;this.currentTrack.info.colorSpace.transfer=c}break;case S.Primaries:{if(this.currentTrack?.info?.type!=="video"||!this.currentTrack.info.colorSpace)break;const o=N(e,n),c=ar[o]??null;this.currentTrack.info.colorSpace.primaries=c}break;case S.Projection:{if(this.currentTrack?.info?.type!=="video")break;this.readContiguousElements(e.slice(a,n))}break;case S.ProjectionPoseRoll:{if(this.currentTrack?.info?.type!=="video")break;const c=-Rr(e,n);try{this.currentTrack.info.rotation=si(c)}catch{}}break;case S.Audio:{if(this.currentTrack?.info?.type!=="audio")break;this.readContiguousElements(e.slice(a,n))}break;case S.SamplingFrequency:{if(this.currentTrack?.info?.type!=="audio")break;this.currentTrack.info.sampleRate=Rr(e,n)}break;case S.Channels:{if(this.currentTrack?.info?.type!=="audio")break;this.currentTrack.info.numberOfChannels=N(e,n)}break;case S.BitDepth:{if(this.currentTrack?.info?.type!=="audio")break;this.currentTrack.info.bitDepth=N(e,n)}break;case S.CuePoint:{if(!this.currentSegment)break;this.readContiguousElements(e.slice(a,n)),this.currentCueTime=null}break;case S.CueTime:this.currentCueTime=N(e,n);break;case S.CueTrackPositions:{if(this.currentCueTime===null)break;m(this.currentSegment);const o={time:this.currentCueTime,trackId:-1,clusterPosition:-1};this.currentSegment.cuePoints.push(o),this.readContiguousElements(e.slice(a,n)),(o.trackId===-1||o.clusterPosition===-1)&&this.currentSegment.cuePoints.pop()}break;case S.CueTrack:{const o=this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length-1];if(!o)break;o.trackId=N(e,n)}break;case S.CueClusterPosition:{const o=this.currentSegment?.cuePoints[this.currentSegment.cuePoints.length-1];if(!o)break;m(this.currentSegment),o.clusterPosition=this.currentSegment.dataStartPos+N(e,n)}break;case S.Timestamp:{if(!this.currentCluster)break;this.currentCluster.timestamp=N(e,n)}break;case S.SimpleBlock:{if(!this.currentCluster)break;const o=Ot(e);if(o===null)break;const c=this.getTrackDataInCluster(this.currentCluster,o);if(!c)break;const l=ei(e),u=F(e),d=u>>1&3;let h=!!(u&128);c.track.info?.type==="audio"&&c.track.info.codec&&(h=!0);const f=O(e,n-(e.filePos-a)),p=c.track.decodingInstructions.length>0;c.blocks.push({timestamp:l,duration:0,isKeyFrame:h,data:f,lacing:d,decoded:!p,mainAdditional:null})}break;case S.BlockGroup:{if(!this.currentCluster)break;this.readContiguousElements(e.slice(a,n)),this.currentBlock=null}break;case S.Block:{if(!this.currentCluster)break;const o=Ot(e);if(o===null)break;const c=this.getTrackDataInCluster(this.currentCluster,o);if(!c)break;const l=ei(e),d=F(e)>>1&3,h=O(e,n-(e.filePos-a)),f=c.track.decodingInstructions.length>0;this.currentBlock={timestamp:l,duration:0,isKeyFrame:!0,data:h,lacing:d,decoded:!f,mainAdditional:null},c.blocks.push(this.currentBlock)}break;case S.BlockAdditions:this.readContiguousElements(e.slice(a,n));break;case S.BlockMore:{if(!this.currentBlock)break;this.currentBlockAdditional={addId:1,data:null},this.readContiguousElements(e.slice(a,n)),this.currentBlockAdditional.data&&this.currentBlockAdditional.addId===1&&(this.currentBlock.mainAdditional=this.currentBlockAdditional.data),this.currentBlockAdditional=null}break;case S.BlockAdditional:{if(!this.currentBlockAdditional)break;this.currentBlockAdditional.data=O(e,n)}break;case S.BlockAddID:{if(!this.currentBlockAdditional)break;this.currentBlockAdditional.addId=N(e,n)}break;case S.BlockDuration:{if(!this.currentBlock)break;this.currentBlock.duration=N(e,n)}break;case S.ReferenceBlock:{if(!this.currentBlock)break;this.currentBlock.isKeyFrame=!1}break;case S.Tag:this.currentTagTargetIsMovie=!0,this.readContiguousElements(e.slice(a,n));break;case S.Targets:this.readContiguousElements(e.slice(a,n));break;case S.TargetTypeValue:N(e,n)!==50&&(this.currentTagTargetIsMovie=!1);break;case S.TagTrackUID:case S.TagEditionUID:case S.TagChapterUID:case S.TagAttachmentUID:this.currentTagTargetIsMovie=!1;break;case S.SimpleTag:{if(!this.currentTagTargetIsMovie)break;this.currentSimpleTagName=null,this.readContiguousElements(e.slice(a,n))}break;case S.TagName:this.currentSimpleTagName=Dt(e,n);break;case S.TagString:{if(!this.currentSimpleTagName)break;const o=Dt(e,n);this.processTagValue(this.currentSimpleTagName,o)}break;case S.TagBinary:{if(!this.currentSimpleTagName)break;const o=O(e,n);this.processTagValue(this.currentSimpleTagName,o)}break;case S.AttachedFile:{if(!this.currentSegment)break;this.currentAttachedFile={fileUid:null,fileName:null,fileMediaType:null,fileData:null,fileDescription:null},this.readContiguousElements(e.slice(a,n));const o=this.currentSegment.metadataTags;if(this.currentAttachedFile.fileUid&&this.currentAttachedFile.fileData&&(o.raw??={},o.raw[this.currentAttachedFile.fileUid.toString()]=new fs(this.currentAttachedFile.fileData,this.currentAttachedFile.fileMediaType??void 0,this.currentAttachedFile.fileName??void 0,this.currentAttachedFile.fileDescription??void 0)),this.currentAttachedFile.fileMediaType?.startsWith("image/")&&this.currentAttachedFile.fileData){const c=this.currentAttachedFile.fileName;let l="unknown";if(c){const u=c.toLowerCase();u.startsWith("cover.")?l="coverFront":u.startsWith("back.")&&(l="coverBack")}o.images??=[],o.images.push({data:this.currentAttachedFile.fileData,mimeType:this.currentAttachedFile.fileMediaType,kind:l,name:this.currentAttachedFile.fileName??void 0,description:this.currentAttachedFile.fileDescription??void 0})}this.currentAttachedFile=null}break;case S.FileUID:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileUid=Ea(e,n)}break;case S.FileName:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileName=Dt(e,n)}break;case S.FileMediaType:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileMediaType=gt(e,n)}break;case S.FileData:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileData=O(e,n)}break;case S.FileDescription:{if(!this.currentAttachedFile)break;this.currentAttachedFile.fileDescription=Dt(e,n)}break;case S.ContentEncodings:{if(!this.currentTrack)break;this.readContiguousElements(e.slice(a,n)),this.currentTrack.decodingInstructions.sort((o,c)=>c.order-o.order)}break;case S.ContentEncoding:this.currentDecodingInstruction={order:0,scope:dr.Block,data:null},this.readContiguousElements(e.slice(a,n)),this.currentDecodingInstruction.data&&this.currentTrack.decodingInstructions.push(this.currentDecodingInstruction),this.currentDecodingInstruction=null;break;case S.ContentEncodingOrder:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.order=N(e,n)}break;case S.ContentEncodingScope:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.scope=N(e,n)}break;case S.ContentCompression:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.data={type:"decompress",algorithm:Vt.Zlib,settings:null},this.readContiguousElements(e.slice(a,n))}break;case S.ContentCompAlgo:{if(this.currentDecodingInstruction?.data?.type!=="decompress")break;this.currentDecodingInstruction.data.algorithm=N(e,n)}break;case S.ContentCompSettings:{if(this.currentDecodingInstruction?.data?.type!=="decompress")break;this.currentDecodingInstruction.data.settings=O(e,n)}break;case S.ContentEncryption:{if(!this.currentDecodingInstruction)break;this.currentDecodingInstruction.data={type:"decrypt"}}break}return e.filePos=a+n,!0}decodeBlockData(e,r){m(e.decodingInstructions.length>0);let i=r;for(const s of e.decodingInstructions)switch(m(s.data),s.data.type){case"decompress":switch(s.data.algorithm){case Vt.HeaderStripping:if(s.data.settings&&s.data.settings.length>0){const n=s.data.settings,a=new Uint8Array(n.length+i.length);a.set(n,0),a.set(i,n.length),i=a}break}break}return i}processTagValue(e,r){if(!this.currentSegment?.metadataTags)return;const i=this.currentSegment.metadataTags;if(i.raw??={},i.raw[e]??=r,typeof r=="string")switch(e.toLowerCase()){case"title":i.title??=r;break;case"description":i.description??=r;break;case"artist":i.artist??=r;break;case"album":i.album??=r;break;case"album_artist":i.albumArtist??=r;break;case"genre":i.genre??=r;break;case"comment":i.comment??=r;break;case"lyrics":i.lyrics??=r;break;case"date":{const s=new Date(r);Number.isNaN(s.getTime())||(i.date??=s)}break;case"track_number":case"part_number":{const s=r.split("/"),n=Number.parseInt(s[0],10),a=s[1]&&Number.parseInt(s[1],10);Number.isInteger(n)&&n>0&&(i.trackNumber??=n),a&&Number.isInteger(a)&&a>0&&(i.tracksTotal??=a)}break;case"disc_number":case"disc":{const s=r.split("/"),n=Number.parseInt(s[0],10),a=s[1]&&Number.parseInt(s[1],10);Number.isInteger(n)&&n>0&&(i.discNumber??=n),a&&Number.isInteger(a)&&a>0&&(i.discsTotal??=a)}break}}}class Ns{constructor(e){this.internalTrack=e,this.packetToClusterLocation=new WeakMap}getId(){return this.internalTrack.id}getCodec(){throw new Error("Not implemented on base class.")}getInternalCodecId(){return this.internalTrack.codecId}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getName(){return this.internalTrack.name}getLanguageCode(){return this.internalTrack.languageCode}async getFirstTimestamp(){return(await this.getFirstPacket({metadataOnly:!0}))?.timestamp??0}getTimeResolution(){return this.internalTrack.segment.timestampFactor}getDisposition(){return this.internalTrack.disposition}async getFirstPacket(e){return this.performClusterLookup(null,r=>r.trackData.get(this.internalTrack.id)?{blockIndex:0,correctBlockFound:!0}:{blockIndex:-1,correctBlockFound:!1},-1/0,1/0,e)}intoTimescale(e){return Ht(e*this.internalTrack.segment.timestampFactor)}async getPacket(e,r){const i=this.intoTimescale(e);return this.performClusterLookup(null,s=>{const n=s.trackData.get(this.internalTrack.id);if(!n)return{blockIndex:-1,correctBlockFound:!1};const a=L(n.presentationTimestamps,i,l=>l.timestamp),o=a!==-1?n.presentationTimestamps[a].blockIndex:-1,c=a!==-1&&i<n.endTimestamp;return{blockIndex:o,correctBlockFound:c}},i,i,r)}async getNextPacket(e,r){const i=this.packetToClusterLocation.get(e);if(i===void 0)throw new Error("Packet was not created from this track.");return this.performClusterLookup(i.cluster,s=>{if(s===i.cluster){const n=s.trackData.get(this.internalTrack.id);if(i.blockIndex+1<n.blocks.length)return{blockIndex:i.blockIndex+1,correctBlockFound:!0}}else if(s.trackData.get(this.internalTrack.id))return{blockIndex:0,correctBlockFound:!0};return{blockIndex:-1,correctBlockFound:!1}},-1/0,1/0,r)}async getKeyPacket(e,r){const i=this.intoTimescale(e);return this.performClusterLookup(null,s=>{const n=s.trackData.get(this.internalTrack.id);if(!n)return{blockIndex:-1,correctBlockFound:!1};const a=ai(n.presentationTimestamps,l=>n.blocks[l.blockIndex].isKeyFrame&&l.timestamp<=i),o=a!==-1?n.presentationTimestamps[a].blockIndex:-1,c=a!==-1&&i<n.endTimestamp;return{blockIndex:o,correctBlockFound:c}},i,i,r)}async getNextKeyPacket(e,r){const i=this.packetToClusterLocation.get(e);if(i===void 0)throw new Error("Packet was not created from this track.");return this.performClusterLookup(i.cluster,s=>{if(s===i.cluster){const a=s.trackData.get(this.internalTrack.id).blocks.findIndex((o,c)=>o.isKeyFrame&&c>i.blockIndex);if(a!==-1)return{blockIndex:a,correctBlockFound:!0}}else{const n=s.trackData.get(this.internalTrack.id);if(n&&n.firstKeyFrameTimestamp!==null){const a=n.blocks.findIndex(o=>o.isKeyFrame);return m(a!==-1),{blockIndex:a,correctBlockFound:!0}}}return{blockIndex:-1,correctBlockFound:!1}},-1/0,1/0,r)}async fetchPacketInCluster(e,r,i){if(r===-1)return null;const n=e.trackData.get(this.internalTrack.id).blocks[r];m(n),n.decoded||(n.data=this.internalTrack.demuxer.decodeBlockData(this.internalTrack,n.data),n.decoded=!0);const a=i.metadataOnly?me:n.data,o=n.timestamp/this.internalTrack.segment.timestampFactor,c=n.duration/this.internalTrack.segment.timestampFactor,l={};n.mainAdditional&&this.internalTrack.info?.type==="video"&&this.internalTrack.info.alphaMode&&(l.alpha=i.metadataOnly?me:n.mainAdditional,l.alphaByteLength=n.mainAdditional.byteLength);const u=new j(a,n.isKeyFrame?"key":"delta",o,c,e.dataStartPos+r,n.data.byteLength,l);return this.packetToClusterLocation.set(u,{cluster:e,blockIndex:r}),u}async performClusterLookup(e,r,i,s,n){const{demuxer:a,segment:o}=this.internalTrack;let c=null,l=null,u=-1;if(e){const{blockIndex:w,correctBlockFound:b}=r(e);if(b)return this.fetchPacketInCluster(e,w,n);w!==-1&&(l=e,u=w)}const d=L(this.internalTrack.cuePoints,i,w=>w.time),h=d!==-1?this.internalTrack.cuePoints[d]:null,f=L(this.internalTrack.clusterPositionCache,i,w=>w.startTimestamp),p=f!==-1?this.internalTrack.clusterPositionCache[f]:null,g=Math.max(h?.clusterPosition??0,p?.elementStartPos??0)||null;let k;for(e?g===null||e.elementStartPos>=g?(k=e.elementEndPos,c=e):k=g:k=g??o.clusterSeekStartPos;o.elementEndPos===null||k<=o.elementEndPos-pe;){if(c){const C=c.trackData.get(this.internalTrack.id);if(C&&C.startTimestamp>s)break}let w=a.reader.requestSliceRange(k,pe,Ne);if(w instanceof Promise&&(w=await w),!w)break;const b=k,y=ze(w);if(!y||!Kt.includes(y.id)&&y.id!==S.Void){const C=await Ms(a.reader,b,Kt,Math.min(o.elementEndPos??1/0,b+Os));if(C){k=C;continue}else break}const T=y.id;let x=y.size;const P=w.filePos;if(T===S.Cluster){c=await a.readCluster(b,o),x=c.elementEndPos-P;const{blockIndex:C,correctBlockFound:R}=r(c);if(R)return this.fetchPacketInCluster(c,C,n);C!==-1&&(l=c,u=C)}x===void 0&&(m(T!==S.Cluster),x=(await Yr(a.reader,P,sr,o.elementEndPos)).pos-P);const _=P+x;if(o.elementEndPos===null){let C=a.reader.requestSliceRange(_,pe,Ne);if(C instanceof Promise&&(C=await C),!C)break;if(wi(C)===S.Segment){o.elementEndPos=_;break}}k=_}if(h&&(!l||l.elementStartPos<h.clusterPosition)){const w=this.internalTrack.cuePoints[d-1];m(!w||w.time<h.time);const b=w?.time??-1/0;return this.performClusterLookup(null,r,b,s,n)}return l?this.fetchPacketInCluster(l,u,n):null}}class Aa extends Ns{constructor(e){super(e),this.decoderConfigPromise=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getCodedWidth(){return this.internalTrack.info.width}getCodedHeight(){return this.internalTrack.info.height}getRotation(){return this.internalTrack.info.rotation}async getColorSpace(){return{primaries:this.internalTrack.info.colorSpace?.primaries,transfer:this.internalTrack.info.colorSpace?.transfer,matrix:this.internalTrack.info.colorSpace?.matrix,fullRange:this.internalTrack.info.colorSpace?.fullRange}}async canBeTransparent(){return this.internalTrack.info.alphaMode}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfigPromise??=(async()=>{let e=null;return(this.internalTrack.info.codec==="vp9"||this.internalTrack.info.codec==="av1"||this.internalTrack.info.codec==="avc"&&!this.internalTrack.info.codecDescription||this.internalTrack.info.codec==="hevc"&&!this.internalTrack.info.codecDescription)&&(e=await this.getFirstPacket({})),{codec:ci({width:this.internalTrack.info.width,height:this.internalTrack.info.height,codec:this.internalTrack.info.codec,codecDescription:this.internalTrack.info.codecDescription,colorSpace:this.internalTrack.info.colorSpace,avcType:1,avcCodecInfo:this.internalTrack.info.codec==="avc"&&e?di(e.data):null,hevcCodecInfo:this.internalTrack.info.codec==="hevc"&&e?fi(e.data):null,vp9CodecInfo:this.internalTrack.info.codec==="vp9"&&e?Ss(e.data):null,av1CodecInfo:this.internalTrack.info.codec==="av1"&&e?xs(e.data):null}),codedWidth:this.internalTrack.info.width,codedHeight:this.internalTrack.info.height,description:this.internalTrack.info.codecDescription??void 0,colorSpace:this.internalTrack.info.colorSpace??void 0}})():null}}class Fa extends Ns{constructor(e){super(e),this.decoderConfig=null,this.internalTrack=e}getCodec(){return this.internalTrack.info.codec}getNumberOfChannels(){return this.internalTrack.info.numberOfChannels}getSampleRate(){return this.internalTrack.info.sampleRate}async getDecoderConfig(){return this.internalTrack.info.codec?this.decoderConfig??={codec:li({codec:this.internalTrack.info.codec,codecDescription:this.internalTrack.info.codecDescription,aacCodecInfo:this.internalTrack.info.aacCodecInfo}),numberOfChannels:this.internalTrack.info.numberOfChannels,sampleRate:this.internalTrack.info.sampleRate,description:this.internalTrack.info.codecDescription??void 0}:null}}const Lt=4,Ba=[44100,48e3,32e3],Ra=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,32,40,48,56,64,80,96,112,128,160,192,224,256,320,-1,-1,32,48,56,64,80,96,112,128,160,192,224,256,320,384,-1,-1,32,64,96,128,160,192,224,256,288,320,352,384,416,448,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1,-1,8,16,24,32,40,48,56,64,80,96,112,128,144,160,-1,-1,32,48,56,64,80,96,112,128,144,160,176,192,224,256,-1],Da=1483304551,za=1231971951,Ma=(t,e,r,i,s)=>e===0?0:e===1?Math.floor(144*r/(i<<t))+s:e===2?Math.floor(144*r/i)+s:(Math.floor(12*r/i)+s)*4,Oa=(t,e)=>t===3?e===3?21:36:e===3?13:21,yi=(t,e)=>{const r=t>>>24,i=t>>>16&255,s=t>>>8&255,n=t&255;if(r!==255&&i!==255&&s!==255&&n!==255)return{header:null,bytesAdvanced:4};if(r!==255)return{header:null,bytesAdvanced:1};if((i&224)!==224)return{header:null,bytesAdvanced:1};let a=0,o=0;i&16?a=i&8?0:1:(a=1,o=1);const c=i>>3&3,l=i>>1&3,u=s>>4&15,d=(s>>2&3)%3,h=s>>1&1,f=n>>6&3,p=n>>4&3,g=n>>3&1,k=n>>2&1,w=n&3,b=Ra[a*16*4+l*16+u];if(b===-1)return{header:null,bytesAdvanced:1};const y=b*1e3,T=Ba[d]>>a+o,x=Ma(a,l,y,T,h);if(e!==null&&e<x)return{header:null,bytesAdvanced:1};let P;return c===3?P=l===3?384:1152:l===3?P=384:l===2?P=1152:P=576,{header:{totalSize:x,mpegVersionId:c,layer:l,bitrate:y,frequencyIndex:d,sampleRate:T,channel:f,modeExtension:p,copyright:g,original:k,emphasis:w,audioSamplesInFrame:P},bytesAdvanced:1}},Zr=t=>{let e=2130706432,r=0;for(;e!==0;)r>>=1,r|=t&e,e>>=8;return r};var Tt;(function(t){t[t.Unsynchronisation=128]="Unsynchronisation",t[t.ExtendedHeader=64]="ExtendedHeader",t[t.ExperimentalIndicator=32]="ExperimentalIndicator",t[t.Footer=16]="Footer"})(Tt||(Tt={}));var St;(function(t){t[t.ISO_8859_1=0]="ISO_8859_1",t[t.UTF_16_WITH_BOM=1]="UTF_16_WITH_BOM",t[t.UTF_16_BE_NO_BOM=2]="UTF_16_BE_NO_BOM",t[t.UTF_8=3]="UTF_8"})(St||(St={}));const nr=128,hr=10,Pt=["Blues","Classic rock","Country","Dance","Disco","Funk","Grunge","Hip-hop","Jazz","Metal","New age","Oldies","Other","Pop","Rhythm and blues","Rap","Reggae","Rock","Techno","Industrial","Alternative","Ska","Death metal","Pranks","Soundtrack","Euro-techno","Ambient","Trip-hop","Vocal","Jazz & funk","Fusion","Trance","Classical","Instrumental","Acid","House","Game","Sound clip","Gospel","Noise","Alternative rock","Bass","Soul","Punk","Space","Meditative","Instrumental pop","Instrumental rock","Ethnic","Gothic","Darkwave","Techno-industrial","Electronic","Pop-folk","Eurodance","Dream","Southern rock","Comedy","Cult","Gangsta","Top 40","Christian rap","Pop/funk","Jungle music","Native US","Cabaret","New wave","Psychedelic","Rave","Showtunes","Trailer","Lo-fi","Tribal","Acid punk","Acid jazz","Polka","Retro","Musical","Rock 'n' roll","Hard rock","Folk","Folk rock","National folk","Swing","Fast fusion","Bebop","Latin","Revival","Celtic","Bluegrass","Avantgarde","Gothic rock","Progressive rock","Psychedelic rock","Symphonic rock","Slow rock","Big band","Chorus","Easy listening","Acoustic","Humour","Speech","Chanson","Opera","Chamber music","Sonata","Symphony","Booty bass","Primus","Porn groove","Satire","Slow jam","Club","Tango","Samba","Folklore","Ballad","Power ballad","Rhythmic Soul","Freestyle","Duet","Punk rock","Drum solo","A cappella","Euro-house","Dance hall","Goa music","Drum & bass","Club-house","Hardcore techno","Terror","Indie","Britpop","Negerpunk","Polsk punk","Beat","Christian gangsta rap","Heavy metal","Black metal","Crossover","Contemporary Christian","Christian rock","Merengue","Salsa","Thrash metal","Anime","Jpop","Synthpop","Christmas","Art rock","Baroque","Bhangra","Big beat","Breakbeat","Chillout","Downtempo","Dub","EBM","Eclectic","Electro","Electroclash","Emo","Experimental","Garage","Global","IDM","Illbient","Industro-Goth","Jam Band","Krautrock","Leftfield","Lounge","Math rock","New romantic","Nu-breakz","Post-punk","Post-rock","Psytrance","Shoegaze","Space rock","Trop rock","World music","Neoclassical","Audiobook","Audio theatre","Neue Deutsche Welle","Podcast","Indie rock","G-Funk","Dubstep","Garage rock","Psybient"],Na=(t,e)=>{const r=t.filePos;e.raw??={},e.raw.TAG??=O(t,nr-3),t.filePos=r;const i=ft(t,30);i&&(e.title??=i);const s=ft(t,30);s&&(e.artist??=s);const n=ft(t,30);n&&(e.album??=n);const a=ft(t,4),o=Number.parseInt(a,10);Number.isInteger(o)&&o>0&&(e.date??=new Date(o,0,1));const c=O(t,30);let l;if(c[28]===0&&c[29]!==0){const d=c[29];d>0&&(e.trackNumber??=d),t.skip(-30),l=ft(t,28),t.skip(2)}else t.skip(-30),l=ft(t,30);l&&(e.comment??=l);const u=F(t);u<Pt.length&&(e.genre??=Pt[u])},ft=(t,e)=>{const r=O(t,e),i=pt(r.indexOf(0),r.length),s=r.subarray(0,i);let n="";for(let a=0;a<s.length;a++)n+=String.fromCharCode(s[a]);return n.trimEnd()},fr=t=>{const e=t.filePos,r=re(t,3),i=F(t),s=F(t),n=F(t),a=I(t);if(r!=="ID3"||i===255||s===255||(a&2155905152)!==0)return t.filePos=e,null;const o=Zr(a);return{majorVersion:i,revision:s,flags:n,size:o}},Us=(t,e,r)=>{if(![2,3,4].includes(e.majorVersion)){console.warn(`Unsupported ID3v2 major version: ${e.majorVersion}`);return}const i=O(t,e.size),s=new Ua(e,i);if(e.flags&Tt.Footer&&s.removeFooter(),e.flags&Tt.Unsynchronisation&&e.majorVersion===3&&s.ununsynchronizeAll(),e.flags&Tt.ExtendedHeader){const n=s.readU32();e.majorVersion===3?s.pos+=n:s.pos+=n-4}for(;s.pos<=s.bytes.length-s.frameHeaderSize();){const n=s.readId3V2Frame();if(!n)break;const a=s.pos,o=s.pos+n.size;let c=!1,l=!1,u=!1;if(e.majorVersion===3?(c=!!(n.flags&64),l=!!(n.flags&128)):e.majorVersion===4&&(c=!!(n.flags&4),l=!!(n.flags&8),u=!!(n.flags&2)||!!(e.flags&Tt.Unsynchronisation)),c){console.warn(`Skipping encrypted ID3v2 frame ${n.id}`),s.pos=o;continue}if(l){console.warn(`Skipping compressed ID3v2 frame ${n.id}`),s.pos=o;continue}switch(u&&s.ununsynchronizeRegion(s.pos,o),r.raw??={},n.id[0]==="T"?r.raw[n.id]??=s.readId3V2EncodingAndText(o):r.raw[n.id]??=s.readBytes(n.size),s.pos=a,n.id){case"TIT2":case"TT2":r.title??=s.readId3V2EncodingAndText(o);break;case"TIT3":case"TT3":r.description??=s.readId3V2EncodingAndText(o);break;case"TPE1":case"TP1":r.artist??=s.readId3V2EncodingAndText(o);break;case"TALB":case"TAL":r.album??=s.readId3V2EncodingAndText(o);break;case"TPE2":case"TP2":r.albumArtist??=s.readId3V2EncodingAndText(o);break;case"TRCK":case"TRK":{const h=s.readId3V2EncodingAndText(o).split("/"),f=Number.parseInt(h[0],10),p=h[1]&&Number.parseInt(h[1],10);Number.isInteger(f)&&f>0&&(r.trackNumber??=f),p&&Number.isInteger(p)&&p>0&&(r.tracksTotal??=p)}break;case"TPOS":case"TPA":{const h=s.readId3V2EncodingAndText(o).split("/"),f=Number.parseInt(h[0],10),p=h[1]&&Number.parseInt(h[1],10);Number.isInteger(f)&&f>0&&(r.discNumber??=f),p&&Number.isInteger(p)&&p>0&&(r.discsTotal??=p)}break;case"TCON":case"TCO":{const d=s.readId3V2EncodingAndText(o);let h=/^\((\d+)\)/.exec(d);if(h){const f=Number.parseInt(h[1]);if(Pt[f]!==void 0){r.genre??=Pt[f];break}}if(h=/^\d+$/.exec(d),h){const f=Number.parseInt(h[0]);if(Pt[f]!==void 0){r.genre??=Pt[f];break}}r.genre??=d}break;case"TDRC":case"TDAT":{const d=s.readId3V2EncodingAndText(o),h=new Date(d);Number.isNaN(h.getTime())||(r.date??=h)}break;case"TYER":case"TYE":{const d=s.readId3V2EncodingAndText(o),h=Number.parseInt(d,10);Number.isInteger(h)&&(r.date??=new Date(h,0,1))}break;case"USLT":case"ULT":{const d=s.readU8();s.pos+=3,s.readId3V2Text(d,o),r.lyrics??=s.readId3V2Text(d,o)}break;case"COMM":case"COM":{const d=s.readU8();s.pos+=3,s.readId3V2Text(d,o),r.comment??=s.readId3V2Text(d,o)}break;case"APIC":case"PIC":{const d=s.readId3V2TextEncoding();let h;if(e.majorVersion===2){const k=s.readAscii(3);h=k==="PNG"?"image/png":k==="JPG"?"image/jpeg":"image/*"}else h=s.readId3V2Text(d,o);const f=s.readU8(),p=s.readId3V2Text(d,o).trimEnd(),g=o-s.pos;if(g>=0){const k=s.readBytes(g);r.images||(r.images=[]),r.images.push({data:k,mimeType:h,kind:f===3?"coverFront":f===4?"coverBack":"unknown",description:p})}}break;default:s.pos+=n.size;break}s.pos=o}};class Ua{constructor(e,r){this.header=e,this.bytes=r,this.pos=0,this.view=new DataView(r.buffer,r.byteOffset,r.byteLength)}frameHeaderSize(){return this.header.majorVersion===2?6:10}ununsynchronizeAll(){const e=[];for(let r=0;r<this.bytes.length;r++){const i=this.bytes[r];e.push(i),i===255&&r!==this.bytes.length-1&&this.bytes[r]===0&&r++}this.bytes=new Uint8Array(e),this.view=new DataView(this.bytes.buffer)}ununsynchronizeRegion(e,r){const i=[];for(let a=e;a<r;a++){const o=this.bytes[a];i.push(o),o===255&&a!==r-1&&this.bytes[a+1]===0&&a++}const s=this.bytes.subarray(0,e),n=this.bytes.subarray(r);this.bytes=new Uint8Array(s.length+i.length+n.length),this.bytes.set(s,0),this.bytes.set(i,s.length),this.bytes.set(n,s.length+i.length),this.view=new DataView(this.bytes.buffer)}removeFooter(){this.bytes=this.bytes.subarray(0,this.bytes.length-hr),this.view=new DataView(this.bytes.buffer)}readBytes(e){const r=this.bytes.subarray(this.pos,this.pos+e);return this.pos+=e,r}readU8(){const e=this.view.getUint8(this.pos);return this.pos+=1,e}readU16(){const e=this.view.getUint16(this.pos,!1);return this.pos+=2,e}readU24(){const e=this.view.getUint16(this.pos,!1),r=this.view.getUint8(this.pos+1);return this.pos+=3,e*256+r}readU32(){const e=this.view.getUint32(this.pos,!1);return this.pos+=4,e}readAscii(e){let r="";for(let i=0;i<e;i++)r+=String.fromCharCode(this.view.getUint8(this.pos+i));return this.pos+=e,r}readId3V2Frame(){if(this.header.majorVersion===2){const e=this.readAscii(3);if(e==="\0\0\0")return null;const r=this.readU24();return{id:e,size:r,flags:0}}else{const e=this.readAscii(4);if(e==="\0\0\0\0")return null;const r=this.readU32();let i=this.header.majorVersion===4?Zr(r):r;const s=this.readU16(),n=this.pos,a=o=>{const c=this.pos+o;if(c>this.bytes.length)return!1;if(c<=this.bytes.length-this.frameHeaderSize()){this.pos+=o;const l=this.readAscii(4);if(l!=="\0\0\0\0"&&!/[0-9A-Z]{4}/.test(l))return!1}return!0};if(!a(i)){const o=this.header.majorVersion===4?r:Zr(r);a(o)&&(i=o)}return this.pos=n,{id:e,size:i,flags:s}}}readId3V2TextEncoding(){const e=this.readU8();if(e>3)throw new Error(`Unsupported text encoding: ${e}`);return e}readId3V2Text(e,r){const i=this.pos,s=this.readBytes(r-this.pos);switch(e){case St.ISO_8859_1:{let n="";for(let a=0;a<s.length;a++){const o=s[a];if(o===0){this.pos=i+a+1;break}n+=String.fromCharCode(o)}return n}case St.UTF_16_WITH_BOM:if(s[0]===255&&s[1]===254){const n=new TextDecoder("utf-16le"),a=pt(s.findIndex((o,c)=>o===0&&s[c+1]===0&&c%2===0),s.length);return this.pos=i+Math.min(a+2,s.length),n.decode(s.subarray(2,a))}else if(s[0]===254&&s[1]===255){const n=new TextDecoder("utf-16be"),a=pt(s.findIndex((o,c)=>o===0&&s[c+1]===0&&c%2===0),s.length);return this.pos=i+Math.min(a+2,s.length),n.decode(s.subarray(2,a))}else{const n=pt(s.findIndex(a=>a===0),s.length);return this.pos=i+Math.min(n+1,s.length),ke.decode(s.subarray(0,n))}case St.UTF_16_BE_NO_BOM:{const n=new TextDecoder("utf-16be"),a=pt(s.findIndex((o,c)=>o===0&&s[c+1]===0&&c%2===0),s.length);return this.pos=i+Math.min(a+2,s.length),n.decode(s.subarray(0,a))}case St.UTF_8:{const n=pt(s.findIndex(a=>a===0),s.length);return this.pos=i+Math.min(n+1,s.length),ke.decode(s.subarray(0,n))}}}readId3V2EncodingAndText(e){if(this.pos>=e)return"";const r=this.readId3V2TextEncoding();return this.readId3V2Text(r,e)}}const Jr=async(t,e,r)=>{let i=e;for(;r===null||i<r;){let s=t.requestSlice(i,Lt);if(s instanceof Promise&&(s=await s),!s)break;const n=I(s),a=yi(n,t.fileSize!==null?t.fileSize-i:null);if(a.header)return{header:a.header,startPos:i};i+=a.bytesAdvanced}return null};class Va extends Je{constructor(e){super(e),this.metadataPromise=null,this.firstFrameHeader=null,this.loadedSamples=[],this.metadataTags=null,this.tracks=[],this.readingMutex=new ut,this.lastSampleLoaded=!1,this.lastLoadedPos=0,this.nextTimestampInSamples=0,this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{for(;!this.firstFrameHeader&&!this.lastSampleLoaded;)await this.advanceReader();if(!this.firstFrameHeader)throw new Error("No valid MP3 frame found.");this.tracks=[new Fe(this.input,new La(this))]})()}async advanceReader(){if(this.lastLoadedPos===0)for(;;){let o=this.reader.requestSlice(this.lastLoadedPos,hr);if(o instanceof Promise&&(o=await o),!o){this.lastSampleLoaded=!0;return}const c=fr(o);if(!c)break;this.lastLoadedPos=o.filePos+c.size}const e=await Jr(this.reader,this.lastLoadedPos,this.reader.fileSize);if(!e){this.lastSampleLoaded=!0;return}const r=e.header;this.lastLoadedPos=e.startPos+r.totalSize-1;const i=Oa(r.mpegVersionId,r.channel);let s=this.reader.requestSlice(e.startPos+i,4);if(s instanceof Promise&&(s=await s),s){const o=I(s);if(o===Da||o===za)return}this.firstFrameHeader||(this.firstFrameHeader=r),r.sampleRate!==this.firstFrameHeader.sampleRate&&console.warn(`MP3 changed sample rate mid-file: ${this.firstFrameHeader.sampleRate} Hz to ${r.sampleRate} Hz. Might be a bug, so please report this file.`);const n=r.audioSamplesInFrame/this.firstFrameHeader.sampleRate,a={timestamp:this.nextTimestampInSamples/this.firstFrameHeader.sampleRate,duration:n,dataStart:e.startPos,dataSize:r.totalSize};this.loadedSamples.push(a),this.nextTimestampInSamples+=r.audioSamplesInFrame}async getMimeType(){return"audio/mpeg"}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return m(e),e.computeDuration()}async getMetadataTags(){const e=await this.readingMutex.acquire();try{if(await this.readMetadata(),this.metadataTags)return this.metadataTags;this.metadataTags={};let r=0,i=!1;for(;;){let s=this.reader.requestSlice(r,hr);if(s instanceof Promise&&(s=await s),!s)break;const n=fr(s);if(!n)break;i=!0;let a=this.reader.requestSlice(s.filePos,n.size);if(a instanceof Promise&&(a=await a),!a)break;Us(a,n,this.metadataTags),r=s.filePos+n.size}if(!i&&this.reader.fileSize!==null&&this.reader.fileSize>=nr){let s=this.reader.requestSlice(this.reader.fileSize-nr,nr);s instanceof Promise&&(s=await s),m(s),re(s,3)==="TAG"&&Na(s,this.metadataTags)}return this.metadataTags}finally{e()}}}class La{constructor(e){this.demuxer=e}getId(){return 1}async getFirstTimestamp(){return 0}getTimeResolution(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.sampleRate/this.demuxer.firstFrameHeader.audioSamplesInFrame}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getName(){return null}getLanguageCode(){return he}getCodec(){return"mp3"}getInternalCodecId(){return null}getNumberOfChannels(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.channel===3?1:2}getSampleRate(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.sampleRate}getDisposition(){return{...Ye}}async getDecoderConfig(){return m(this.demuxer.firstFrameHeader),{codec:"mp3",numberOfChannels:this.demuxer.firstFrameHeader.channel===3?1:2,sampleRate:this.demuxer.firstFrameHeader.sampleRate}}async getPacketAtIndex(e,r){if(e===-1)return null;const i=this.demuxer.loadedSamples[e];if(!i)return null;let s;if(r.metadataOnly)s=me;else{let n=this.demuxer.reader.requestSlice(i.dataStart,i.dataSize);if(n instanceof Promise&&(n=await n),!n)return null;s=O(n,i.dataSize)}return new j(s,"key",i.timestamp,i.duration,e,i.dataSize)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getNextPacket(e,r){const i=await this.demuxer.readingMutex.acquire();try{const s=Zt(this.demuxer.loadedSamples,e.timestamp,a=>a.timestamp);if(s===-1)throw new Error("Packet was not created from this track.");const n=s+1;for(;n>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(n,r)}finally{i()}}async getPacket(e,r){const i=await this.demuxer.readingMutex.acquire();try{for(;;){const s=L(this.demuxer.loadedSamples,e,n=>n.timestamp);if(s===-1&&this.demuxer.loadedSamples.length>0)return null;if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(s,r);if(s>=0&&s+1<this.demuxer.loadedSamples.length)return this.getPacketAtIndex(s,r);await this.demuxer.advanceReader()}}finally{i()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}const Vs=1399285583,Wa=79764919,Ls=new Uint32Array(256);for(let t=0;t<256;t++){let e=t<<24;for(let r=0;r<8;r++)e=e&2147483648?e<<1^Wa:e<<1;Ls[t]=e>>>0&4294967295}const Ha=t=>{const e=X(t),r=e.getUint32(22,!0);e.setUint32(22,0,!0);let i=0;for(let s=0;s<t.length;s++){const n=t[s];i=(i<<8^Ls[i>>>24^n])>>>0}return e.setUint32(22,r,!0),i},qa=(t,e,r)=>{let i=0,s=null;if(t.length>0)if(e.codec==="vorbis"){m(e.vorbisInfo);const n=e.vorbisInfo.modeBlockflags.length,o=(1<<Sn(n-1))-1<<1,c=(t[0]&o)>>1;if(c>=e.vorbisInfo.modeBlockflags.length)throw new Error("Invalid mode number.");let l=r;const u=e.vorbisInfo.modeBlockflags[c];if(s=e.vorbisInfo.blocksizes[u],u===1){const d=(o|1)+1,h=t[0]&d?1:0;l=e.vorbisInfo.blocksizes[h]}i=l!==null?l+s>>2:0}else e.codec==="opus"&&(i=ia(t).durationInSamples);return{durationInSamples:i,vorbisBlockSize:s}},ja=t=>{let e="audio/ogg";if(t.codecStrings){const r=[...new Set(t.codecStrings)];e+=`; codecs="${r.join(", ")}"`}return e};const st=27,_t=282,$a=_t+65025,Wt=t=>{const e=t.filePos;if(vt(t)!==Vs)return null;t.skip(1);const i=F(t),s=No(t),n=vt(t),a=vt(t),o=vt(t),c=F(t),l=new Uint8Array(c);for(let f=0;f<c;f++)l[f]=F(t);const u=27+c,d=l.reduce((f,p)=>f+p,0),h=u+d;return{headerStartPos:e,totalSize:h,dataStartPos:e+u,dataSize:d,headerType:i,granulePosition:s,serialNumber:n,sequenceNumber:a,checksum:o,lacingValues:l}},Qa=(t,e)=>{for(;t.filePos<e-3;){const r=vt(t),i=r&255,s=r>>>8&255,n=r>>>16&255,a=r>>>24&255,o=79;if(!(i!==o&&s!==o&&n!==o&&a!==o)){if(t.skip(-4),r===Vs)return!0;t.skip(1)}}return!1};class Ka extends Je{constructor(e){super(e),this.metadataPromise=null,this.bitstreams=[],this.tracks=[],this.metadataTags={},this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{let e=0;for(;;){let r=this.reader.requestSliceRange(e,st,_t);if(r instanceof Promise&&(r=await r),!r)break;const i=Wt(r);if(!i||!!!(i.headerType&2))break;this.bitstreams.push({serialNumber:i.serialNumber,bosPage:i,description:null,numberOfChannels:-1,sampleRate:-1,codecInfo:{codec:null,vorbisInfo:null,opusInfo:null},lastMetadataPacket:null}),e=i.headerStartPos+i.totalSize}for(const r of this.bitstreams){const i=await this.readPacket(r.bosPage,0);i&&(i.data.byteLength>=7&&i.data[0]===1&&i.data[1]===118&&i.data[2]===111&&i.data[3]===114&&i.data[4]===98&&i.data[5]===105&&i.data[6]===115?await this.readVorbisMetadata(i,r):i.data.byteLength>=8&&i.data[0]===79&&i.data[1]===112&&i.data[2]===117&&i.data[3]===115&&i.data[4]===72&&i.data[5]===101&&i.data[6]===97&&i.data[7]===100&&await this.readOpusMetadata(i,r),r.codecInfo.codec!==null&&this.tracks.push(new Fe(this.input,new Ga(r,this))))}})()}async readVorbisMetadata(e,r){let i=await this.findNextPacketStart(e);if(!i)return;const s=await this.readPacket(i.startPage,i.startSegmentIndex);if(!s||(i=await this.findNextPacketStart(s),!i))return;const n=await this.readPacket(i.startPage,i.startSegmentIndex);if(!n||s.data[0]!==3||n.data[0]!==5)return;const a=[],o=d=>{for(;a.push(Math.min(255,d)),!(d<255);)d-=255};o(e.data.length),o(s.data.length);const c=new Uint8Array(1+a.length+e.data.length+s.data.length+n.data.length);c[0]=2,c.set(a,1),c.set(e.data,1+a.length),c.set(s.data,1+a.length+e.data.length),c.set(n.data,1+a.length+e.data.length+s.data.length),r.codecInfo.codec="vorbis",r.description=c,r.lastMetadataPacket=n;const l=X(e.data);r.numberOfChannels=l.getUint8(11),r.sampleRate=l.getUint32(12,!0);const u=l.getUint8(28);r.codecInfo.vorbisInfo={blocksizes:[1<<(u&15),1<<(u>>4)],modeBlockflags:sa(n.data).modeBlockflags},jr(s.data.subarray(7),this.metadataTags)}async readOpusMetadata(e,r){const i=await this.findNextPacketStart(e);if(!i)return;const s=await this.readPacket(i.startPage,i.startSegmentIndex);if(!s)return;r.codecInfo.codec="opus",r.description=e.data,r.lastMetadataPacket=s;const n=Cs(e.data);r.numberOfChannels=n.outputChannelCount,r.sampleRate=wr,r.codecInfo.opusInfo={preSkip:n.preSkip},jr(s.data.subarray(8),this.metadataTags)}async readPacket(e,r){m(r<e.lacingValues.length);let i=0;for(let d=0;d<r;d++)i+=e.lacingValues[d];let s=e,n=i,a=r;const o=[];e:for(;;){let d=this.reader.requestSlice(s.dataStartPos,s.dataSize);d instanceof Promise&&(d=await d),m(d);const h=O(d,s.dataSize);for(;;){if(a===s.lacingValues.length){o.push(h.subarray(i,n));break}const p=s.lacingValues[a];if(n+=p,p<255){o.push(h.subarray(i,n));break e}a++}let f=s.headerStartPos+s.totalSize;for(;;){let p=this.reader.requestSliceRange(f,st,_t);if(p instanceof Promise&&(p=await p),!p)return null;const g=Wt(p);if(!g)return null;if(s=g,s.serialNumber===e.serialNumber)break;f=s.headerStartPos+s.totalSize}i=0,n=0,a=0}const c=o.reduce((d,h)=>d+h.length,0);if(c===0)return null;const l=new Uint8Array(c);let u=0;for(let d=0;d<o.length;d++){const h=o[d];l.set(h,u),u+=h.length}return{data:l,endPage:s,endSegmentIndex:a}}async findNextPacketStart(e){if(e.endSegmentIndex<e.endPage.lacingValues.length-1)return{startPage:e.endPage,startSegmentIndex:e.endSegmentIndex+1};if(!!(e.endPage.headerType&4))return null;let i=e.endPage.headerStartPos+e.endPage.totalSize;for(;;){let s=this.reader.requestSliceRange(i,st,_t);if(s instanceof Promise&&(s=await s),!s)return null;const n=Wt(s);if(!n)return null;if(n.serialNumber===e.endPage.serialNumber)return{startPage:n,startSegmentIndex:0};i=n.headerStartPos+n.totalSize}}async getMimeType(){await this.readMetadata();const e=await Promise.all(this.tracks.map(r=>r.getCodecParameterString()));return ja({codecStrings:e.filter(Boolean)})}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){const e=await this.getTracks(),r=await Promise.all(e.map(i=>i.computeDuration()));return Math.max(0,...r)}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}}class Ga{constructor(e,r){this.bitstream=e,this.demuxer=r,this.encodedPacketToMetadata=new WeakMap,this.sequentialScanCache=[],this.sequentialScanMutex=new ut,this.internalSampleRate=e.codecInfo.codec==="opus"?wr:e.sampleRate}getId(){return this.bitstream.serialNumber}getNumberOfChannels(){return this.bitstream.numberOfChannels}getSampleRate(){return this.bitstream.sampleRate}getTimeResolution(){return this.bitstream.sampleRate}getCodec(){return this.bitstream.codecInfo.codec}getInternalCodecId(){return null}async getDecoderConfig(){return m(this.bitstream.codecInfo.codec),{codec:this.bitstream.codecInfo.codec,numberOfChannels:this.bitstream.numberOfChannels,sampleRate:this.bitstream.sampleRate,description:this.bitstream.description??void 0}}getName(){return null}getLanguageCode(){return he}getDisposition(){return{...Ye}}async getFirstTimestamp(){return 0}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}granulePositionToTimestampInSamples(e){return this.bitstream.codecInfo.codec==="opus"?(m(this.bitstream.codecInfo.opusInfo),e-this.bitstream.codecInfo.opusInfo.preSkip):e}createEncodedPacketFromOggPacket(e,r,i){if(!e)return null;const{durationInSamples:s,vorbisBlockSize:n}=qa(e.data,this.bitstream.codecInfo,r.vorbisLastBlocksize),a=new j(i.metadataOnly?me:e.data,"key",Math.max(0,r.timestampInSamples)/this.internalSampleRate,s/this.internalSampleRate,e.endPage.headerStartPos+e.endSegmentIndex,e.data.byteLength);return this.encodedPacketToMetadata.set(a,{packet:e,timestampInSamples:r.timestampInSamples,durationInSamples:s,vorbisLastBlockSize:r.vorbisLastBlocksize,vorbisBlockSize:n}),a}async getFirstPacket(e){m(this.bitstream.lastMetadataPacket);const r=await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);if(!r)return null;let i=0;this.bitstream.codecInfo.codec==="opus"&&(m(this.bitstream.codecInfo.opusInfo),i-=this.bitstream.codecInfo.opusInfo.preSkip);const s=await this.demuxer.readPacket(r.startPage,r.startSegmentIndex);return this.createEncodedPacketFromOggPacket(s,{timestampInSamples:i,vorbisLastBlocksize:null},e)}async getNextPacket(e,r){const i=this.encodedPacketToMetadata.get(e);if(!i)throw new Error("Packet was not created from this track.");const s=await this.demuxer.findNextPacketStart(i.packet);if(!s)return null;const n=i.timestampInSamples+i.durationInSamples,a=await this.demuxer.readPacket(s.startPage,s.startSegmentIndex);return this.createEncodedPacketFromOggPacket(a,{timestampInSamples:n,vorbisLastBlocksize:i.vorbisBlockSize},r)}async getPacket(e,r){if(this.demuxer.reader.fileSize===null)return this.getPacketSequential(e,r);const i=Ht(e*this.internalSampleRate);if(i===0)return this.getFirstPacket(r);if(i<0)return null;m(this.bitstream.lastMetadataPacket);const s=await this.demuxer.findNextPacketStart(this.bitstream.lastMetadataPacket);if(!s)return null;let n=s.startPage,a=this.demuxer.reader.fileSize;const o=[n];e:for(;n.headerStartPos+n.totalSize<a;){const b=n.headerStartPos,y=Math.floor((b+a)/2);let T=y;for(;;){const x=Math.min(T+$a,a-st);let P=this.demuxer.reader.requestSlice(T,x-T);if(P instanceof Promise&&(P=await P),m(P),!Qa(P,x)){a=y+st;continue e}let C=this.demuxer.reader.requestSliceRange(P.filePos,st,_t);C instanceof Promise&&(C=await C),m(C);const R=Wt(C);m(R);let M=!1;if(R.serialNumber===this.bitstream.serialNumber)M=!0;else{let z=this.demuxer.reader.requestSlice(R.headerStartPos,R.totalSize);z instanceof Promise&&(z=await z),m(z);const W=O(z,R.totalSize);M=Ha(W)===R.checksum}if(!M){T=R.headerStartPos+4;continue}if(M&&R.serialNumber!==this.bitstream.serialNumber){T=R.headerStartPos+R.totalSize;continue}if(R.granulePosition===-1){T=R.headerStartPos+R.totalSize;continue}this.granulePositionToTimestampInSamples(R.granulePosition)>i?a=R.headerStartPos:(n=R,o.push(R));continue e}}let c=s.startPage;for(const b of o){if(b.granulePosition===n.granulePosition)break;(!c||b.headerStartPos>c.headerStartPos)&&(c=b)}let l=c;const u=[l];for(;!(l.serialNumber===this.bitstream.serialNumber&&l.granulePosition===n.granulePosition);){const b=l.headerStartPos+l.totalSize;let y=this.demuxer.reader.requestSliceRange(b,st,_t);y instanceof Promise&&(y=await y),m(y);const T=Wt(y);m(T),l=T,l.serialNumber===this.bitstream.serialNumber&&u.push(l)}m(l.granulePosition!==-1);let d=null,h,f,p=l,g=0;if(l.headerStartPos===s.startPage.headerStartPos)h=this.granulePositionToTimestampInSamples(0),f=!0,d=0;else{h=0,f=!1;for(let T=l.lacingValues.length-1;T>=0;T--)if(l.lacingValues[T]<255){d=T+1;break}if(d===null)throw new Error("Invalid page with granule position: no packets end on this page.");g=d-1;const b={data:me,endPage:p,endSegmentIndex:g};if(await this.demuxer.findNextPacketStart(b)){const T=Qi(u,l,d);m(T);const x=$i(u,T.page,T.segmentIndex);x&&(l=x.page,d=x.segmentIndex)}else for(;;){const T=Qi(u,l,d);if(!T)break;const x=$i(u,T.page,T.segmentIndex);if(!x)break;if(l=x.page,d=x.segmentIndex,T.page.headerStartPos!==p.headerStartPos){p=T.page,g=T.segmentIndex;break}}}let k=null,w=null;for(;l!==null;){m(d!==null);const b=await this.demuxer.readPacket(l,d);if(!b)break;if(!(l.headerStartPos===s.startPage.headerStartPos&&d<s.startSegmentIndex)){let x=this.createEncodedPacketFromOggPacket(b,{timestampInSamples:h,vorbisLastBlocksize:w?.vorbisBlockSize??null},r);m(x);let P=this.encodedPacketToMetadata.get(x);if(m(P),!f&&b.endPage.headerStartPos===p.headerStartPos&&b.endSegmentIndex===g?(h=this.granulePositionToTimestampInSamples(l.granulePosition),f=!0,x=this.createEncodedPacketFromOggPacket(b,{timestampInSamples:h-P.durationInSamples,vorbisLastBlocksize:w?.vorbisBlockSize??null},r),m(x),P=this.encodedPacketToMetadata.get(x),m(P)):h+=P.durationInSamples,k=x,w=P,f&&(Math.max(h,0)>i||Math.max(P.timestampInSamples,0)===i))break}const T=await this.demuxer.findNextPacketStart(b);if(!T)break;l=T.startPage,d=T.startSegmentIndex}return k}async getPacketSequential(e,r){const i=await this.sequentialScanMutex.acquire();try{const s=Ht(e*this.internalSampleRate);e=s/this.internalSampleRate;const n=L(this.sequentialScanCache,s,c=>c.timestampInSamples);let a;if(n!==-1){const c=this.sequentialScanCache[n];a=this.createEncodedPacketFromOggPacket(c.packet,{timestampInSamples:c.timestampInSamples,vorbisLastBlocksize:c.vorbisLastBlockSize},r)}else a=await this.getFirstPacket(r);let o=0;for(;a&&a.timestamp<e;){const c=await this.getNextPacket(a,r);if(!c||c.timestamp>e)break;if(a=c,o++,o===100){o=0;const l=this.encodedPacketToMetadata.get(a);m(l),this.sequentialScanCache.length>0&&m(G(this.sequentialScanCache).timestampInSamples<=l.timestampInSamples),this.sequentialScanCache.push(l)}}return a}finally{i()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}const $i=(t,e,r)=>{let i=e,s=r;e:for(;;){for(s--,s;s>=0;s--)if(i.lacingValues[s]<255){s++;break e}if(m(s===-1),!(i.headerType&1)){s=0;break}const a=cs(t,o=>o.headerStartPos<i.headerStartPos);if(!a)return null;i=a,s=i.lacingValues.length}if(m(s!==-1),s===i.lacingValues.length){const n=t[t.indexOf(i)+1];m(n),i=n,s=0}return{page:i,segmentIndex:s}},Qi=(t,e,r)=>{if(r>0)return{page:e,segmentIndex:r-1};const i=cs(t,s=>s.headerStartPos<e.headerStartPos);return i?{page:i,segmentIndex:i.lacingValues.length-1}:null};var Re;(function(t){t[t.PCM=1]="PCM",t[t.IEEE_FLOAT=3]="IEEE_FLOAT",t[t.ALAW=6]="ALAW",t[t.MULAW=7]="MULAW",t[t.EXTENSIBLE=65534]="EXTENSIBLE"})(Re||(Re={}));class Xa extends Je{constructor(e){super(e),this.metadataPromise=null,this.dataStart=-1,this.dataSize=-1,this.audioInfo=null,this.tracks=[],this.lastKnownPacketIndex=0,this.metadataTags={},this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{let e=this.reader.requestSlice(0,12);e instanceof Promise&&(e=await e),m(e);const r=re(e,4),i=r!=="RIFX",s=r==="RF64",n=Ke(e,i);let a=s?this.reader.fileSize:Math.min(n+8,this.reader.fileSize??1/0);if(re(e,4)!=="WAVE")throw new Error("Invalid WAVE file - wrong format");let c=0,l=null,u=e.filePos;for(;a===null||u<a;){let h=this.reader.requestSlice(u,8);if(h instanceof Promise&&(h=await h),!h)break;const f=re(h,4),p=Ke(h,i),g=h.filePos;if(s&&c===0&&f!=="ds64")throw new Error('Invalid RF64 file: First chunk must be "ds64".');if(f==="fmt ")await this.parseFmtChunk(g,p,i);else if(f==="data"){if(l??=p,this.dataStart=h.filePos,this.dataSize=Math.min(l,(a??1/0)-this.dataStart),this.reader.fileSize===null)break}else if(f==="ds64"){let k=this.reader.requestSlice(g,p);if(k instanceof Promise&&(k=await k),!k)break;const w=Ki(k,i);l=Ki(k,i),a=Math.min(w+8,this.reader.fileSize??1/0)}else f==="LIST"?await this.parseListChunk(g,p,i):(f==="ID3 "||f==="id3 ")&&await this.parseId3Chunk(g,p);u=g+p+(p&1),c++}if(!this.audioInfo)throw new Error('Invalid WAVE file - missing "fmt " chunk');if(this.dataStart===-1)throw new Error('Invalid WAVE file - missing "data" chunk');const d=this.audioInfo.blockSizeInBytes;this.dataSize=Math.floor(this.dataSize/d)*d,this.tracks.push(new Fe(this.input,new Ya(this)))})()}async parseFmtChunk(e,r,i){let s=this.reader.requestSlice(e,r);if(s instanceof Promise&&(s=await s),!s)return;let n=zt(s,i);const a=zt(s,i),o=Ke(s,i);s.skip(4);const c=zt(s,i);let l;if(r===14?l=8:l=zt(s,i),r>=18&&n!==357){const u=zt(s,i),d=r-18;if(Math.min(d,u)>=22&&n===Re.EXTENSIBLE){s.skip(6);const f=O(s,16);n=f[0]|f[1]<<8}}(n===Re.MULAW||n===Re.ALAW)&&(l=8),this.audioInfo={format:n,numberOfChannels:a,sampleRate:o,sampleSizeInBytes:Math.ceil(l/8),blockSizeInBytes:c}}async parseListChunk(e,r,i){let s=this.reader.requestSlice(e,r);if(s instanceof Promise&&(s=await s),!s)return;const n=re(s,4);if(n!=="INFO"&&n!=="INF0")return;let a=s.filePos;for(;a<=e+r-8;){s.filePos=a;const o=re(s,4),c=Ke(s,i),l=O(s,c);let u=0;for(let h=0;h<l.length&&l[h]!==0;h++)u++;const d=String.fromCharCode(...l.subarray(0,u));switch(this.metadataTags.raw??={},this.metadataTags.raw[o]=d,o){case"INAM":case"TITL":this.metadataTags.title??=d;break;case"TIT3":this.metadataTags.description??=d;break;case"IART":this.metadataTags.artist??=d;break;case"IPRD":this.metadataTags.album??=d;break;case"IPRT":case"ITRK":case"TRCK":{const h=d.split("/"),f=Number.parseInt(h[0],10),p=h[1]&&Number.parseInt(h[1],10);Number.isInteger(f)&&f>0&&(this.metadataTags.trackNumber??=f),p&&Number.isInteger(p)&&p>0&&(this.metadataTags.tracksTotal??=p)}break;case"ICRD":case"IDIT":{const h=new Date(d);Number.isNaN(h.getTime())||(this.metadataTags.date??=h)}break;case"YEAR":{const h=Number.parseInt(d,10);Number.isInteger(h)&&h>0&&(this.metadataTags.date??=new Date(h,0,1))}break;case"IGNR":case"GENR":this.metadataTags.genre??=d;break;case"ICMT":case"CMNT":case"COMM":this.metadataTags.comment??=d;break}a+=8+c+(c&1)}}async parseId3Chunk(e,r){let i=this.reader.requestSlice(e,r);if(i instanceof Promise&&(i=await i),!i)return;const s=fr(i);if(s){const n=i.slice(e+10,s.size);Us(n,s,this.metadataTags)}}getCodec(){if(m(this.audioInfo),this.audioInfo.format===Re.MULAW)return"ulaw";if(this.audioInfo.format===Re.ALAW)return"alaw";if(this.audioInfo.format===Re.PCM){if(this.audioInfo.sampleSizeInBytes===1)return"pcm-u8";if(this.audioInfo.sampleSizeInBytes===2)return"pcm-s16";if(this.audioInfo.sampleSizeInBytes===3)return"pcm-s24";if(this.audioInfo.sampleSizeInBytes===4)return"pcm-s32"}return this.audioInfo.format===Re.IEEE_FLOAT&&this.audioInfo.sampleSizeInBytes===4?"pcm-f32":null}async getMimeType(){return"audio/wav"}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return m(e),e.computeDuration()}async getTracks(){return await this.readMetadata(),this.tracks}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}}const mt=2048;class Ya{constructor(e){this.demuxer=e}getId(){return 1}getCodec(){return this.demuxer.getCodec()}getInternalCodecId(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.format}async getDecoderConfig(){const e=this.demuxer.getCodec();return e?(m(this.demuxer.audioInfo),{codec:e,numberOfChannels:this.demuxer.audioInfo.numberOfChannels,sampleRate:this.demuxer.audioInfo.sampleRate}):null}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getNumberOfChannels(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.numberOfChannels}getSampleRate(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getTimeResolution(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getName(){return null}getLanguageCode(){return he}getDisposition(){return{...Ye}}async getFirstTimestamp(){return 0}async getPacketAtIndex(e,r){m(this.demuxer.audioInfo);const i=e*mt*this.demuxer.audioInfo.blockSizeInBytes;if(i>=this.demuxer.dataSize)return null;const s=Math.min(mt*this.demuxer.audioInfo.blockSizeInBytes,this.demuxer.dataSize-i);if(this.demuxer.reader.fileSize===null){let c=this.demuxer.reader.requestSlice(this.demuxer.dataStart+i,s);if(c instanceof Promise&&(c=await c),!c)return null}let n;if(r.metadataOnly)n=me;else{let c=this.demuxer.reader.requestSlice(this.demuxer.dataStart+i,s);c instanceof Promise&&(c=await c),m(c),n=O(c,s)}const a=e*mt/this.demuxer.audioInfo.sampleRate,o=s/this.demuxer.audioInfo.blockSizeInBytes/this.demuxer.audioInfo.sampleRate;return this.demuxer.lastKnownPacketIndex=Math.max(e,a),new j(n,"key",a,o,e,s)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getPacket(e,r){m(this.demuxer.audioInfo);const i=Math.floor(Math.min(e*this.demuxer.audioInfo.sampleRate/mt,(this.demuxer.dataSize-1)/(mt*this.demuxer.audioInfo.blockSizeInBytes))),s=await this.getPacketAtIndex(i,r);if(s)return s;if(i===0)return null;m(this.demuxer.reader.fileSize===null);let n=await this.getPacketAtIndex(this.demuxer.lastKnownPacketIndex,r);for(;n;){const a=await this.getNextPacket(n,r);if(!a)break;n=a}return n}getNextPacket(e,r){m(this.demuxer.audioInfo);const i=Math.round(e.timestamp*this.demuxer.audioInfo.sampleRate/mt);return this.getPacketAtIndex(i+1,r)}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}const mr=7,at=9,ct=t=>{const e=t.filePos,r=O(t,9),i=new K(r);if(i.readBits(12)!==4095||(i.skipBits(1),i.readBits(2)!==0))return null;const a=i.readBits(1),o=i.readBits(2)+1,c=i.readBits(4);if(c===15)return null;i.skipBits(1);const l=i.readBits(3);if(l===0)throw new Error("ADTS frames with channel configuration 0 are not supported.");i.skipBits(1),i.skipBits(1),i.skipBits(1),i.skipBits(1);const u=i.readBits(13);i.skipBits(11);const d=i.readBits(2)+1;if(d!==1)throw new Error("ADTS frames with more than one AAC frame are not supported.");let h=null;return a===1?t.filePos-=2:h=i.readBits(16),{objectType:o,samplingFrequencyIndex:c,channelConfiguration:l,frameLength:u,numberOfAacFrames:d,crcCheck:h,startPos:e}};const pr=1024;class Za extends Je{constructor(e){super(e),this.metadataPromise=null,this.firstFrameHeader=null,this.loadedSamples=[],this.tracks=[],this.readingMutex=new ut,this.lastSampleLoaded=!1,this.lastLoadedPos=0,this.nextTimestampInSamples=0,this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{for(;!this.firstFrameHeader&&!this.lastSampleLoaded;)await this.advanceReader();m(this.firstFrameHeader),this.tracks=[new Fe(this.input,new Ja(this))]})()}async advanceReader(){let e=this.reader.requestSliceRange(this.lastLoadedPos,mr,at);if(e instanceof Promise&&(e=await e),!e){this.lastSampleLoaded=!0;return}const r=ct(e);if(!r){this.lastSampleLoaded=!0;return}if(this.reader.fileSize!==null&&r.startPos+r.frameLength>this.reader.fileSize){this.lastSampleLoaded=!0;return}this.firstFrameHeader||(this.firstFrameHeader=r);const i=ot[r.samplingFrequencyIndex];m(i!==void 0);const s=pr/i,n={timestamp:this.nextTimestampInSamples/i,duration:s,dataStart:r.startPos,dataSize:r.frameLength};this.loadedSamples.push(n),this.nextTimestampInSamples+=pr,this.lastLoadedPos=r.startPos+r.frameLength}async getMimeType(){return"audio/aac"}async getTracks(){return await this.readMetadata(),this.tracks}async computeDuration(){await this.readMetadata();const e=this.tracks[0];return m(e),e.computeDuration()}async getMetadataTags(){return{}}}class Ja{constructor(e){this.demuxer=e}getId(){return 1}async getFirstTimestamp(){return 0}getTimeResolution(){return this.getSampleRate()/pr}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getName(){return null}getLanguageCode(){return he}getCodec(){return"aac"}getInternalCodecId(){return m(this.demuxer.firstFrameHeader),this.demuxer.firstFrameHeader.objectType}getNumberOfChannels(){m(this.demuxer.firstFrameHeader);const e=Jt[this.demuxer.firstFrameHeader.channelConfiguration];return m(e!==void 0),e}getSampleRate(){m(this.demuxer.firstFrameHeader);const e=ot[this.demuxer.firstFrameHeader.samplingFrequencyIndex];return m(e!==void 0),e}getDisposition(){return{...Ye}}async getDecoderConfig(){return m(this.demuxer.firstFrameHeader),{codec:`mp4a.40.${this.demuxer.firstFrameHeader.objectType}`,numberOfChannels:this.getNumberOfChannels(),sampleRate:this.getSampleRate()}}async getPacketAtIndex(e,r){if(e===-1)return null;const i=this.demuxer.loadedSamples[e];if(!i)return null;let s;if(r.metadataOnly)s=me;else{let n=this.demuxer.reader.requestSlice(i.dataStart,i.dataSize);if(n instanceof Promise&&(n=await n),!n)return null;s=O(n,i.dataSize)}return new j(s,"key",i.timestamp,i.duration,e,i.dataSize)}getFirstPacket(e){return this.getPacketAtIndex(0,e)}async getNextPacket(e,r){const i=await this.demuxer.readingMutex.acquire();try{const s=Zt(this.demuxer.loadedSamples,e.timestamp,a=>a.timestamp);if(s===-1)throw new Error("Packet was not created from this track.");const n=s+1;for(;n>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(n,r)}finally{i()}}async getPacket(e,r){const i=await this.demuxer.readingMutex.acquire();try{for(;;){const s=L(this.demuxer.loadedSamples,e,n=>n.timestamp);if(s===-1&&this.demuxer.loadedSamples.length>0)return null;if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(s,r);if(s>=0&&s+1<this.demuxer.loadedSamples.length)return this.getPacketAtIndex(s,r);await this.demuxer.advanceReader()}}finally{i()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}}const eo=t=>t===0?null:t===1?192:t>=2&&t<=5?144*2**t:t===6?"uncommon-u8":t===7?"uncommon-u16":t>=8&&t<=15?2**t:null,to=(t,e)=>{switch(t){case 0:return e;case 1:return 88200;case 2:return 176400;case 3:return 192e3;case 4:return 8e3;case 5:return 16e3;case 6:return 22050;case 7:return 24e3;case 8:return 32e3;case 9:return 44100;case 10:return 48e3;case 11:return 96e3;case 12:return"uncommon-u8";case 13:return"uncommon-u16";case 14:return"uncommon-u16-10";default:return null}},ro=t=>{let e=0;const r=new K(O(t,1));for(;r.readBits(1)===1;)e++;if(e===0)return r.readBits(7);const i=[],s=e-1,n=new K(O(t,s)),a=8-e-1;for(let c=0;c<a;c++)i.unshift(r.readBits(1));for(let c=0;c<s;c++)for(let l=0;l<8;l++){const u=n.readBits(1);l<2||i.unshift(u)}return i.reduce((c,l,u)=>c|l<<u,0)},io=(t,e)=>{if(e==="uncommon-u16")return ee(t)+1;if(e==="uncommon-u8")return F(t)+1;if(typeof e=="number")return e;Xe(e),m(!1)},so=(t,e)=>e==="uncommon-u16"?ee(t):e==="uncommon-u16-10"?ee(t)*10:e==="uncommon-u8"?F(t):typeof e=="number"?e:null,no=t=>{let r=0;for(const i of t){r^=i;for(let s=0;s<8;s++)(r&128)!==0?r=r<<1^7:r<<=1,r&=255}return r};class ao extends Je{constructor(e){super(e),this.loadedSamples=[],this.metadataPromise=null,this.track=null,this.metadataTags={},this.audioInfo=null,this.lastLoadedPos=null,this.blockingBit=null,this.readingMutex=new ut,this.lastSampleLoaded=!1,this.reader=e._reader}async computeDuration(){return await this.readMetadata(),m(this.track),this.track.computeDuration()}async getMetadataTags(){return await this.readMetadata(),this.metadataTags}async getTracks(){return await this.readMetadata(),m(this.track),[this.track]}async getMimeType(){return"audio/flac"}async readMetadata(){let e=4;return this.metadataPromise??=(async()=>{for(;this.reader.fileSize===null||e<this.reader.fileSize;){let r=this.reader.requestSlice(e,4);if(r instanceof Promise&&(r=await r),e+=4,r===null)throw new Error(`Metadata block at position ${e} is too small! Corrupted file.`);m(r);const i=F(r),s=wt(r),n=(i&128)!==0;switch(i&127){case It.STREAMINFO:{let o=this.reader.requestSlice(e,s);if(o instanceof Promise&&(o=await o),m(o),o===null)throw new Error(`StreamInfo block at position ${e} is too small! Corrupted file.`);const c=O(o,34),l=new K(c),u=l.readBits(16),d=l.readBits(16),h=l.readBits(24),f=l.readBits(24),p=l.readBits(20),g=l.readBits(3)+1;l.readBits(5);const k=l.readBits(36);l.skipBits(128);const w=new Uint8Array(42);w.set(new Uint8Array([102,76,97,67]),0),w.set(new Uint8Array([128,0,0,34]),4),w.set(c,8),this.audioInfo={numberOfChannels:g,sampleRate:p,totalSamples:k,minimumBlockSize:u,maximumBlockSize:d,minimumFrameSize:h,maximumFrameSize:f,description:w},this.track=new Fe(this.input,new oo(this));break}case It.VORBIS_COMMENT:{let o=this.reader.requestSlice(e,s);o instanceof Promise&&(o=await o),m(o),jr(O(o,s),this.metadataTags);break}case It.PICTURE:{let o=this.reader.requestSlice(e,s);o instanceof Promise&&(o=await o),m(o);const c=I(o),l=I(o),u=ke.decode(O(o,l)),d=I(o),h=ke.decode(O(o,d));o.skip(16);const f=I(o),p=O(o,f);this.metadataTags.images??=[],this.metadataTags.images.push({data:p,mimeType:u,kind:c===3?"coverFront":c===4?"coverBack":"unknown",description:h});break}}if(e+=s,n){this.lastLoadedPos=e;break}}})()}async readNextFlacFrame({startPos:e,isFirstPacket:r}){m(this.audioInfo);const i=6,n=this.audioInfo.maximumFrameSize+16,a=await this.reader.requestSliceRange(e,this.audioInfo.minimumFrameSize,n);if(!a)return null;const o=this.readFlacFrameHeader({slice:a,isFirstPacket:r});if(!o)return null;for(a.filePos=e+this.audioInfo.minimumFrameSize;;){if(a.filePos>a.end-i)return{num:o.num,blockSize:o.blockSize,sampleRate:o.sampleRate,size:a.end-e,isLastFrame:!0};if(F(a)===255){const l=a.filePos,u=F(a),d=this.blockingBit===1?249:248;if(u!==d){a.filePos=l;continue}a.skip(-2);const h=a.filePos-e,f=this.readFlacFrameHeader({slice:a,isFirstPacket:!1});if(!f){a.filePos=l;continue}if(this.blockingBit===0){if(f.num-o.num!==1){a.filePos=l;continue}}else if(f.num-o.num!==o.blockSize){a.filePos=l;continue}return{num:o.num,blockSize:o.blockSize,sampleRate:o.sampleRate,size:h,isLastFrame:!1}}}}readFlacFrameHeader({slice:e,isFirstPacket:r}){const i=e.filePos,s=O(e,4),n=new K(s);if(n.readBits(15)!==32764)return null;if(this.blockingBit===null){m(r);const k=n.readBits(1);this.blockingBit=k}else if(this.blockingBit===1){if(m(!r),n.readBits(1)!==1)return null}else if(this.blockingBit===0){if(m(!r),n.readBits(1)!==0)return null}else throw new Error("Invalid blocking bit");const o=eo(n.readBits(4));if(!o)return null;m(this.audioInfo);const c=to(n.readBits(4),this.audioInfo.sampleRate);if(!c||(n.readBits(4),n.readBits(3),n.readBits(1)!==0))return null;const u=ro(e),d=io(e,o),h=so(e,c);if(h===null||h!==this.audioInfo.sampleRate)return null;const f=e.filePos-i,p=F(e);e.skip(-f),e.skip(-1);const g=no(O(e,f));return p!==g?null:{num:u,blockSize:d,sampleRate:h}}async advanceReader(){await this.readMetadata(),m(this.lastLoadedPos!==null),m(this.audioInfo);const e=this.lastLoadedPos,r=await this.readNextFlacFrame({startPos:e,isFirstPacket:this.loadedSamples.length===0});if(!r){this.lastSampleLoaded=!0;return}const i=this.loadedSamples[this.loadedSamples.length-1],n={blockOffset:i?i.blockOffset+i.blockSize:0,blockSize:r.blockSize,byteOffset:e,byteSize:r.size};if(this.lastLoadedPos=this.lastLoadedPos+r.size,this.loadedSamples.push(n),r.isLastFrame){this.lastSampleLoaded=!0;return}}}class oo{constructor(e){this.demuxer=e}getId(){return 1}getCodec(){return"flac"}getInternalCodecId(){return null}getNumberOfChannels(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.numberOfChannels}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}getSampleRate(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getName(){return null}getLanguageCode(){return he}getTimeResolution(){return m(this.demuxer.audioInfo),this.demuxer.audioInfo.sampleRate}getDisposition(){return{...Ye}}async getFirstTimestamp(){return 0}async getDecoderConfig(){return m(this.demuxer.audioInfo),{codec:"flac",numberOfChannels:this.demuxer.audioInfo.numberOfChannels,sampleRate:this.demuxer.audioInfo.sampleRate,description:this.demuxer.audioInfo.description}}async getPacket(e,r){if(m(this.demuxer.audioInfo),e<0)throw new Error("Timestamp cannot be negative");const i=await this.demuxer.readingMutex.acquire();try{for(;;){const s=L(this.demuxer.loadedSamples,e,c=>c.blockOffset/this.demuxer.audioInfo.sampleRate);if(s===-1){await this.demuxer.advanceReader();continue}const n=this.demuxer.loadedSamples[s],a=n.blockOffset/this.demuxer.audioInfo.sampleRate,o=n.blockSize/this.demuxer.audioInfo.sampleRate;if(a+o<=e){if(this.demuxer.lastSampleLoaded)return this.getPacketAtIndex(this.demuxer.loadedSamples.length-1,r);await this.demuxer.advanceReader();continue}return this.getPacketAtIndex(s,r)}}finally{i()}}async getNextPacket(e,r){const i=await this.demuxer.readingMutex.acquire();try{const s=e.sequenceNumber+1;if(this.demuxer.lastSampleLoaded&&s>=this.demuxer.loadedSamples.length)return null;for(;s>=this.demuxer.loadedSamples.length&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(s,r)}finally{i()}}getKeyPacket(e,r){return this.getPacket(e,r)}getNextKeyPacket(e,r){return this.getNextPacket(e,r)}async getPacketAtIndex(e,r){const i=this.demuxer.loadedSamples[e];if(!i)return null;let s;if(r.metadataOnly)s=me;else{let o=this.demuxer.reader.requestSlice(i.byteOffset,i.byteSize);if(o instanceof Promise&&(o=await o),!o)return null;s=O(o,i.byteSize)}m(this.demuxer.audioInfo);const n=i.blockOffset/this.demuxer.audioInfo.sampleRate,a=i.blockSize/this.demuxer.audioInfo.sampleRate;return new j(s,"key",n,a,e,i.byteSize)}async getFirstPacket(e){for(;this.demuxer.loadedSamples.length===0&&!this.demuxer.lastSampleLoaded;)await this.demuxer.advanceReader();return this.getPacketAtIndex(0,e)}}const De=9e4,ue=188,co=t=>{let e="video/MP2T";const r=[...new Set(t.filter(Boolean))];return r.length>0&&(e+=`; codecs="${r.join(", ")}"`),e};const kt="No PES packet found where one was expected.";class lo extends Je{constructor(e){super(e),this.metadataPromise=null,this.elementaryStreams=[],this.tracks=[],this.packetOffset=0,this.packetStride=-1,this.sectionEndPositions=[],this.reader=e._reader}async readMetadata(){return this.metadataPromise??=(async()=>{const e=ue+16+1;let r=this.reader.requestSlice(0,e);r instanceof Promise&&(r=await r),m(r);const i=O(r,e);if(i[0]===71&&i[ue]===71)this.packetOffset=0,this.packetStride=ue;else if(i[0]===71&&i[ue+16]===71)this.packetOffset=0,this.packetStride=ue+16;else if(i[4]===71&&i[4+ue]===71)this.packetOffset=4,this.packetStride=ue;else throw new Error("Unreachable.");let s=this.packetOffset,n=null,a=!1,o=!1;for(;;){const c=await this.readSection(s,!0,!o);if(!c)break;const l=3,u=32;if(c.pid===0&&!a){const h=new K(c.payload),f=h.readAlignedByte();h.skipBits(8*f),h.skipBits(14);const p=h.readBits(10);for(h.skipBits(40);8*(p+l)-h.pos>u;){const g=h.readBits(16);if(h.skipBits(3),g!==0){if(n!==null)throw new Error("Only files with a single program are supported.");n=h.readBits(13)}}if(n===null)throw new Error("Program Association Table must link to a Program Map Table.");a=!0}else if(c.pid===n&&!o){const h=new K(c.payload),f=h.readAlignedByte();h.skipBits(8*f),h.skipBits(12);const p=h.readBits(12);h.skipBits(43),h.readBits(13),h.skipBits(6);const g=h.readBits(10);for(h.skipBits(8*g);8*(p+l)-h.pos>u;){const k=h.readBits(8);h.skipBits(3);const w=h.readBits(13);h.skipBits(6);const b=h.readBits(10);h.skipBits(8*b);let y=null;switch(k){case 3:case 4:case 15:y={type:"audio",codec:k===15?"aac":"mp3",aacCodecInfo:null,numberOfChannels:-1,sampleRate:-1};break;case 27:case 36:y={type:"video",codec:k===27?"avc":"hevc",avcCodecInfo:null,hevcCodecInfo:null,colorSpace:{primaries:null,transfer:null,matrix:null,fullRange:null},width:-1,height:-1,reorderSize:-1};break}y&&this.elementaryStreams.push({demuxer:this,pid:w,streamType:k,initialized:!1,firstSection:null,info:y})}o=!0}else{const h=this.elementaryStreams.find(f=>f.pid===c.pid);if(h&&!h.initialized){const f=xt(c);if(!f)throw new Error(`Couldn't read first PES packet for Elementary Stream with PID ${h.pid}`);if(h.firstSection=c,h.info.type==="video")if(h.info.codec==="avc"){if(h.info.avcCodecInfo=di(f.data),!h.info.avcCodecInfo)throw new Error("Invalid AVC video stream; could not extract AVCDecoderConfigurationRecord from first packet.");const p=h.info.avcCodecInfo.sequenceParameterSets[0];m(p);const g=hi(p);h.info.width=g.displayWidth,h.info.height=g.displayHeight,h.info.colorSpace={primaries:ar[g.colourPrimaries],transfer:or[g.transferCharacteristics],matrix:cr[g.matrixCoefficients],fullRange:!!g.fullRangeFlag},h.info.reorderSize=g.maxDecFrameBuffering,h.initialized=!0}else if(h.info.codec==="hevc"){if(h.info.hevcCodecInfo=fi(f.data),!h.info.hevcCodecInfo)throw new Error("Invalid HEVC video stream; could not extract HVCDecoderConfigurationRecord from first packet.");const g=h.info.hevcCodecInfo.arrays.find(w=>w.nalUnitType===ae.SPS_NUT).nalUnits[0];m(g);const k=Ts(g);h.info.width=k.displayWidth,h.info.height=k.displayHeight,h.info.colorSpace={primaries:ar[k.colourPrimaries],transfer:or[k.transferCharacteristics],matrix:cr[k.matrixCoefficients],fullRange:!!k.fullRangeFlag},h.info.reorderSize=k.maxDecFrameBuffering,h.initialized=!0}else throw new Error("Unhandled.");else if(h.info.codec==="aac"){const p=ye.tempFromBytes(f.data),g=ct(p);if(!g)throw new Error("Invalid AAC audio stream; could not read ADTS frame header from first packet.");h.info.aacCodecInfo={isMpeg2:!1,objectType:g.objectType},h.info.numberOfChannels=Jt[g.channelConfiguration],h.info.sampleRate=ot[g.samplingFrequencyIndex],h.initialized=!0}else if(h.info.codec==="mp3"){const p=I(ye.tempFromBytes(f.data)),g=yi(p,f.data.byteLength);if(!g.header)throw new Error("Invalid MP3 audio stream; could not read frame header from first packet.");h.info.numberOfChannels=g.header.channel===3?1:2,h.info.sampleRate=g.header.sampleRate,h.initialized=!0}else throw new Error("Unhandled.")}}if(o&&this.elementaryStreams.every(h=>h.initialized))break;m(c.endPos!==null),s=c.endPos}for(const c of this.elementaryStreams)c.info.type==="video"?this.tracks.push(new Bt(this.input,new uo(c))):this.tracks.push(new Fe(this.input,new ho(c)))})()}async getTracks(){return await this.readMetadata(),this.tracks}async getMetadataTags(){return{}}async computeDuration(){const e=await this.getTracks(),r=await Promise.all(e.map(i=>i.computeDuration()));return Math.max(0,...r)}async getMimeType(){await this.readMetadata();const e=await this.getTracks(),r=await Promise.all(e.map(i=>i.getCodecParameterString()));return co(r)}async readSection(e,r,i=!1){let s=e,n=e;const a=[];let o=0,c=null,l=!0;for(;;){const d=await this.readPacket(n);if(n+=this.packetStride,!d)break;if(c){if(d.pid!==c.pid){if(i)break;continue}if(d.payloadUnitStartIndicator===1)break}else{if(d.payloadUnitStartIndicator===0)break;c=d}const h=!!(d.adaptationFieldControl&2),f=!!(d.adaptationFieldControl&1);let p=0;if(h&&(p=1+d.body[0]),f&&(p===0?(a.push(d.body),o+=d.body.byteLength):(a.push(d.body.subarray(p)),o+=d.body.byteLength-p)),s=n,!r&&o>=64){l=!1;break}if(Zt(this.sectionEndPositions,s,k=>k)!==-1){l=!1;break}}if(l){const d=L(this.sectionEndPositions,s,h=>h);this.sectionEndPositions.splice(d+1,0,s)}if(!c)return null;let u;if(a.length===1)u=a[0];else{const d=a.reduce((f,p)=>f+p.length,0);u=new Uint8Array(d);let h=0;for(const f of a)u.set(f,h),h+=f.length}return{startPos:e,endPos:r?s:null,pid:c.pid,payload:u}}async readPacketHeader(e){let r=this.reader.requestSlice(e,4);if(r instanceof Promise&&(r=await r),!r)return null;if(F(r)!==71)throw new Error("Invalid TS packet sync byte. Likely an internal bug, please report this file.");const s=ee(r),n=s>>14&1,a=s&8191,c=F(r)>>4&3;return{payloadUnitStartIndicator:n,pid:a,adaptationFieldControl:c}}async readPacket(e){let r=this.reader.requestSlice(e,ue);if(r instanceof Promise&&(r=await r),!r)return null;const i=O(r,ue);if(i[0]!==71)throw new Error("Invalid TS packet sync byte. Likely an internal bug, please report this file.");const n=(i[1]<<8)+i[2],a=n>>14&1,o=n&8191,l=i[3]>>4&3;return{payloadUnitStartIndicator:a,pid:o,adaptationFieldControl:l,body:i.subarray(4)}}}const bt=t=>{const e=new K(t.payload);if(e.readBits(24)!==1)return null;const i=e.readBits(8);if(e.skipBits(16),i===188||i===190||i===191||i===240||i===241||i===255||i===242||i===248)return null;e.skipBits(8);const s=e.readBits(2);e.skipBits(14);let n=0;if(s===2||s===3)e.skipBits(4),n+=e.readBits(3)*(1<<30),e.skipBits(1),n+=e.readBits(15)*32768,e.skipBits(1),n+=e.readBits(15);else throw new Error("PES packets without PTS are not currently supported. If you think this file should be supported, please report it.");return{sectionStartPos:t.startPos,sectionEndPos:t.endPos,pts:n}},xt=t=>{m(t.endPos!==null);const e=bt(t);if(!e)return null;const r=new K(t.payload);r.skipBits(32);const i=r.readBits(16),s=6;r.skipBits(16);const n=r.readBits(8),a=r.pos+8*n;r.pos=a;const o=a/8;m(Number.isInteger(o));const c=t.payload.subarray(o,i>0?s+i:t.payload.byteLength);return{...e,data:c}};class Ws{constructor(e){this.elementaryStream=e,this.referencePesPackets=[],this.endReferencePesPacketAdded=!1,this.packetBuffers=new WeakMap,this.packetSectionStarts=new WeakMap,this.mutex=new ut}getId(){return this.elementaryStream.pid}getCodec(){throw new Error("Not implemented on base class.")}getInternalCodecId(){return this.elementaryStream.streamType}getName(){return null}getLanguageCode(){return he}getDisposition(){return Ye}getTimeResolution(){return De}async computeDuration(){const e=await this.getPacket(1/0,{metadataOnly:!0});return(e?.timestamp??0)+(e?.duration??0)}async getFirstTimestamp(){return(await this.getFirstPacket({metadataOnly:!0}))?.timestamp??0}createEncodedPacket(e,r,i){return new j(i.metadataOnly?me:e.data,this.getPacketType(e.data),e.pts/De,Math.max(r/De,0),e.sequenceNumber,e.data.byteLength)}maybeInsertReferencePacket(e,r,i){if(i&&this.mutex.pending>0)return;const s=L(this.referencePesPackets,e.pts,n=>n.pts);if(s>=0){const n=this.referencePesPackets[s];if(e.sectionStartPos<=n.sectionStartPos||!r&&e.pts-n.pts<De/2)return!1;if(s<this.referencePesPackets.length-1){const a=this.referencePesPackets[s+1];if(a.sectionStartPos<e.sectionStartPos||!r&&a.pts-e.pts<De/2)return!1}}return this.referencePesPackets.splice(s+1,0,e),!0}async getFirstPacket(e){const r=this.elementaryStream.firstSection;m(r);const i=xt(r);m(i);const s=new Ct(this,i,!0),n=new rr(this,s),a=await n.readNext();if(!a)return null;const o=this.createEncodedPacket(a.packet,a.duration,e);return this.packetBuffers.set(o,n),this.packetSectionStarts.set(o,a.packet.sectionStartPos),o}async getNextPacket(e,r){let i=this.packetBuffers.get(e);if(i){const u=await i.readNext();if(!u)return null;this.packetBuffers.delete(e);const d=this.createEncodedPacket(u.packet,u.duration,r);return this.packetBuffers.set(d,i),this.packetSectionStarts.set(d,u.packet.sectionStartPos),d}const s=this.packetSectionStarts.get(e);if(s===void 0)throw new Error("Packet was not created from this track.");const a=await this.elementaryStream.demuxer.readSection(s,!0);m(a);const o=xt(a);m(o);const c=new Ct(this,o,!0);i=new rr(this,c);const l=e.sequenceNumber;for(;;){const u=await i.readNext();if(!u)return null;if(u.packet.sequenceNumber>l){const d=this.createEncodedPacket(u.packet,u.duration,r);return this.packetBuffers.set(d,i),this.packetSectionStarts.set(d,u.packet.sectionStartPos),d}}}async getNextKeyPacket(e,r){let i=e;for(;;){if(i=await this.getNextPacket(i,r),!i)return null;if(i.type==="key")return i}}getPacket(e,r){return this.doPacketLookup(e,!1,r)}getKeyPacket(e,r){return this.doPacketLookup(e,!0,r)}async doPacketLookup(e,r,i){const s=Ht(e*De),n=this.elementaryStream.demuxer,a=n.reader,o=await this.mutex.acquire();let c;try{if(this.referencePesPackets.length===0){const b=this.elementaryStream.firstSection;m(b);const y=bt(b);m(y),this.maybeInsertReferencePacket(y,!1,!1),m(this.referencePesPackets.length===1)}let k=L(this.referencePesPackets,s,b=>b.pts);if(k===-1)return null;if(a.fileSize!==null&&k===this.referencePesPackets.length-1&&!this.endReferencePesPacketAdded){let b=a.fileSize-n.packetStride+n.packetOffset,y=await n.readPacketHeader(b);if(!y)return null;for(;y.pid!==this.elementaryStream.pid||y.payloadUnitStartIndicator===0;){b-=n.packetStride;const P=await n.readPacketHeader(b);if(!P)return null;y=P}const T=await n.readSection(b,!1);m(T);const x=bt(T);if(!x)throw new Error(kt);this.maybeInsertReferencePacket(x,!0,!1),this.endReferencePesPacketAdded=!0}for(k=L(this.referencePesPackets,s,b=>b.pts),m(k!==-1);a.fileSize!==null;){const b=this.referencePesPackets[k],y=this.referencePesPackets[k+1];if(s-b.pts<De||!y)break;let x=ls((b.sectionStartPos+y.sectionStartPos)/2,n.packetStride)+n.packetOffset,P=await n.readPacketHeader(x);for(m(P);x<y.sectionStartPos&&(P.pid!==this.elementaryStream.pid||P.payloadUnitStartIndicator===0);){x+=n.packetStride;const M=await n.readPacketHeader(x);if(!M)return null;P=M}if(x>=y.sectionStartPos)break;const _=await n.readSection(x,!1);m(_);const C=bt(_);if(!C)throw new Error(kt);if(!this.maybeInsertReferencePacket(C,!1,!1))break;C.pts<=s&&k++}c=this.referencePesPackets[k],m(c.pts<=s)}finally{o()}o();e:for(;;){let k=c.sectionStartPos+n.packetStride;for(;;){const y=await n.readPacketHeader(k);if(!y)break e;if(y.pid===this.elementaryStream.pid&&y.payloadUnitStartIndicator===1)break;k+=n.packetStride}const w=await n.readSection(k,!1);if(!w)break;const b=bt(w);if(!b)throw new Error(kt);if(b.pts>s)break;c=b,a.fileSize===null&&this.maybeInsertReferencePacket(b,!1,!0)}const l=this.getReorderSize();for(let k=0;k<l;k++){let w=c.sectionStartPos-n.packetStride;for(;;){const b=await n.readPacketHeader(w);if(!b)break;if(b.pid===this.elementaryStream.pid&&b.payloadUnitStartIndicator===1){const y=await n.readSection(w,!1);m(y);const T=bt(y);if(!T)throw new Error(kt);c=T;break}w-=n.packetStride}}const u=await n.readSection(c.sectionStartPos,!0);m(u);const d=xt(u);m(d);const h=new Ct(this,d,!0),f=new rr(this,h);for(;!((G(f.presentationOrderPackets)?.pts??-1/0)>=s||!await f.readNextDecodeOrderPacket()););const p=ai(f.presentationOrderPackets,k=>k.pts<=s&&(!r||this.getPacketType(k.data)==="key"));if(p!==-1){const k=f.presentationOrderPackets[p],w=p===0?0:k.pts-f.presentationOrderPackets[p-1].pts;for(;f.decodeOrderPackets[0]!==k;)f.decodeOrderPackets.shift();f.lastDuration=w;const b=await f.readNext();m(b);const y=this.createEncodedPacket(b.packet,b.duration,i);return this.packetBuffers.set(y,f),this.packetSectionStarts.set(y,b.packet.sectionStartPos),y}if(!r)return null;let g=c.sectionStartPos;for(;;){g-=n.packetStride;const k=await n.readPacketHeader(g);if(!k)return null;if(k.pid!==this.elementaryStream.pid||k.payloadUnitStartIndicator!==1)continue;const w=await n.readSection(g,!0);m(w);const b=xt(w);if(!b)throw new Error(kt);const y=new Ct(this,b,!1);if(await this.markNextPacket(y),!y.suppliedPacket||this.getPacketType(y.suppliedPacket.data)!=="key")continue;y.uncapped=!0;const T=new rr(this,y),x=await T.readNext();m(x);const P=this.createEncodedPacket(x.packet,x.duration,i);return this.packetBuffers.set(P,T),this.packetSectionStarts.set(P,x.packet.sectionStartPos),P}}}class uo extends Ws{constructor(e){super(e),this.elementaryStream=e,this.decoderConfig={codec:ci({width:this.elementaryStream.info.width,height:this.elementaryStream.info.height,codec:this.elementaryStream.info.codec,codecDescription:null,colorSpace:this.elementaryStream.info.colorSpace,avcType:1,avcCodecInfo:this.elementaryStream.info.avcCodecInfo,hevcCodecInfo:this.elementaryStream.info.hevcCodecInfo,vp9CodecInfo:null,av1CodecInfo:null}),codedWidth:this.elementaryStream.info.width,codedHeight:this.elementaryStream.info.height,colorSpace:this.elementaryStream.info.colorSpace}}getCodec(){return this.elementaryStream.info.codec}getCodedWidth(){return this.elementaryStream.info.width}getCodedHeight(){return this.elementaryStream.info.height}getRotation(){return 0}async getColorSpace(){return this.elementaryStream.info.colorSpace}async canBeTransparent(){return!1}async getDecoderConfig(){return this.decoderConfig}getPacketType(e){return mi(this.elementaryStream.info.codec,this.decoderConfig,e)??"key"}getReorderSize(){return this.elementaryStream.info.reorderSize}async markNextPacket(e){m(!e.suppliedPacket);const r=this.elementaryStream.info.codec,i=1024;if(r!=="avc"&&r!=="hevc")throw new Error("Unhandled.");let s=null;for(;;){let n=e.ensureBuffered(i);if(n instanceof Promise&&(n=await n),n===0)break;const a=e.currentPos,o=e.readBytes(n),c=o.byteLength;let l=0;for(;l<c;){const u=o.indexOf(0,l);if(u===-1||u>=c)break;l=u;const d=a+l;if(l+4>=c){e.seekTo(d);break}const h=o[l+1],f=o[l+2],p=o[l+3];let g=0,k=null;if(h===0&&f===0&&p===1?(g=4,k=o[l+4]):h===0&&f===1&&(g=3,k=p),g===0){l++;continue}const w=d;if(s===null){s=w,l+=g;continue}if(k!==null){const b=r==="avc"?yr(k):jt(k);if(r==="avc"?b===Ee.AUD:b===ae.AUD_NUT){const T=w-s;return e.seekTo(s),e.supplyPacket(T,0)}}l+=g}if(n<i)break}if(s!==null){const n=e.endPos-s;return e.seekTo(s),e.supplyPacket(n,0)}}}class ho extends Ws{constructor(e){super(e),this.elementaryStream=e}getCodec(){return this.elementaryStream.info.codec}getNumberOfChannels(){return this.elementaryStream.info.numberOfChannels}getSampleRate(){return this.elementaryStream.info.sampleRate}async getDecoderConfig(){return{codec:li({codec:this.elementaryStream.info.codec,codecDescription:null,aacCodecInfo:this.elementaryStream.info.aacCodecInfo}),numberOfChannels:this.elementaryStream.info.numberOfChannels,sampleRate:this.elementaryStream.info.sampleRate}}getPacketType(e){return"key"}getReorderSize(){return 1}async markNextPacket(e){m(!e.suppliedPacket);const r=this.elementaryStream.info.codec,i=128;for(;;){let s=e.ensureBuffered(i);s instanceof Promise&&(s=await s);const n=e.currentPos;for(;e.currentPos-n<s;){const a=e.readU8();if(r==="aac"){if(a!==255)continue;e.skip(-1);const o=e.currentPos;let c=e.ensureBuffered(at);if(c instanceof Promise&&(c=await c),c<at)return;const l=e.readBytes(at),u=ct(ye.tempFromBytes(l));if(u){e.seekTo(o);let d=e.ensureBuffered(u.frameLength);return d instanceof Promise&&(d=await d),e.supplyPacket(d,Math.round(pr*De/this.elementaryStream.info.sampleRate))}else e.seekTo(o+1)}else if(r==="mp3"){if(a!==255)continue;e.skip(-1);const o=e.currentPos;let c=e.ensureBuffered(Lt);if(c instanceof Promise&&(c=await c),c<Lt)return;const l=e.readBytes(Lt),u=X(l).getUint32(0),d=yi(u,null);if(d.header){e.seekTo(o);let h=e.ensureBuffered(d.header.totalSize);h instanceof Promise&&(h=await h);const f=d.header.audioSamplesInFrame*De/this.elementaryStream.info.sampleRate;return e.supplyPacket(h,Math.round(f))}else e.seekTo(o+1)}else throw new Error("Unhandled.")}if(s<i)break}}}class Ct{constructor(e,r,i){this.currentPos=0,this.pesPackets=[],this.currentPesPacketIndex=0,this.currentPesPacketPos=0,this.endPos=0,this.nextPts=0,this.suppliedPacket=null,this.backing=e,this.pid=e.elementaryStream.pid,this.demuxer=e.elementaryStream.demuxer,this.startingPesPacket=r,this.uncapped=i}clone(){const e=new Ct(this.backing,this.startingPesPacket,!0);return e.currentPos=this.currentPos,e.pesPackets=[...this.pesPackets],e.currentPesPacketIndex=this.currentPesPacketIndex,e.currentPesPacketPos=this.currentPesPacketPos,e.endPos=this.endPos,e.nextPts=this.nextPts,e}ensureBuffered(e){const r=this.endPos-this.currentPos;return r>=e?e:this.bufferData(e-r).then(()=>Math.min(this.endPos-this.currentPos,e))}getCurrentPesPacket(){const e=this.pesPackets[this.currentPesPacketIndex];return m(e),e}async bufferData(e){const r=this.endPos+e;for(;this.endPos<r;){let i;if(this.pesPackets.length===0)i=this.startingPesPacket;else{let s=G(this.pesPackets).sectionEndPos;for(m(s!==null);;){const o=await this.demuxer.readPacketHeader(s);if(!o)return;if(o.pid===this.pid)break;s+=this.demuxer.packetStride}const n=await this.demuxer.readSection(s,!0);if(!n)return;const a=xt(n);if(!a)throw new Error(kt);i=a}this.pesPackets.push(i),this.endPos+=i.data.byteLength,this.pesPackets.length===1&&(this.nextPts=i.pts)}}readBytes(e){const r=this.getCurrentPesPacket(),i=this.currentPos-this.currentPesPacketPos,s=i+e;if(this.currentPos+=e,s<=r.data.byteLength)return r.data.subarray(i,s);const n=new Uint8Array(e);n.set(r.data.subarray(i));let a=r.data.byteLength-i;for(;;){this.advanceCurrentPacket();const o=this.getCurrentPesPacket(),c=e-a;if(c<=o.data.byteLength){n.set(o.data.subarray(0,c),a);break}n.set(o.data,a),a+=o.data.byteLength}return n}readU8(){let e=this.getCurrentPesPacket();const r=this.currentPos-this.currentPesPacketPos;return this.currentPos++,r<e.data.byteLength?e.data[r]:(this.advanceCurrentPacket(),e=this.getCurrentPesPacket(),e.data[0])}seekTo(e){if(e!==this.currentPos){if(e<this.currentPos)for(;e<this.currentPesPacketPos;){this.currentPesPacketIndex--;const r=this.getCurrentPesPacket();this.currentPesPacketPos-=r.data.byteLength,this.nextPts=r.pts}else for(;;){const r=this.getCurrentPesPacket(),i=this.currentPesPacketPos+r.data.byteLength;if(e<i)break;this.currentPesPacketPos+=r.data.byteLength,this.currentPesPacketIndex++,this.nextPts=this.getCurrentPesPacket().pts}this.currentPos=e}}skip(e){this.seekTo(this.currentPos+e)}advanceCurrentPacket(){this.currentPesPacketPos+=this.getCurrentPesPacket().data.byteLength,this.currentPesPacketIndex++,this.nextPts=this.getCurrentPesPacket().pts}supplyPacket(e,r){const i=this.getCurrentPesPacket();if(!this.uncapped&&i!==this.startingPesPacket){this.suppliedPacket=null;return}this.backing.maybeInsertReferencePacket(i,!1,!0);const s=this.nextPts;this.nextPts+=r;const n=i.sectionStartPos,a=n+(this.currentPos-this.currentPesPacketPos),o=this.readBytes(e);this.suppliedPacket={pts:s,data:o,sequenceNumber:a,sectionStartPos:n},this.pesPackets.splice(0,this.currentPesPacketIndex),this.currentPesPacketIndex=0}}class rr{constructor(e,r){this.decodeOrderPackets=[],this.reorderBuffer=[],this.presentationOrderPackets=[],this.reachedEnd=!1,this.lastDuration=0,this.backing=e,this.context=r,this.reorderSize=e.getReorderSize(),m(this.reorderSize>=0)}async readNext(){if(this.decodeOrderPackets.length===0&&!await this.readNextDecodeOrderPacket())return null;await this.ensureCurrentPacketHasNext();const e=this.decodeOrderPackets[0],r=this.presentationOrderPackets.indexOf(e);m(r!==-1);let i;for(r===this.presentationOrderPackets.length-1?i=this.lastDuration:(i=this.presentationOrderPackets[r+1].pts-e.pts,this.lastDuration=i),this.decodeOrderPackets.shift();this.presentationOrderPackets.length>0;){const s=this.presentationOrderPackets[0];if(this.decodeOrderPackets.includes(s))break;this.presentationOrderPackets.shift()}return{packet:e,duration:i}}async readNextDecodeOrderPacket(){if(this.reachedEnd)return!1;let e;return this.context.suppliedPacket?e=this.context.suppliedPacket:(await this.backing.markNextPacket(this.context),e=this.context.suppliedPacket),this.context.suppliedPacket=null,e?(this.decodeOrderPackets.push(e),this.processPacketThroughReorderBuffer(e),!0):(this.reachedEnd=!0,this.flushReorderBuffer(),!1)}async ensureCurrentPacketHasNext(){const e=this.decodeOrderPackets[0];for(m(e);;){const r=this.presentationOrderPackets.indexOf(e);if(r!==-1&&r<=this.presentationOrderPackets.length-2||!await this.readNextDecodeOrderPacket())break}}processPacketThroughReorderBuffer(e){if(this.reorderBuffer.push(e),this.reorderBuffer.length>=this.reorderSize){let r=0;for(let s=1;s<this.reorderBuffer.length;s++)this.reorderBuffer[s].pts<this.reorderBuffer[r].pts&&(r=s);const i=this.reorderBuffer.splice(r,1)[0];this.presentationOrderPackets.push(i)}}flushReorderBuffer(){this.reorderBuffer.sort((e,r)=>e.pts-r.pts),this.presentationOrderPackets.push(...this.reorderBuffer),this.reorderBuffer.length=0}}class Ve{}class Hs extends Ve{async _getMajorBrand(e){let r=e._reader.requestSlice(0,12);return r instanceof Promise&&(r=await r),!r||(r.skip(4),re(r,4)!=="ftyp")?null:re(r,4)}_createDemuxer(e){return new wa(e)}}class fo extends Hs{async _canReadInput(e){const r=await this._getMajorBrand(e);return!!r&&r!=="qt  "}get name(){return"MP4"}get mimeType(){return"video/mp4"}}class mo extends Hs{async _canReadInput(e){return await this._getMajorBrand(e)==="qt  "}get name(){return"QuickTime File Format"}get mimeType(){return"video/quicktime"}}class qs extends Ve{async isSupportedEBMLOfDocType(e,r){let i=e._reader.requestSlice(0,Ne);if(i instanceof Promise&&(i=await i),!i)return!1;const s=Ds(i);if(s===null||s<1||s>8||N(i,s)!==S.EBML)return!1;const a=zs(i);if(typeof a!="number")return!1;let o=e._reader.requestSlice(i.filePos,a);if(o instanceof Promise&&(o=await o),!o)return!1;const c=i.filePos;for(;o.filePos<=c+a-pe;){const l=ze(o);if(!l)break;const{id:u,size:d}=l,h=o.filePos;if(d===void 0)return!1;switch(u){case S.EBMLVersion:if(N(o,d)!==1)return!1;break;case S.EBMLReadVersion:if(N(o,d)!==1)return!1;break;case S.DocType:if(gt(o,d)!==r)return!1;break;case S.DocTypeVersion:if(N(o,d)>4)return!1;break}o.filePos=h+d}return!0}_canReadInput(e){return this.isSupportedEBMLOfDocType(e,"matroska")}_createDemuxer(e){return new _a(e)}get name(){return"Matroska"}get mimeType(){return"video/x-matroska"}}class po extends qs{_canReadInput(e){return this.isSupportedEBMLOfDocType(e,"webm")}get name(){return"WebM"}get mimeType(){return"video/webm"}}class go extends Ve{async _canReadInput(e){let r=e._reader.requestSlice(0,10);if(r instanceof Promise&&(r=await r),!r)return!1;let i=0,s=!1;for(;;){let l=e._reader.requestSlice(i,hr);if(l instanceof Promise&&(l=await l),!l)break;const u=fr(l);if(!u)break;s=!0,i=l.filePos+u.size}const n=await Jr(e._reader,i,i+4096);if(!n)return!1;if(s)return!0;i=n.startPos+n.header.totalSize;const a=await Jr(e._reader,i,i+Lt);if(!a)return!1;const o=n.header,c=a.header;return!(o.channel!==c.channel||o.sampleRate!==c.sampleRate)}_createDemuxer(e){return new Va(e)}get name(){return"MP3"}get mimeType(){return"audio/mpeg"}}class ko extends Ve{async _canReadInput(e){let r=e._reader.requestSlice(0,12);if(r instanceof Promise&&(r=await r),!r)return!1;const i=re(r,4);return i!=="RIFF"&&i!=="RIFX"&&i!=="RF64"?!1:(r.skip(4),re(r,4)==="WAVE")}_createDemuxer(e){return new Xa(e)}get name(){return"WAVE"}get mimeType(){return"audio/wav"}}class bo extends Ve{async _canReadInput(e){let r=e._reader.requestSlice(0,4);return r instanceof Promise&&(r=await r),r?re(r,4)==="OggS":!1}_createDemuxer(e){return new Ka(e)}get name(){return"Ogg"}get mimeType(){return"application/ogg"}}class wo extends Ve{async _canReadInput(e){let r=e._reader.requestSlice(0,4);return r instanceof Promise&&(r=await r),r?re(r,4)==="fLaC":!1}get name(){return"FLAC"}get mimeType(){return"audio/flac"}_createDemuxer(e){return new ao(e)}}class yo extends Ve{async _canReadInput(e){let r=e._reader.requestSliceRange(0,mr,at);if(r instanceof Promise&&(r=await r),!r)return!1;const i=ct(r);if(!i||(r=e._reader.requestSliceRange(i.frameLength,mr,at),r instanceof Promise&&(r=await r),!r))return!1;const s=ct(r);return s?i.objectType===s.objectType&&i.samplingFrequencyIndex===s.samplingFrequencyIndex&&i.channelConfiguration===s.channelConfiguration:!1}_createDemuxer(e){return new Za(e)}get name(){return"ADTS"}get mimeType(){return"audio/aac"}}class To extends Ve{async _canReadInput(e){const r=ue+16+1;let i=e._reader.requestSlice(0,r);if(i instanceof Promise&&(i=await i),!i)return!1;const s=O(i,r);return s[0]===71&&s[ue]===71||s[0]===71&&s[ue+16]===71?!0:s[4]===71&&s[4+ue]===71}_createDemuxer(e){return new lo(e)}get name(){return"MPEG Transport Stream"}get mimeType(){return"video/MP2T"}}const So=new fo,Po=new mo,xo=new qs,Co=new po,vo=new go,Eo=new ko,Io=new bo,_o=new yo,Ao=new wo,Fo=new To,gl=[So,Po,xo,Co,Eo,Io,Ao,vo,_o,Fo];class js{constructor(){this._disposed=!1,this._sizePromise=null,this.onread=null}async getSizeOrNull(){if(this._disposed)throw new de;return this._sizePromise??=Promise.resolve(this._retrieveSize())}async getSize(){if(this._disposed)throw new de;const e=await this.getSizeOrNull();if(e===null)throw new Error("Cannot determine the size of an unsized source.");return e}}class kl extends js{constructor(e,r={}){if(!(e instanceof Blob))throw new TypeError("blob must be a Blob.");if(!r||typeof r!="object")throw new TypeError("options must be an object.");if(r.maxCacheSize!==void 0&&(!hs(r.maxCacheSize)||r.maxCacheSize<0))throw new TypeError("options.maxCacheSize, when provided, must be a non-negative number.");super(),this._readers=new WeakMap,this._blob=e,this._orchestrator=new Ro({maxCacheSize:r.maxCacheSize??8*2**20,maxWorkerCount:4,runWorker:this._runWorker.bind(this),prefetchProfile:Bo.fileSystem})}_retrieveSize(){const e=this._blob.size;return this._orchestrator.fileSize=e,e}_read(e,r){return this._orchestrator.read(e,r)}async _runWorker(e){let r=this._readers.get(e);for(r===void 0&&("stream"in this._blob&&!Nt()?r=this._blob.slice(e.currentPos).stream().getReader():r=null,this._readers.set(e,r));e.currentPos<e.targetPos&&!e.aborted;)if(r){const{done:i,value:s}=await r.read();if(i)throw this._orchestrator.forgetWorker(e),new Error("Blob reader stopped unexpectedly before all requested data was read.");if(e.aborted)break;this.onread?.(e.currentPos,e.currentPos+s.length),this._orchestrator.supplyWorkerData(e,s)}else{const i=await this._blob.slice(e.currentPos,e.targetPos).arrayBuffer();if(e.aborted)break;this.onread?.(e.currentPos,e.currentPos+i.byteLength),this._orchestrator.supplyWorkerData(e,new Uint8Array(i))}e.running=!1,e.aborted&&await r?.cancel()}_dispose(){this._orchestrator.dispose()}}const Bo={fileSystem:(t,e)=>(t=Math.floor((t-65536)/65536)*65536,e=Math.ceil((e+65536)/65536)*65536,{start:t,end:e})};class Ro{constructor(e){this.options=e,this.fileSize=null,this.nextAge=0,this.workers=[],this.cache=[],this.currentCacheSize=0,this.disposed=!1}read(e,r){m(this.fileSize!==null);const i=this.options.prefetchProfile(e,r,this.workers),s=Math.max(i.start,0),n=Math.min(i.end,this.fileSize);m(s<=e&&r<=n);let a=null;const o=L(this.cache,e,b=>b.start),c=o!==-1?this.cache[o]:null;c&&c.start<=e&&r<=c.end&&(c.age=this.nextAge++,a={bytes:c.bytes,view:c.view,offset:c.start});const l=L(this.cache,s,b=>b.start),u=a?null:new Uint8Array(r-e);let d=0,h=s;const f=[];if(l!==-1){for(let b=l;b<this.cache.length;b++){const y=this.cache[b];if(y.start>=n)break;if(y.end<=s)continue;const T=Math.max(s,y.start),x=Math.min(n,y.end);if(m(T<=x),h<T&&f.push({start:h,end:T}),h=x,u){const P=Math.max(e,y.start),_=Math.min(r,y.end);if(P<_){const C=P-e;u.set(y.bytes.subarray(P-y.start,_-y.start),C),C===d&&(d=_-e)}}y.age=this.nextAge++}h<n&&f.push({start:h,end:n})}else f.push({start:s,end:n});if(u&&d>=u.length&&(a={bytes:u,view:X(u),offset:e}),f.length===0)return m(a),a;const{promise:p,resolve:g,reject:k}=ne(),w=[];for(const b of f){const y=Math.max(e,b.start),T=Math.min(r,b.end);y===b.start&&T===b.end?w.push(b):y<T&&w.push({start:y,end:T})}for(const b of f){const y=u&&{start:e,bytes:u,holes:w,resolve:g,reject:k};let T=!1;for(const x of this.workers)if(Ri(b.start-131072,b.start,x.currentPos,x.targetPos)){x.targetPos=Math.max(x.targetPos,b.end),T=!0,y&&!x.pendingSlices.includes(y)&&x.pendingSlices.push(y),x.running||this.runWorker(x);break}if(!T){const x=this.createWorker(b.start,b.end);y&&(x.pendingSlices=[y]),this.runWorker(x)}}return a||(m(u),a=p.then(b=>({bytes:b,view:X(b),offset:e}))),a}createWorker(e,r){const i={startPos:e,currentPos:e,targetPos:r,running:!1,aborted:this.disposed,pendingSlices:[],age:this.nextAge++};for(this.workers.push(i);this.workers.length>this.options.maxWorkerCount;){let s=0,n=this.workers[0];for(let a=1;a<this.workers.length;a++){const o=this.workers[a];o.age<n.age&&(s=a,n=o)}if(n.running&&n.pendingSlices.length>0)break;n.aborted=!0,this.workers.splice(s,1)}return i}runWorker(e){m(!e.running),m(e.currentPos<e.targetPos),e.running=!0,e.age=this.nextAge++,this.options.runWorker(e).catch(r=>{if(e.running=!1,e.pendingSlices.length>0)e.pendingSlices.forEach(i=>i.reject(r)),e.pendingSlices.length=0;else throw r})}supplyWorkerData(e,r){m(!e.aborted);const i=e.currentPos,s=i+r.length;this.insertIntoCache({start:i,end:s,bytes:r,view:X(r),age:this.nextAge++}),e.currentPos+=r.length,e.targetPos=Math.max(e.targetPos,e.currentPos);for(let n=0;n<e.pendingSlices.length;n++){const a=e.pendingSlices[n],o=Math.max(i,a.start),c=Math.min(s,a.start+a.bytes.length);o<c&&a.bytes.set(r.subarray(o-i,c-i),o-a.start);for(let l=0;l<a.holes.length;l++){const u=a.holes[l];i<=u.start&&s>u.start&&(u.start=s),u.end<=u.start&&(a.holes.splice(l,1),l--)}a.holes.length===0&&(a.resolve(a.bytes),e.pendingSlices.splice(n,1),n--)}for(let n=0;n<this.workers.length;n++){const a=this.workers[n];e===a||a.running||Ri(i,s,a.currentPos,a.targetPos)&&(this.workers.splice(n,1),n--)}}forgetWorker(e){const r=this.workers.indexOf(e);m(r!==-1),this.workers.splice(r,1)}insertIntoCache(e){if(this.options.maxCacheSize===0)return;let r=L(this.cache,e.start,i=>i.start)+1;if(r>0){const i=this.cache[r-1];if(i.end>=e.end)return;if(i.end>e.start){const s=new Uint8Array(e.end-i.start);s.set(i.bytes,0),s.set(e.bytes,e.start-i.start),this.currentCacheSize+=e.end-i.end,i.bytes=s,i.view=X(s),i.end=e.end,r--,e=i}else this.cache.splice(r,0,e),this.currentCacheSize+=e.bytes.length}else this.cache.splice(r,0,e),this.currentCacheSize+=e.bytes.length;for(let i=r+1;i<this.cache.length;i++){const s=this.cache[i];if(e.end<=s.start)break;if(e.end>=s.end){this.cache.splice(i,1),this.currentCacheSize-=s.bytes.length,i--;continue}const n=new Uint8Array(s.end-e.start);n.set(e.bytes,0),n.set(s.bytes,s.start-e.start),this.currentCacheSize-=e.end-s.start,e.bytes=n,e.view=X(n),e.end=s.end,this.cache.splice(i,1);break}for(;this.currentCacheSize>this.options.maxCacheSize;){let i=0,s=this.cache[0];for(let n=1;n<this.cache.length;n++){const a=this.cache[n];a.age<s.age&&(i=n,s=a)}if(this.currentCacheSize-s.bytes.length<=this.options.maxCacheSize)break;this.cache.splice(i,1),this.currentCacheSize-=s.bytes.length}}dispose(){for(const e of this.workers)e.aborted=!0;this.workers.length=0,this.cache.length=0,this.disposed=!0}}ds();class Do{get disposed(){return this._disposed}constructor(e){if(this._demuxerPromise=null,this._format=null,this._disposed=!1,!e||typeof e!="object")throw new TypeError("options must be an object.");if(!Array.isArray(e.formats)||e.formats.some(r=>!(r instanceof Ve)))throw new TypeError("options.formats must be an array of InputFormat.");if(!(e.source instanceof js))throw new TypeError("options.source must be a Source.");if(e.source._disposed)throw new Error("options.source must not be disposed.");this._formats=e.formats,this._source=e.source,this._reader=new zo(e.source)}_getDemuxer(){return this._demuxerPromise??=(async()=>{this._reader.fileSize=await this._source.getSizeOrNull();for(const e of this._formats)if(await e._canReadInput(this))return this._format=e,e._createDemuxer(this);throw new Error("Input has an unsupported or unrecognizable format.")})()}get source(){return this._source}async getFormat(){return await this._getDemuxer(),m(this._format),this._format}async computeDuration(){return(await this._getDemuxer()).computeDuration()}async getFirstTimestamp(){const e=await this.getTracks();if(e.length===0)return 0;const r=await Promise.all(e.map(i=>i.getFirstTimestamp()));return Math.min(...r)}async getTracks(){return(await this._getDemuxer()).getTracks()}async getVideoTracks(){return(await this.getTracks()).filter(r=>r.isVideoTrack())}async getAudioTracks(){return(await this.getTracks()).filter(r=>r.isAudioTrack())}async getPrimaryVideoTrack(){return(await this.getTracks()).find(r=>r.isVideoTrack())??null}async getPrimaryAudioTrack(){return(await this.getTracks()).find(r=>r.isAudioTrack())??null}async getMimeType(){return(await this._getDemuxer()).getMimeType()}async getMetadataTags(){return(await this._getDemuxer()).getMetadataTags()}dispose(){this._disposed||(this._disposed=!0,this._source._disposed=!0,this._source._dispose())}[Symbol.dispose](){this.dispose()}}class de extends Error{constructor(e="Input has been disposed."){super(e),this.name="InputDisposedError"}}class zo{constructor(e){this.source=e}requestSlice(e,r){if(this.source._disposed)throw new de;if(e<0||this.fileSize!==null&&e+r>this.fileSize)return null;const i=e+r,s=this.source._read(e,i);return s instanceof Promise?s.then(n=>n?new ye(n.bytes,n.view,n.offset,e,i):null):s?new ye(s.bytes,s.view,s.offset,e,i):null}requestSliceRange(e,r,i){if(this.source._disposed)throw new de;if(e<0)return null;if(this.fileSize!==null)return this.requestSlice(e,te(this.fileSize-e,r,i));{const s=this.requestSlice(e,i),n=a=>{if(a)return a;const o=l=>(m(l!==null),this.requestSlice(e,te(l-e,r,i))),c=this.source._retrieveSize();return c instanceof Promise?c.then(o):o(c)};return s instanceof Promise?s.then(n):n(s)}}}class ye{constructor(e,r,i,s,n){this.bytes=e,this.view=r,this.offset=i,this.start=s,this.end=n,this.bufferPos=s-i}static tempFromBytes(e){return new ye(e,X(e),0,0,e.length)}get length(){return this.end-this.start}get filePos(){return this.offset+this.bufferPos}set filePos(e){this.bufferPos=e-this.offset}get remainingLength(){return Math.max(this.end-this.filePos,0)}skip(e){this.bufferPos+=e}slice(e,r=this.end-e){if(e<this.start||e+r>this.end)throw new RangeError("Slicing outside of original slice.");return new ye(this.bytes,this.view,this.offset,e,e+r)}}const le=(t,e)=>{if(t.filePos<t.start||t.filePos+e>t.end)throw new RangeError(`Tried reading [${t.filePos}, ${t.filePos+e}), but slice is [${t.start}, ${t.end}). This is likely an internal error, please report it alongside the file that caused it.`)},O=(t,e)=>{le(t,e);const r=t.bytes.subarray(t.bufferPos,t.bufferPos+e);return t.bufferPos+=e,r},F=t=>(le(t,1),t.view.getUint8(t.bufferPos++)),zt=(t,e)=>{le(t,2);const r=t.view.getUint16(t.bufferPos,e);return t.bufferPos+=2,r},ee=t=>{le(t,2);const e=t.view.getUint16(t.bufferPos,!1);return t.bufferPos+=2,e},wt=t=>{le(t,3);const e=kr(t.view,t.bufferPos,!1);return t.bufferPos+=3,e},ei=t=>{le(t,2);const e=t.view.getInt16(t.bufferPos,!1);return t.bufferPos+=2,e},Ke=(t,e)=>{le(t,4);const r=t.view.getUint32(t.bufferPos,e);return t.bufferPos+=4,r},I=t=>{le(t,4);const e=t.view.getUint32(t.bufferPos,!1);return t.bufferPos+=4,e},vt=t=>{le(t,4);const e=t.view.getUint32(t.bufferPos,!0);return t.bufferPos+=4,e},nt=t=>{le(t,4);const e=t.view.getInt32(t.bufferPos,!1);return t.bufferPos+=4,e},Mo=t=>{le(t,4);const e=t.view.getInt32(t.bufferPos,!0);return t.bufferPos+=4,e},Ki=(t,e)=>{let r,i;return e?(r=Ke(t,!0),i=Ke(t,!0)):(i=Ke(t,!1),r=Ke(t,!1)),i*4294967296+r},we=t=>{const e=I(t),r=I(t);return e*4294967296+r},Oo=t=>{const e=nt(t),r=I(t);return e*4294967296+r},No=t=>{const e=vt(t);return Mo(t)*4294967296+e},Uo=t=>{le(t,4);const e=t.view.getFloat32(t.bufferPos,!1);return t.bufferPos+=4,e},$s=t=>{le(t,8);const e=t.view.getFloat64(t.bufferPos,!1);return t.bufferPos+=8,e},re=(t,e)=>{le(t,e);let r="";for(let i=0;i<e;i++)r+=String.fromCharCode(t.bytes[t.bufferPos++]);return r};const Gi=/<(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})>/g,Vo=t=>{const e=Math.floor(t/36e5),r=Math.floor(t%(3600*1e3)/(60*1e3)),i=Math.floor(t%(60*1e3)/1e3),s=t%1e3;return e.toString().padStart(2,"0")+":"+r.toString().padStart(2,"0")+":"+i.toString().padStart(2,"0")+"."+s.toString().padStart(3,"0")};class Xi{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer),this.offsets=new WeakMap}writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeU64(e){this.helperView.setUint32(0,Math.floor(e/2**32),!1),this.helperView.setUint32(4,e,!1),this.writer.write(this.helper.subarray(0,8))}writeAscii(e){for(let r=0;r<e.length;r++)this.helperView.setUint8(r%8,e.charCodeAt(r)),r%8===7&&this.writer.write(this.helper);e.length%8!==0&&this.writer.write(this.helper.subarray(0,e.length%8))}writeBox(e){if(this.offsets.set(e,this.writer.getPos()),e.contents&&!e.children)this.writeBoxHeader(e,e.size??e.contents.byteLength+8),this.writer.write(e.contents);else{const r=this.writer.getPos();if(this.writeBoxHeader(e,0),e.contents&&this.writer.write(e.contents),e.children)for(const n of e.children)n&&this.writeBox(n);const i=this.writer.getPos(),s=e.size??i-r;this.writer.seek(r),this.writeBoxHeader(e,s),this.writer.seek(i)}}writeBoxHeader(e,r){this.writeU32(e.largeSize?1:r),this.writeAscii(e.type),e.largeSize&&this.writeU64(r)}measureBoxHeader(e){return 8+(e.largeSize?8:0)}patchBox(e){const r=this.offsets.get(e);m(r!==void 0);const i=this.writer.getPos();this.writer.seek(r),this.writeBox(e),this.writer.seek(i)}measureBox(e){if(e.contents&&!e.children)return this.measureBoxHeader(e)+e.contents.byteLength;{let r=this.measureBoxHeader(e);if(e.contents&&(r+=e.contents.byteLength),e.children)for(const i of e.children)i&&(r+=this.measureBox(i));return r}}}const U=new Uint8Array(8),Ae=new DataView(U.buffer),Y=t=>[(t%256+256)%256],B=t=>(Ae.setUint16(0,t,!1),[U[0],U[1]]),Qs=t=>(Ae.setInt16(0,t,!1),[U[0],U[1]]),Ks=t=>(Ae.setUint32(0,t,!1),[U[1],U[2],U[3]]),v=t=>(Ae.setUint32(0,t,!1),[U[0],U[1],U[2],U[3]]),je=t=>(Ae.setInt32(0,t,!1),[U[0],U[1],U[2],U[3]]),lt=t=>(Ae.setUint32(0,Math.floor(t/2**32),!1),Ae.setUint32(4,t,!1),[U[0],U[1],U[2],U[3],U[4],U[5],U[6],U[7]]),Gs=t=>(Ae.setInt16(0,2**8*t,!1),[U[0],U[1]]),Me=t=>(Ae.setInt32(0,2**16*t,!1),[U[0],U[1],U[2],U[3]]),zr=t=>(Ae.setInt32(0,2**30*t,!1),[U[0],U[1],U[2],U[3]]),Mr=(t,e)=>{const r=[];let i=t;do{let s=i&127;i>>=7,r.length>0&&(s|=128),r.push(s)}while(i>0||e);return r.reverse()},se=(t,e=!1)=>{const r=Array(t.length).fill(null).map((i,s)=>t.charCodeAt(s));return e&&r.push(0),r},Ti=t=>{let e=null;for(const r of t)(!e||r.timestamp>e.timestamp)&&(e=r);return e},Xs=t=>{const e=t*(Math.PI/180),r=Math.round(Math.cos(e)),i=Math.round(Math.sin(e));return[r,i,0,-i,r,0,0,0,1]},Ys=Xs(0),Zs=t=>[Me(t[0]),Me(t[1]),zr(t[2]),Me(t[3]),Me(t[4]),zr(t[5]),Me(t[6]),Me(t[7]),zr(t[8])],D=(t,e,r)=>({type:t,contents:e&&new Uint8Array(e.flat(10)),children:r}),V=(t,e,r,i,s)=>D(t,[Y(e),Ks(r),i??[]],s),Lo=t=>t.isQuickTime?D("ftyp",[se("qt  "),v(512),se("qt  ")]):t.fragmented?D("ftyp",[se("iso5"),v(512),se("iso5"),se("iso6"),se("mp41")]):D("ftyp",[se("isom"),v(512),se("isom"),t.holdsAvc?se("avc1"):[],se("mp41")]),ir=t=>({type:"mdat",largeSize:t}),Wo=t=>({type:"free",size:t}),Mt=t=>D("moov",void 0,[Ho(t.creationTime,t.trackDatas),...t.trackDatas.map(e=>qo(e,t.creationTime)),t.isFragmented?Cc(t.trackDatas):null,Nc(t)]),Ho=(t,e)=>{const r=J(Math.max(0,...e.filter(a=>a.samples.length>0).map(a=>{const o=Ti(a.samples);return o.timestamp+o.duration})),ti),i=Math.max(0,...e.map(a=>a.track.id))+1,s=!At(t)||!At(r),n=s?lt:v;return V("mvhd",+s,0,[n(t),n(t),v(ti),n(r),Me(1),Gs(1),Array(10).fill(0),Zs(Ys),Array(24).fill(0),v(i)])},qo=(t,e)=>{const r=Yc(t);return D("trak",void 0,[jo(t,e),$o(t,e),r.name!==void 0?D("udta",void 0,[D("name",[...ve.encode(r.name)])]):null])},jo=(t,e)=>{const r=Ti(t.samples),i=J(r?r.timestamp+r.duration:0,ti),s=!At(e)||!At(i),n=s?lt:v;let a;if(t.type==="video"){const c=t.track.metadata.rotation;a=Xs(c??0)}else a=Ys;let o=2;return t.track.metadata.disposition?.default!==!1&&(o|=1),V("tkhd",+s,o,[n(e),n(e),v(t.track.id),v(0),n(i),Array(8).fill(0),B(0),B(t.track.id),Gs(t.type==="audio"?1:0),B(0),Zs(a),Me(t.type==="video"?t.info.width:0),Me(t.type==="video"?t.info.height:0)])},$o=(t,e)=>D("mdia",void 0,[Qo(t,e),Si(!0,Ko[t.type],Go[t.type]),Xo(t)]),Qo=(t,e)=>{const r=Ti(t.samples),i=J(r?r.timestamp+r.duration:0,t.timescale),s=!At(e)||!At(i),n=s?lt:v;return V("mdhd",+s,0,[n(e),n(e),v(t.timescale),n(i),B(rn(t.track.metadata.languageCode??he)),B(0)])},Ko={video:"vide",audio:"soun",subtitle:"text"},Go={video:"MediabunnyVideoHandler",audio:"MediabunnySoundHandler",subtitle:"MediabunnyTextHandler"},Si=(t,e,r,i="\0\0\0\0")=>V("hdlr",0,0,[t?se("mhlr"):v(0),se(e),se(i),v(0),v(0),se(r,!0)]),Xo=t=>D("minf",void 0,[ec[t.type](),tc(),sc(t)]),Yo=()=>V("vmhd",0,1,[B(0),B(0),B(0),B(0)]),Zo=()=>V("smhd",0,0,[B(0),B(0)]),Jo=()=>V("nmhd",0,0),ec={video:Yo,audio:Zo,subtitle:Jo},tc=()=>D("dinf",void 0,[rc()]),rc=()=>V("dref",0,0,[v(1)],[ic()]),ic=()=>V("url ",0,1),sc=t=>{const e=t.compositionTimeOffsetTable.length>1||t.compositionTimeOffsetTable.some(r=>r.sampleCompositionTimeOffset!==0);return D("stbl",void 0,[nc(t),bc(t),e?Pc(t):null,e?xc(t):null,yc(t),Tc(t),Sc(t),wc(t)])},nc=t=>{let e;if(t.type==="video")e=ac(Wc(t.track.source._codec,t.info.decoderConfig.codec),t);else if(t.type==="audio"){const r=tn(t.track.source._codec,t.muxer.isQuickTime);m(r),e=dc(r,t)}else t.type==="subtitle"&&(e=gc(jc[t.track.source._codec],t));return m(e),V("stsd",0,0,[v(1)],[e])},ac=(t,e)=>D(t,[Array(6).fill(0),B(1),B(0),B(0),Array(12).fill(0),B(e.info.width),B(e.info.height),v(4718592),v(4718592),v(0),B(1),Array(32).fill(0),B(24),Qs(65535)],[Hc[e.track.source._codec](e),kn(e.info.decoderConfig.colorSpace)?oc(e):null]),oc=t=>D("colr",[se("nclx"),B(Gt[t.info.decoderConfig.colorSpace.primaries]),B(Xt[t.info.decoderConfig.colorSpace.transfer]),B(Yt[t.info.decoderConfig.colorSpace.matrix]),Y((t.info.decoderConfig.colorSpace.fullRange?1:0)<<7)]),cc=t=>t.info.decoderConfig&&D("avcC",[...fe(t.info.decoderConfig.description)]),lc=t=>t.info.decoderConfig&&D("hvcC",[...fe(t.info.decoderConfig.description)]),Yi=t=>{if(!t.info.decoderConfig)return null;const e=t.info.decoderConfig,r=e.codec.split("."),i=Number(r[1]),s=Number(r[2]),n=Number(r[3]),a=r[4]?Number(r[4]):1,o=r[8]?Number(r[8]):Number(e.colorSpace?.fullRange??0),c=(n<<4)+(a<<1)+o,l=r[5]?Number(r[5]):e.colorSpace?.primaries?Gt[e.colorSpace.primaries]:2,u=r[6]?Number(r[6]):e.colorSpace?.transfer?Xt[e.colorSpace.transfer]:2,d=r[7]?Number(r[7]):e.colorSpace?.matrix?Yt[e.colorSpace.matrix]:2;return V("vpcC",1,0,[Y(i),Y(s),Y(c),Y(l),Y(u),Y(d),B(0)])},uc=t=>D("av1C",_n(t.info.decoderConfig.codec)),dc=(t,e)=>{let r=0,i,s=16;if(ce.includes(e.track.source._codec)){const n=e.track.source._codec,{sampleSize:a}=Ze(n);s=8*a,s>16&&(r=1)}return r===0?i=[Array(6).fill(0),B(1),B(r),B(0),v(0),B(e.info.numberOfChannels),B(s),B(0),B(0),B(e.info.sampleRate<2**16?e.info.sampleRate:0),B(0)]:i=[Array(6).fill(0),B(1),B(r),B(0),v(0),B(e.info.numberOfChannels),B(Math.min(s,16)),B(0),B(0),B(e.info.sampleRate<2**16?e.info.sampleRate:0),B(0),v(1),v(s/8),v(e.info.numberOfChannels*s/8),v(2)],D(t,i,[qc(e.track.source._codec,e.muxer.isQuickTime)?.(e)??null])},Or=t=>{let e;switch(t.track.source._codec){case"aac":e=64;break;case"mp3":e=107;break;case"vorbis":e=221;break;default:throw new Error(`Unhandled audio codec: ${t.track.source._codec}`)}let r=[...Y(e),...Y(21),...Ks(0),...v(0),...v(0)];if(t.info.decoderConfig.description){const i=fe(t.info.decoderConfig.description);r=[...r,...Y(5),...Mr(i.byteLength),...i]}return r=[...B(1),...Y(0),...Y(4),...Mr(r.length),...r,...Y(6),...Y(1),...Y(2)],r=[...Y(3),...Mr(r.length),...r],V("esds",0,0,r)},We=t=>D("wave",void 0,[hc(t),fc(t),D("\0\0\0\0")]),hc=t=>D("frma",[se(tn(t.track.source._codec,t.muxer.isQuickTime))]),fc=t=>{const{littleEndian:e}=Ze(t.track.source._codec);return D("enda",[B(+e)])},mc=t=>{let e=t.info.numberOfChannels,r=3840,i=t.info.sampleRate,s=0,n=0,a=new Uint8Array(0);const o=t.info.decoderConfig?.description;if(o){m(o.byteLength>=18);const c=fe(o),l=Cs(c);e=l.outputChannelCount,r=l.preSkip,i=l.inputSampleRate,s=l.outputGain,n=l.channelMappingFamily,l.channelMappingTable&&(a=l.channelMappingTable)}return D("dOps",[Y(0),Y(e),B(r),v(i),Qs(s),Y(n),...a])},pc=t=>{const e=t.info.decoderConfig?.description;m(e);const r=fe(e);return V("dfLa",0,0,[...r.subarray(4)])},xe=t=>{const{littleEndian:e,sampleSize:r}=Ze(t.track.source._codec),i=+e;return V("pcmC",0,0,[Y(i),Y(8*r)])},gc=(t,e)=>D(t,[Array(6).fill(0),B(1)],[$c[e.track.source._codec](e)]),kc=t=>D("vttC",[...ve.encode(t.info.config.description)]),bc=t=>V("stts",0,0,[v(t.timeToSampleTable.length),t.timeToSampleTable.map(e=>[v(e.sampleCount),v(e.sampleDelta)])]),wc=t=>{if(t.samples.every(r=>r.type==="key"))return null;const e=[...t.samples.entries()].filter(([,r])=>r.type==="key");return V("stss",0,0,[v(e.length),e.map(([r])=>v(r+1))])},yc=t=>V("stsc",0,0,[v(t.compactlyCodedChunkTable.length),t.compactlyCodedChunkTable.map(e=>[v(e.firstChunk),v(e.samplesPerChunk),v(1)])]),Tc=t=>{if(t.type==="audio"&&t.info.requiresPcmTransformation){const{sampleSize:e}=Ze(t.track.source._codec);return V("stsz",0,0,[v(e*t.info.numberOfChannels),v(t.samples.reduce((r,i)=>r+J(i.duration,t.timescale),0))])}return V("stsz",0,0,[v(0),v(t.samples.length),t.samples.map(e=>v(e.size))])},Sc=t=>t.finalizedChunks.length>0&&G(t.finalizedChunks).offset>=2**32?V("co64",0,0,[v(t.finalizedChunks.length),t.finalizedChunks.map(e=>lt(e.offset))]):V("stco",0,0,[v(t.finalizedChunks.length),t.finalizedChunks.map(e=>v(e.offset))]),Pc=t=>V("ctts",1,0,[v(t.compositionTimeOffsetTable.length),t.compositionTimeOffsetTable.map(e=>[v(e.sampleCount),je(e.sampleCompositionTimeOffset)])]),xc=t=>{let e=1/0,r=-1/0,i=1/0,s=-1/0;m(t.compositionTimeOffsetTable.length>0),m(t.samples.length>0);for(let a=0;a<t.compositionTimeOffsetTable.length;a++){const o=t.compositionTimeOffsetTable[a];e=Math.min(e,o.sampleCompositionTimeOffset),r=Math.max(r,o.sampleCompositionTimeOffset)}for(let a=0;a<t.samples.length;a++){const o=t.samples[a];i=Math.min(i,J(o.timestamp,t.timescale)),s=Math.max(s,J(o.timestamp+o.duration,t.timescale))}const n=Math.max(-e,0);return s>=2**31?null:V("cslg",0,0,[je(n),je(e),je(r),je(i),je(s)])},Cc=t=>D("mvex",void 0,t.map(vc)),vc=t=>V("trex",0,0,[v(t.track.id),v(1),v(0),v(0),v(0)]),Zi=(t,e)=>D("moof",void 0,[Ec(t),...e.map(Ic)]),Ec=t=>V("mfhd",0,0,[v(t)]),Js=t=>{let e=0,r=0;const i=0,s=0,n=t.type==="delta";return r|=+n,n?e|=1:e|=2,e<<24|r<<16|i<<8|s},Ic=t=>D("traf",void 0,[_c(t),Ac(t),Fc(t)]),_c=t=>{m(t.currentChunk);let e=0;e|=8,e|=16,e|=32,e|=131072;const r=t.currentChunk.samples[1]??t.currentChunk.samples[0],i={duration:r.timescaleUnitsToNextSample,size:r.size,flags:Js(r)};return V("tfhd",0,e,[v(t.track.id),v(i.duration),v(i.size),v(i.flags)])},Ac=t=>(m(t.currentChunk),V("tfdt",1,0,[lt(J(t.currentChunk.startTimestamp,t.timescale))])),Fc=t=>{m(t.currentChunk);const e=t.currentChunk.samples.map(g=>g.timescaleUnitsToNextSample),r=t.currentChunk.samples.map(g=>g.size),i=t.currentChunk.samples.map(Js),s=t.currentChunk.samples.map(g=>J(g.timestamp-g.decodeTimestamp,t.timescale)),n=new Set(e),a=new Set(r),o=new Set(i),c=new Set(s),l=o.size===2&&i[0]!==i[1],u=n.size>1,d=a.size>1,h=!l&&o.size>1,f=c.size>1||[...c].some(g=>g!==0);let p=0;return p|=1,p|=4*+l,p|=256*+u,p|=512*+d,p|=1024*+h,p|=2048*+f,V("trun",1,p,[v(t.currentChunk.samples.length),v(t.currentChunk.offset-t.currentChunk.moofOffset||0),l?v(i[0]):[],t.currentChunk.samples.map((g,k)=>[u?v(e[k]):[],d?v(r[k]):[],h?v(i[k]):[],f?je(s[k]):[]])])},Bc=t=>D("mfra",void 0,[...t.map(Rc),Dc()]),Rc=(t,e)=>V("tfra",1,0,[v(t.track.id),v(63),v(t.finalizedChunks.length),t.finalizedChunks.map(i=>[lt(J(i.samples[0].timestamp,t.timescale)),lt(i.moofOffset),v(e+1),v(1),v(1)])]),Dc=()=>V("mfro",0,0,[v(0)]),zc=()=>D("vtte"),Mc=(t,e,r,i,s)=>D("vttc",void 0,[s!==null?D("vsid",[je(s)]):null,r!==null?D("iden",[...ve.encode(r)]):null,e!==null?D("ctim",[...ve.encode(Vo(e))]):null,i!==null?D("sttg",[...ve.encode(i)]):null,D("payl",[...ve.encode(t)])]),Oc=t=>D("vtta",[...ve.encode(t)]),Nc=t=>{const e=[],r=t.format._options.metadataFormat??"auto",i=t.output._metadataTags;if(r==="mdir"||r==="auto"&&!t.isQuickTime){const s=Vc(i);s&&e.push(s)}else if(r==="mdta"){const s=Lc(i);s&&e.push(s)}else(r==="udta"||r==="auto"&&t.isQuickTime)&&Uc(e,t.output._metadataTags);return e.length===0?null:D("udta",void 0,e)},Uc=(t,e)=>{for(const{key:r,value:i}of us(e))switch(r){case"title":t.push(Ce("nam",i));break;case"description":t.push(Ce("des",i));break;case"artist":t.push(Ce("ART",i));break;case"album":t.push(Ce("alb",i));break;case"albumArtist":t.push(Ce("albr",i));break;case"genre":t.push(Ce("gen",i));break;case"date":t.push(Ce("day",i.toISOString().slice(0,10)));break;case"comment":t.push(Ce("cmt",i));break;case"lyrics":t.push(Ce("lyr",i));break;case"raw":break;case"discNumber":case"discsTotal":case"trackNumber":case"tracksTotal":case"images":break;default:Xe(r)}if(e.raw)for(const r in e.raw){const i=e.raw[r];i==null||r.length!==4||t.some(s=>s.type===r)||(typeof i=="string"?t.push(Ce(r,i)):i instanceof Uint8Array&&t.push(D(r,Array.from(i))))}},Ce=(t,e)=>{const r=ve.encode(e);return D(t,[B(r.length),B(rn("und")),Array.from(r)])},Ji={"image/jpeg":13,"image/png":14,"image/bmp":27},en=(t,e)=>{const r=[];for(const{key:i,value:s}of us(t))switch(i){case"title":r.push({key:e?"title":"nam",value:be(s)});break;case"description":r.push({key:e?"description":"des",value:be(s)});break;case"artist":r.push({key:e?"artist":"ART",value:be(s)});break;case"album":r.push({key:e?"album":"alb",value:be(s)});break;case"albumArtist":r.push({key:e?"album_artist":"aART",value:be(s)});break;case"comment":r.push({key:e?"comment":"cmt",value:be(s)});break;case"genre":r.push({key:e?"genre":"gen",value:be(s)});break;case"lyrics":r.push({key:e?"lyrics":"lyr",value:be(s)});break;case"date":r.push({key:e?"date":"day",value:be(s.toISOString().slice(0,10))});break;case"images":for(const n of s)n.kind==="coverFront"&&r.push({key:"covr",value:D("data",[v(Ji[n.mimeType]??0),v(0),Array.from(n.data)])});break;case"trackNumber":if(e){const n=t.tracksTotal!==void 0?`${s}/${t.tracksTotal}`:s.toString();r.push({key:"track",value:be(n)})}else r.push({key:"trkn",value:D("data",[v(0),v(0),B(0),B(s),B(t.tracksTotal??0),B(0)])});break;case"discNumber":e||r.push({key:"disc",value:D("data",[v(0),v(0),B(0),B(s),B(t.discsTotal??0),B(0)])});break;case"tracksTotal":case"discsTotal":break;case"raw":break;default:Xe(i)}if(t.raw)for(const i in t.raw){const s=t.raw[i];s==null||!e&&i.length!==4||r.some(n=>n.key===i)||(typeof s=="string"?r.push({key:i,value:be(s)}):s instanceof Uint8Array?r.push({key:i,value:D("data",[v(0),v(0),Array.from(s)])}):s instanceof Et&&r.push({key:i,value:D("data",[v(Ji[s.mimeType]??0),v(0),Array.from(s.data)])}))}return r},Vc=t=>{const e=en(t,!1);return e.length===0?null:V("meta",0,0,void 0,[Si(!1,"mdir","","appl"),D("ilst",void 0,e.map(r=>D(r.key,void 0,[r.value])))])},Lc=t=>{const e=en(t,!0);return e.length===0?null:D("meta",void 0,[Si(!1,"mdta",""),V("keys",0,0,[v(e.length)],e.map(r=>D("mdta",[...ve.encode(r.key)]))),D("ilst",void 0,e.map((r,i)=>{const s=String.fromCharCode(...v(i+1));return D(s,void 0,[r.value])}))])},be=t=>D("data",[v(1),v(0),...ve.encode(t)]),Wc=(t,e)=>{switch(t){case"avc":return e.startsWith("avc3")?"avc3":"avc1";case"hevc":return"hvc1";case"vp8":return"vp08";case"vp9":return"vp09";case"av1":return"av01"}},Hc={avc:cc,hevc:lc,vp8:Yi,vp9:Yi,av1:uc},tn=(t,e)=>{switch(t){case"aac":return"mp4a";case"mp3":return"mp4a";case"opus":return"Opus";case"vorbis":return"mp4a";case"flac":return"fLaC";case"ulaw":return"ulaw";case"alaw":return"alaw";case"pcm-u8":return"raw ";case"pcm-s8":return"sowt"}if(e)switch(t){case"pcm-s16":return"sowt";case"pcm-s16be":return"twos";case"pcm-s24":return"in24";case"pcm-s24be":return"in24";case"pcm-s32":return"in32";case"pcm-s32be":return"in32";case"pcm-f32":return"fl32";case"pcm-f32be":return"fl32";case"pcm-f64":return"fl64";case"pcm-f64be":return"fl64"}else switch(t){case"pcm-s16":return"ipcm";case"pcm-s16be":return"ipcm";case"pcm-s24":return"ipcm";case"pcm-s24be":return"ipcm";case"pcm-s32":return"ipcm";case"pcm-s32be":return"ipcm";case"pcm-f32":return"fpcm";case"pcm-f32be":return"fpcm";case"pcm-f64":return"fpcm";case"pcm-f64be":return"fpcm"}},qc=(t,e)=>{switch(t){case"aac":return Or;case"mp3":return Or;case"opus":return mc;case"vorbis":return Or;case"flac":return pc}if(e)switch(t){case"pcm-s24":return We;case"pcm-s24be":return We;case"pcm-s32":return We;case"pcm-s32be":return We;case"pcm-f32":return We;case"pcm-f32be":return We;case"pcm-f64":return We;case"pcm-f64be":return We}else switch(t){case"pcm-s16":return xe;case"pcm-s16be":return xe;case"pcm-s24":return xe;case"pcm-s24be":return xe;case"pcm-s32":return xe;case"pcm-s32be":return xe;case"pcm-f32":return xe;case"pcm-f32be":return xe;case"pcm-f64":return xe;case"pcm-f64be":return xe}return null},jc={webvtt:"wvtt"},$c={webvtt:kc},rn=t=>{m(t.length===3);let e=0;for(let r=0;r<3;r++)e<<=5,e+=t.charCodeAt(r)-96;return e};class sn{constructor(){this.ensureMonotonicity=!1,this.trackedWrites=null,this.trackedStart=-1,this.trackedEnd=-1}start(){}maybeTrackWrites(e){if(!this.trackedWrites)return;let r=this.getPos();if(r<this.trackedStart){if(r+e.byteLength<=this.trackedStart)return;e=e.subarray(this.trackedStart-r),r=0}const i=r+e.byteLength-this.trackedStart;let s=this.trackedWrites.byteLength;for(;s<i;)s*=2;if(s!==this.trackedWrites.byteLength){const n=new Uint8Array(s);n.set(this.trackedWrites,0),this.trackedWrites=n}this.trackedWrites.set(e,r-this.trackedStart),this.trackedEnd=Math.max(this.trackedEnd,r+e.byteLength)}startTrackingWrites(){this.trackedWrites=new Uint8Array(2**10),this.trackedStart=this.getPos(),this.trackedEnd=this.trackedStart}stopTrackingWrites(){if(!this.trackedWrites)throw new Error("Internal error: Can't get tracked writes since nothing was tracked.");const r={data:this.trackedWrites.subarray(0,this.trackedEnd-this.trackedStart),start:this.trackedStart,end:this.trackedEnd};return this.trackedWrites=null,r}}const Nr=2**16,Ur=2**32;class nn extends sn{constructor(e){if(super(),this.pos=0,this.maxPos=0,this.target=e,this.supportsResize="resize"in new ArrayBuffer(0),this.supportsResize)try{this.buffer=new ArrayBuffer(Nr,{maxByteLength:Ur})}catch{this.buffer=new ArrayBuffer(Nr),this.supportsResize=!1}else this.buffer=new ArrayBuffer(Nr);this.bytes=new Uint8Array(this.buffer)}ensureSize(e){let r=this.buffer.byteLength;for(;r<e;)r*=2;if(r!==this.buffer.byteLength){if(r>Ur)throw new Error(`ArrayBuffer exceeded maximum size of ${Ur} bytes. Please consider using another target.`);if(this.supportsResize)this.buffer.resize(r);else{const i=new ArrayBuffer(r),s=new Uint8Array(i);s.set(this.bytes,0),this.buffer=i,this.bytes=s}}}write(e){this.maybeTrackWrites(e),this.ensureSize(this.pos+e.byteLength),this.bytes.set(e,this.pos),this.target.onwrite?.(this.pos,this.pos+e.byteLength),this.pos+=e.byteLength,this.maxPos=Math.max(this.maxPos,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){}async finalize(){this.ensureSize(this.pos),this.target.buffer=this.buffer.slice(0,Math.max(this.maxPos,this.pos))}async close(){}getSlice(e,r){return this.bytes.slice(e,r)}}class Qc extends sn{constructor(e){super(),this.target=e,this.pos=0}write(e){this.maybeTrackWrites(e),this.target.onwrite?.(this.pos,this.pos+e.byteLength),this.pos+=e.byteLength}getPos(){return this.pos}seek(e){this.pos=e}async flush(){}async finalize(){}async close(){}}class Pi{constructor(){this._output=null,this.onwrite=null}}class Kc extends Pi{constructor(){super(...arguments),this.buffer=null}_createWriter(){return new nn(this)}}class Gc extends Pi{_createWriter(){return new Qc(this)}}const ti=1e3,Xc=2082844800,Yc=t=>{const e={},r=t.track;return r.metadata.name!==void 0&&(e.name=r.metadata.name),e},J=(t,e,r=!0)=>{const i=t*e;return r?Math.round(i):i};class Zc extends Wn{constructor(e,r){super(e),this.auxTarget=new Kc,this.auxWriter=this.auxTarget._createWriter(),this.auxBoxWriter=new Xi(this.auxWriter),this.mdat=null,this.ftypSize=null,this.trackDatas=[],this.allTracksKnown=ne(),this.creationTime=Math.floor(Date.now()/1e3)+Xc,this.finalizedChunks=[],this.nextFragmentNumber=1,this.maxWrittenTimestamp=-1/0,this.format=r,this.writer=e._writer,this.boxWriter=new Xi(this.writer),this.isQuickTime=r instanceof ln;const i=this.writer instanceof nn?"in-memory":!1;this.fastStart=r._options.fastStart??i,this.isFragmented=this.fastStart==="fragmented",(this.fastStart==="in-memory"||this.isFragmented)&&(this.writer.ensureMonotonicity=!0),this.minimumFragmentDuration=r._options.minimumFragmentDuration??1}async start(){const e=await this.mutex.acquire(),r=this.output._tracks.some(i=>i.type==="video"&&i.source._codec==="avc");if(this.format._options.onFtyp&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(Lo({isQuickTime:this.isQuickTime,holdsAvc:r,fragmented:this.isFragmented})),this.format._options.onFtyp){const{data:i,start:s}=this.writer.stopTrackingWrites();this.format._options.onFtyp(i,s)}if(this.ftypSize=this.writer.getPos(),this.fastStart!=="in-memory")if(this.fastStart==="reserve"){for(const i of this.output._tracks)if(i.metadata.maximumPacketCount===void 0)throw new Error("All tracks must specify maximumPacketCount in their metadata when using fastStart: 'reserve'.")}else this.isFragmented||(this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=ir(!0),this.boxWriter.writeBox(this.mdat));await this.writer.flush(),e()}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(r=>r.track===e))return!1;return!0}async getMimeType(){await this.allTracksKnown.promise;const e=this.trackDatas.map(r=>r.type==="video"||r.type==="audio"?r.info.decoderConfig.codec:{webvtt:"wvtt"}[r.track.source._codec]);return Bs({isQuickTime:this.isQuickTime,hasVideo:this.trackDatas.some(r=>r.type==="video"),hasAudio:this.trackDatas.some(r=>r.type==="audio"),codecStrings:e})}getVideoTrackData(e,r,i){const s=this.trackDatas.find(l=>l.track===e);if(s)return s;Nn(i),m(i),m(i.decoderConfig);const n={...i.decoderConfig};m(n.codedWidth!==void 0),m(n.codedHeight!==void 0);let a=!1;if(e.source._codec==="avc"&&!n.description){const l=di(r.data);if(!l)throw new Error("Couldn't extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in AVCC format.");n.description=$n(l),a=!0}else if(e.source._codec==="hevc"&&!n.description){const l=fi(r.data);if(!l)throw new Error("Couldn't extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in HEVC format.");n.description=ta(l),a=!0}const o=xn(1/(e.metadata.frameRate??57600),1e6).denominator,c={muxer:this,track:e,type:"video",info:{width:n.codedWidth,height:n.codedHeight,decoderConfig:n,requiresAnnexBTransformation:a},timescale:o,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(c),this.trackDatas.sort((l,u)=>l.track.id-u.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),c}getAudioTrackData(e,r,i){const s=this.trackDatas.find(c=>c.track===e);if(s)return s;Vn(i),m(i),m(i.decoderConfig);const n={...i.decoderConfig};let a=!1;if(e.source._codec==="aac"&&!n.description){const c=ct(ye.tempFromBytes(r.data));if(!c)throw new Error("Couldn't parse ADTS header from the AAC packet. Make sure the packets are in ADTS format (as specified in ISO 13818-7) when not providing a description, or provide a description (must be an AudioSpecificConfig as specified in ISO 14496-3) and ensure the packets are raw AAC data.");const l=ot[c.samplingFrequencyIndex],u=Jt[c.channelConfiguration];if(l===void 0||u===void 0)throw new Error("Invalid ADTS frame header.");n.description=ms({objectType:c.objectType,sampleRate:l,numberOfChannels:u}),a=!0}const o={muxer:this,track:e,type:"audio",info:{numberOfChannels:i.decoderConfig.numberOfChannels,sampleRate:i.decoderConfig.sampleRate,decoderConfig:n,requiresPcmTransformation:!this.isFragmented&&ce.includes(e.source._codec),requiresAdtsStripping:a},timescale:i.decoderConfig.sampleRate,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(o),this.trackDatas.sort((c,l)=>c.track.id-l.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),o}getSubtitleTrackData(e,r){const i=this.trackDatas.find(n=>n.track===e);if(i)return i;Ln(r),m(r),m(r.config);const s={muxer:this,track:e,type:"subtitle",info:{config:r.config},timescale:1e3,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[],lastCueEndTimestamp:0,cueQueue:[],nextSourceId:0,cueToSourceId:new WeakMap};return this.trackDatas.push(s),this.trackDatas.sort((n,a)=>n.track.id-a.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),s}async addEncodedVideoPacket(e,r,i){const s=await this.mutex.acquire();try{const n=this.getVideoTrackData(e,r,i);let a=r.data;if(n.info.requiresAnnexBTransformation){const l=[...er(a)].map(u=>a.subarray(u.offset,u.offset+u.length));if(l.length===0)throw new Error("Failed to transform packet data. Make sure all packets are provided in Annex B format, as specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.");a=ws(l,4)}const o=this.validateAndNormalizeTimestamp(n.track,r.timestamp,r.type==="key"),c=this.createSampleForTrack(n,a,o,r.duration,r.type);await this.registerSample(n,c)}finally{s()}}async addEncodedAudioPacket(e,r,i){const s=await this.mutex.acquire();try{const n=this.getAudioTrackData(e,r,i);let a=r.data;if(n.info.requiresAdtsStripping){const l=ct(ye.tempFromBytes(a));if(!l)throw new Error("Expected ADTS frame, didn't get one.");const u=l.crcCheck===null?mr:at;a=a.subarray(u)}const o=this.validateAndNormalizeTimestamp(n.track,r.timestamp,r.type==="key"),c=this.createSampleForTrack(n,a,o,r.duration,r.type);n.info.requiresPcmTransformation&&await this.maybePadWithSilence(n,o),await this.registerSample(n,c)}finally{s()}}async maybePadWithSilence(e,r){const i=G(e.samples),s=i?i.timestamp+i.duration:0,n=r-s,a=J(n,e.timescale);if(a>0){const{sampleSize:o,silentValue:c}=Ze(e.info.decoderConfig.codec),l=a*e.info.numberOfChannels,u=new Uint8Array(o*l).fill(c),d=this.createSampleForTrack(e,new Uint8Array(u.buffer),s,n,"key");await this.registerSample(e,d)}}async addSubtitleCue(e,r,i){const s=await this.mutex.acquire();try{const n=this.getSubtitleTrackData(e,i);this.validateAndNormalizeTimestamp(n.track,r.timestamp,!0),e.source._codec==="webvtt"&&(n.cueQueue.push(r),await this.processWebVTTCues(n,r.timestamp))}finally{s()}}async processWebVTTCues(e,r){for(;e.cueQueue.length>0;){const i=new Set([]);for(const l of e.cueQueue)m(l.timestamp<=r),m(e.lastCueEndTimestamp<=l.timestamp+l.duration),i.add(Math.max(l.timestamp,e.lastCueEndTimestamp)),i.add(l.timestamp+l.duration);const s=[...i].sort((l,u)=>l-u),n=s[0],a=s[1]??n;if(r<a)break;if(e.lastCueEndTimestamp<n){this.auxWriter.seek(0);const l=zc();this.auxBoxWriter.writeBox(l);const u=this.auxWriter.getSlice(0,this.auxWriter.getPos()),d=this.createSampleForTrack(e,u,e.lastCueEndTimestamp,n-e.lastCueEndTimestamp,"key");await this.registerSample(e,d),e.lastCueEndTimestamp=n}this.auxWriter.seek(0);for(let l=0;l<e.cueQueue.length;l++){const u=e.cueQueue[l];if(u.timestamp>=a)break;Gi.lastIndex=0;const d=Gi.test(u.text),h=u.timestamp+u.duration;let f=e.cueToSourceId.get(u);if(f===void 0&&a<h&&(f=e.nextSourceId++,e.cueToSourceId.set(u,f)),u.notes){const g=Oc(u.notes);this.auxBoxWriter.writeBox(g)}const p=Mc(u.text,d?n:null,u.identifier??null,u.settings??null,f??null);this.auxBoxWriter.writeBox(p),h===a&&e.cueQueue.splice(l--,1)}const o=this.auxWriter.getSlice(0,this.auxWriter.getPos()),c=this.createSampleForTrack(e,o,n,a-n,"key");await this.registerSample(e,c),e.lastCueEndTimestamp=a}}createSampleForTrack(e,r,i,s,n){return{timestamp:i,decodeTimestamp:i,duration:s,data:r,size:r.byteLength,type:n,timescaleUnitsToNextSample:J(s,e.timescale)}}processTimestamps(e,r){if(e.timestampProcessingQueue.length===0)return;if(e.type==="audio"&&e.info.requiresPcmTransformation){let s=0;for(let n=0;n<e.timestampProcessingQueue.length;n++){const a=e.timestampProcessingQueue[n],o=J(a.duration,e.timescale);s+=o}if(e.timeToSampleTable.length===0)e.timeToSampleTable.push({sampleCount:s,sampleDelta:1});else{const n=G(e.timeToSampleTable);n.sampleCount+=s}e.timestampProcessingQueue.length=0;return}const i=e.timestampProcessingQueue.map(s=>s.timestamp).sort((s,n)=>s-n);for(let s=0;s<e.timestampProcessingQueue.length;s++){const n=e.timestampProcessingQueue[s];n.decodeTimestamp=i[s],!this.isFragmented&&e.lastTimescaleUnits===null&&(n.decodeTimestamp=0);const a=J(n.timestamp-n.decodeTimestamp,e.timescale),o=J(n.duration,e.timescale);if(e.lastTimescaleUnits!==null){m(e.lastSample);const c=J(n.decodeTimestamp,e.timescale,!1),l=Math.round(c-e.lastTimescaleUnits);if(m(l>=0),e.lastTimescaleUnits+=l,e.lastSample.timescaleUnitsToNextSample=l,!this.isFragmented){let u=G(e.timeToSampleTable);if(m(u),u.sampleCount===1){u.sampleDelta=l;const h=e.timeToSampleTable[e.timeToSampleTable.length-2];h&&h.sampleDelta===l&&(h.sampleCount++,e.timeToSampleTable.pop(),u=h)}else u.sampleDelta!==l&&(u.sampleCount--,e.timeToSampleTable.push(u={sampleCount:1,sampleDelta:l}));u.sampleDelta===o?u.sampleCount++:e.timeToSampleTable.push({sampleCount:1,sampleDelta:o});const d=G(e.compositionTimeOffsetTable);m(d),d.sampleCompositionTimeOffset===a?d.sampleCount++:e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:a})}}else e.lastTimescaleUnits=J(n.decodeTimestamp,e.timescale,!1),this.isFragmented||(e.timeToSampleTable.push({sampleCount:1,sampleDelta:o}),e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:a}));e.lastSample=n}if(e.timestampProcessingQueue.length=0,m(e.lastSample),m(e.lastTimescaleUnits!==null),r!==void 0&&e.lastSample.timescaleUnitsToNextSample===0){m(r.type==="key");const s=J(r.timestamp,e.timescale,!1),n=Math.round(s-e.lastTimescaleUnits);e.lastSample.timescaleUnitsToNextSample=n}}async registerSample(e,r){r.type==="key"&&this.processTimestamps(e,r),e.timestampProcessingQueue.push(r),this.isFragmented?(e.sampleQueue.push(r),await this.interleaveSamples()):this.fastStart==="reserve"?await this.registerSampleFastStartReserve(e,r):await this.addSampleToTrack(e,r)}async addSampleToTrack(e,r){if(!this.isFragmented&&(e.samples.push(r),this.fastStart==="reserve")){const s=e.track.metadata.maximumPacketCount;if(m(s!==void 0),e.samples.length>s)throw new Error(`Track #${e.track.id} has already reached the maximum packet count (${s}). Either add less packets or increase the maximum packet count.`)}let i=!1;if(!e.currentChunk)i=!0;else{e.currentChunk.startTimestamp=Math.min(e.currentChunk.startTimestamp,r.timestamp);const s=r.timestamp-e.currentChunk.startTimestamp;if(this.isFragmented){const n=this.trackDatas.every(a=>{if(e===a)return r.type==="key";const o=a.sampleQueue[0];return o?o.type==="key":a.track.source._closed});s>=this.minimumFragmentDuration&&n&&r.timestamp>this.maxWrittenTimestamp&&(i=!0,await this.finalizeFragment())}else i=s>=.5}i&&(e.currentChunk&&await this.finalizeCurrentChunk(e),e.currentChunk={startTimestamp:r.timestamp,samples:[],offset:null,moofOffset:null}),m(e.currentChunk),e.currentChunk.samples.push(r),this.isFragmented&&(this.maxWrittenTimestamp=Math.max(this.maxWrittenTimestamp,r.timestamp))}async finalizeCurrentChunk(e){if(m(!this.isFragmented),!e.currentChunk)return;e.finalizedChunks.push(e.currentChunk),this.finalizedChunks.push(e.currentChunk);let r=e.currentChunk.samples.length;if(e.type==="audio"&&e.info.requiresPcmTransformation&&(r=e.currentChunk.samples.reduce((i,s)=>i+J(s.duration,e.timescale),0)),(e.compactlyCodedChunkTable.length===0||G(e.compactlyCodedChunkTable).samplesPerChunk!==r)&&e.compactlyCodedChunkTable.push({firstChunk:e.finalizedChunks.length,samplesPerChunk:r}),this.fastStart==="in-memory"){e.currentChunk.offset=0;return}e.currentChunk.offset=this.writer.getPos();for(const i of e.currentChunk.samples)m(i.data),this.writer.write(i.data),i.data=null;await this.writer.flush()}async interleaveSamples(e=!1){if(m(this.isFragmented),!(!e&&!this.allTracksAreKnown()))e:for(;;){let r=null,i=1/0;for(const n of this.trackDatas){if(!e&&n.sampleQueue.length===0&&!n.track.source._closed)break e;n.sampleQueue.length>0&&n.sampleQueue[0].timestamp<i&&(r=n,i=n.sampleQueue[0].timestamp)}if(!r)break;const s=r.sampleQueue.shift();await this.addSampleToTrack(r,s)}}async finalizeFragment(e=!0){m(this.isFragmented);const r=this.nextFragmentNumber++;if(r===1){this.format._options.onMoov&&this.writer.startTrackingWrites();const f=Mt(this);if(this.boxWriter.writeBox(f),this.format._options.onMoov){const{data:p,start:g}=this.writer.stopTrackingWrites();this.format._options.onMoov(p,g)}}const i=this.trackDatas.filter(f=>f.currentChunk),s=Zi(r,i),n=this.writer.getPos(),a=n+this.boxWriter.measureBox(s);let o=a+Oe,c=1/0;for(const f of i){f.currentChunk.offset=o,f.currentChunk.moofOffset=n;for(const p of f.currentChunk.samples)o+=p.size;c=Math.min(c,f.currentChunk.startTimestamp)}const l=o-a,u=l>=2**32;if(u)for(const f of i)f.currentChunk.offset+=it-Oe;this.format._options.onMoof&&this.writer.startTrackingWrites();const d=Zi(r,i);if(this.boxWriter.writeBox(d),this.format._options.onMoof){const{data:f,start:p}=this.writer.stopTrackingWrites();this.format._options.onMoof(f,p,c)}m(this.writer.getPos()===a),this.format._options.onMdat&&this.writer.startTrackingWrites();const h=ir(u);h.size=l,this.boxWriter.writeBox(h),this.writer.seek(a+(u?it:Oe));for(const f of i)for(const p of f.currentChunk.samples)this.writer.write(p.data),p.data=null;if(this.format._options.onMdat){const{data:f,start:p}=this.writer.stopTrackingWrites();this.format._options.onMdat(f,p)}for(const f of i)f.finalizedChunks.push(f.currentChunk),this.finalizedChunks.push(f.currentChunk),f.currentChunk=null;e&&await this.writer.flush()}async registerSampleFastStartReserve(e,r){if(this.allTracksAreKnown()){if(!this.mdat){const i=Mt(this),n=this.boxWriter.measureBox(i)+this.computeSampleTableSizeUpperBound()+4096;m(this.ftypSize!==null),this.writer.seek(this.ftypSize+n),this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=ir(!0),this.boxWriter.writeBox(this.mdat);for(const a of this.trackDatas){for(const o of a.sampleQueue)await this.addSampleToTrack(a,o);a.sampleQueue.length=0}}await this.addSampleToTrack(e,r)}else e.sampleQueue.push(r)}computeSampleTableSizeUpperBound(){m(this.fastStart==="reserve");let e=0;for(const r of this.trackDatas){const i=r.track.metadata.maximumPacketCount;m(i!==void 0),e+=8*Math.ceil(2/3*i),e+=4*i,e+=8*Math.ceil(2/3*i),e+=12*Math.ceil(2/3*i),e+=4*i,e+=8*i}return e}async onTrackClose(e){const r=await this.mutex.acquire();if(e.type==="subtitle"&&e.source._codec==="webvtt"){const i=this.trackDatas.find(s=>s.track===e);i&&await this.processWebVTTCues(i,1/0)}this.allTracksAreKnown()&&this.allTracksKnown.resolve(),this.isFragmented&&await this.interleaveSamples(),r()}async finalize(){const e=await this.mutex.acquire();this.allTracksKnown.resolve();for(const r of this.trackDatas)r.type==="subtitle"&&r.track.source._codec==="webvtt"&&await this.processWebVTTCues(r,1/0);if(this.isFragmented){await this.interleaveSamples(!0);for(const r of this.trackDatas)this.processTimestamps(r);await this.finalizeFragment(!1)}else for(const r of this.trackDatas)this.processTimestamps(r),await this.finalizeCurrentChunk(r);if(this.fastStart==="in-memory"){this.mdat=ir(!1);let r;for(let s=0;s<2;s++){const n=Mt(this),a=this.boxWriter.measureBox(n);r=this.boxWriter.measureBox(this.mdat);let o=this.writer.getPos()+a+r;for(const c of this.finalizedChunks){c.offset=o;for(const{data:l}of c.samples)m(l),o+=l.byteLength,r+=l.byteLength}if(o<2**32)break;r>=2**32&&(this.mdat.largeSize=!0)}this.format._options.onMoov&&this.writer.startTrackingWrites();const i=Mt(this);if(this.boxWriter.writeBox(i),this.format._options.onMoov){const{data:s,start:n}=this.writer.stopTrackingWrites();this.format._options.onMoov(s,n)}this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat.size=r,this.boxWriter.writeBox(this.mdat);for(const s of this.finalizedChunks)for(const n of s.samples)m(n.data),this.writer.write(n.data),n.data=null;if(this.format._options.onMdat){const{data:s,start:n}=this.writer.stopTrackingWrites();this.format._options.onMdat(s,n)}}else if(this.isFragmented){const r=this.writer.getPos(),i=Bc(this.trackDatas);this.boxWriter.writeBox(i);const s=this.writer.getPos()-r;this.writer.seek(this.writer.getPos()-4),this.boxWriter.writeU32(s)}else{m(this.mdat);const r=this.boxWriter.offsets.get(this.mdat);m(r!==void 0);const i=this.writer.getPos()-r;if(this.mdat.size=i,this.mdat.largeSize=i>=2**32,this.boxWriter.patchBox(this.mdat),this.format._options.onMdat){const{data:n,start:a}=this.writer.stopTrackingWrites();this.format._options.onMdat(n,a)}const s=Mt(this);if(this.fastStart==="reserve"){m(this.ftypSize!==null),this.writer.seek(this.ftypSize),this.format._options.onMoov&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(s);const n=this.boxWriter.offsets.get(this.mdat)-this.writer.getPos();this.boxWriter.writeBox(Wo(n))}else this.format._options.onMoov&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(s);if(this.format._options.onMoov){const{data:n,start:a}=this.writer.stopTrackingWrites();this.format._options.onMoov(n,a)}}e()}}class an{getSupportedVideoCodecs(){return this.getSupportedCodecs().filter(e=>Ie.includes(e))}getSupportedAudioCodecs(){return this.getSupportedCodecs().filter(e=>_e.includes(e))}getSupportedSubtitleCodecs(){return this.getSupportedCodecs().filter(e=>lr.includes(e))}_codecUnsupportedHint(e){return""}}class on extends an{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.fastStart!==void 0&&![!1,"in-memory","reserve","fragmented"].includes(e.fastStart))throw new TypeError("options.fastStart, when provided, must be false, 'in-memory', 'reserve', or 'fragmented'.");if(e.minimumFragmentDuration!==void 0&&(!Number.isFinite(e.minimumFragmentDuration)||e.minimumFragmentDuration<0))throw new TypeError("options.minimumFragmentDuration, when provided, must be a non-negative number.");if(e.onFtyp!==void 0&&typeof e.onFtyp!="function")throw new TypeError("options.onFtyp, when provided, must be a function.");if(e.onMoov!==void 0&&typeof e.onMoov!="function")throw new TypeError("options.onMoov, when provided, must be a function.");if(e.onMdat!==void 0&&typeof e.onMdat!="function")throw new TypeError("options.onMdat, when provided, must be a function.");if(e.onMoof!==void 0&&typeof e.onMoof!="function")throw new TypeError("options.onMoof, when provided, must be a function.");if(e.metadataFormat!==void 0&&!["mdir","mdta","udta","auto"].includes(e.metadataFormat))throw new TypeError("options.metadataFormat, when provided, must be either 'auto', 'mdir', 'mdta', or 'udta'.");super(),this._options=e}getSupportedTrackCounts(){return{video:{min:0,max:4294967295},audio:{min:0,max:4294967295},subtitle:{min:0,max:4294967295},total:{min:1,max:4294967295}}}get supportsVideoRotationMetadata(){return!0}_createMuxer(e){return new Zc(e,this)}}class cn extends on{constructor(e){super(e)}get _name(){return"MP4"}get fileExtension(){return".mp4"}get mimeType(){return"video/mp4"}getSupportedCodecs(){return[...Ie,...Ut,"pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be",...lr]}_codecUnsupportedHint(e){return new ln().getSupportedCodecs().includes(e)?" Switching to MOV will grant support for this codec.":""}}class ln extends on{constructor(e){super(e)}get _name(){return"MOV"}get fileExtension(){return".mov"}get mimeType(){return"video/quicktime"}getSupportedCodecs(){return[...Ie,..._e]}_codecUnsupportedHint(e){return new cn().getSupportedCodecs().includes(e)?" Switching to MP4 will grant support for this codec.":""}}const Jc=t=>{if(!t||typeof t!="object")throw new TypeError("Encoding config must be an object.");if(!Ie.includes(t.codec))throw new TypeError(`Invalid video codec '${t.codec}'. Must be one of: ${Ie.join(", ")}.`);if(!(t.bitrate instanceof Te)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("config.bitrate must be a positive integer or a quality.");if(t.keyFrameInterval!==void 0&&(!Number.isFinite(t.keyFrameInterval)||t.keyFrameInterval<0))throw new TypeError("config.keyFrameInterval, when provided, must be a non-negative number.");if(t.sizeChangeBehavior!==void 0&&!["deny","passThrough","fill","contain","cover"].includes(t.sizeChangeBehavior))throw new TypeError("config.sizeChangeBehavior, when provided, must be 'deny', 'passThrough', 'fill', 'contain' or 'cover'.");if(t.onEncodedPacket!==void 0&&typeof t.onEncodedPacket!="function")throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(t.onEncoderConfig!==void 0&&typeof t.onEncoderConfig!="function")throw new TypeError("config.onEncoderConfig, when provided, must be a function.");un(t.codec,t)},un=(t,e)=>{if(!e||typeof e!="object")throw new TypeError("Encoding options must be an object.");if(e.alpha!==void 0&&!["discard","keep"].includes(e.alpha))throw new TypeError("options.alpha, when provided, must be 'discard' or 'keep'.");if(e.bitrateMode!==void 0&&!["constant","variable"].includes(e.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(e.latencyMode!==void 0&&!["quality","realtime"].includes(e.latencyMode))throw new TypeError("latencyMode, when provided, must be 'quality' or 'realtime'.");if(e.fullCodecString!==void 0&&typeof e.fullCodecString!="string")throw new TypeError("fullCodecString, when provided, must be a string.");if(e.fullCodecString!==void 0&&gs(e.fullCodecString)!==t)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${t}).`);if(e.hardwareAcceleration!==void 0&&!["no-preference","prefer-hardware","prefer-software"].includes(e.hardwareAcceleration))throw new TypeError("hardwareAcceleration, when provided, must be 'no-preference', 'prefer-hardware' or 'prefer-software'.");if(e.scalabilityMode!==void 0&&typeof e.scalabilityMode!="string")throw new TypeError("scalabilityMode, when provided, must be a string.");if(e.contentHint!==void 0&&typeof e.contentHint!="string")throw new TypeError("contentHint, when provided, must be a string.")},ri=t=>{const e=t.bitrate instanceof Te?t.bitrate._toVideoBitrate(t.codec,t.width,t.height):t.bitrate;return{codec:t.fullCodecString??In(t.codec,t.width,t.height,e),width:t.width,height:t.height,bitrate:e,bitrateMode:t.bitrateMode,alpha:t.alpha??"discard",framerate:t.framerate,latencyMode:t.latencyMode,hardwareAcceleration:t.hardwareAcceleration,scalabilityMode:t.scalabilityMode,contentHint:t.contentHint,...Fn(t.codec)}},el=t=>{if(!t||typeof t!="object")throw new TypeError("Encoding config must be an object.");if(!_e.includes(t.codec))throw new TypeError(`Invalid audio codec '${t.codec}'. Must be one of: ${_e.join(", ")}.`);if(t.bitrate===void 0&&(!ce.includes(t.codec)||t.codec==="flac"))throw new TypeError("config.bitrate must be provided for compressed audio codecs.");if(t.bitrate!==void 0&&!(t.bitrate instanceof Te)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("config.bitrate, when provided, must be a positive integer or a quality.");if(t.onEncodedPacket!==void 0&&typeof t.onEncodedPacket!="function")throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(t.onEncoderConfig!==void 0&&typeof t.onEncoderConfig!="function")throw new TypeError("config.onEncoderConfig, when provided, must be a function.");dn(t.codec,t)},dn=(t,e)=>{if(!e||typeof e!="object")throw new TypeError("Encoding options must be an object.");if(e.bitrateMode!==void 0&&!["constant","variable"].includes(e.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(e.fullCodecString!==void 0&&typeof e.fullCodecString!="string")throw new TypeError("fullCodecString, when provided, must be a string.");if(e.fullCodecString!==void 0&&gs(e.fullCodecString)!==t)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${t}).`)},ii=t=>{const e=t.bitrate instanceof Te?t.bitrate._toAudioBitrate(t.codec):t.bitrate;return{codec:t.fullCodecString??An(t.codec,t.numberOfChannels,t.sampleRate),numberOfChannels:t.numberOfChannels,sampleRate:t.sampleRate,bitrate:e,bitrateMode:t.bitrateMode,...Bn(t.codec)}};class Te{constructor(e){this._factor=e}_toVideoBitrate(e,r,i){const s=r*i,n={avc:1,hevc:.6,vp9:.6,av1:.4,vp8:1.2},a=1920*1080,o=3e6,c=Math.pow(s/a,.95),d=o*c*n[e]*this._factor;return Math.ceil(d/1e3)*1e3}_toAudioBitrate(e){if(ce.includes(e)||e==="flac")return;const i={aac:128e3,opus:64e3,mp3:16e4,vorbis:64e3}[e];if(!i)throw new Error(`Unhandled codec: ${e}`);let s=i*this._factor;return e==="aac"?s=[96e3,128e3,16e4,192e3].reduce((a,o)=>Math.abs(o-s)<Math.abs(a-s)?o:a):e==="opus"||e==="vorbis"?s=Math.max(6e3,s):e==="mp3"&&(s=[8e3,16e3,24e3,32e3,4e4,48e3,64e3,8e4,96e3,112e3,128e3,16e4,192e3,224e3,256e3,32e4].reduce((a,o)=>Math.abs(o-s)<Math.abs(a-s)?o:a)),Math.round(s/1e3)*1e3}}const bl=new Te(.3),wl=new Te(1),es=new Te(2),tl=async(t,e={})=>{const{width:r=1280,height:i=720,bitrate:s=1e6,...n}=e;if(!Ie.includes(t))return!1;if(!Number.isInteger(r)||r<=0)throw new TypeError("width must be a positive integer.");if(!Number.isInteger(i)||i<=0)throw new TypeError("height must be a positive integer.");if(!(s instanceof Te)&&(!Number.isInteger(s)||s<=0))throw new TypeError("bitrate must be a positive integer or a quality.");un(t,n);let a=null;return $r.length>0&&(a??=ri({codec:t,width:r,height:i,bitrate:s,framerate:void 0,...n}),$r.some(l=>l.supports(t,a)))?!0:typeof VideoEncoder>"u"||(r%2===1||i%2===1)&&(t==="avc"||t==="hevc")||(a??=ri({codec:t,width:r,height:i,bitrate:s,framerate:void 0,...n,alpha:"discard"}),!(await VideoEncoder.isConfigSupported(a)).supported)?!1:Ft()?new Promise(async l=>{try{const u=new VideoEncoder({output:()=>{},error:()=>l(!1)});u.configure(a);const d=new Uint8Array(r*i*4),h=new VideoFrame(d,{format:"RGBA",codedWidth:r,codedHeight:i,timestamp:0});u.encode(h),h.close(),await u.flush(),l(!0)}catch{l(!1)}}):!0},rl=async(t,e={})=>{const{numberOfChannels:r=2,sampleRate:i=48e3,bitrate:s=128e3,...n}=e;if(!_e.includes(t))return!1;if(!Number.isInteger(r)||r<=0)throw new TypeError("numberOfChannels must be a positive integer.");if(!Number.isInteger(i)||i<=0)throw new TypeError("sampleRate must be a positive integer.");if(!(s instanceof Te)&&(!Number.isInteger(s)||s<=0))throw new TypeError("bitrate must be a positive integer.");dn(t,n);let a=null;return Qr.length>0&&(a??=ii({codec:t,numberOfChannels:r,sampleRate:i,bitrate:s,...n}),Qr.some(c=>c.supports(t,a)))||ce.includes(t)?!0:typeof AudioEncoder>"u"?!1:(a??=ii({codec:t,numberOfChannels:r,sampleRate:i,bitrate:s,...n}),(await AudioEncoder.isConfigSupported(a)).supported===!0)},ts=async(t=_e,e)=>{const r=await Promise.all(t.map(i=>rl(i,e)));return t.filter((i,s)=>r[s])},il=async(t,e)=>{for(const r of t)if(await tl(r,e))return r;return null};class xi{constructor(){this._connectedTrack=null,this._closingPromise=null,this._closed=!1,this._timestampOffset=0}_ensureValidAdd(){if(!this._connectedTrack)throw new Error("Source is not connected to an output track.");if(this._connectedTrack.output.state==="canceled")throw new Error("Output has been canceled.");if(this._connectedTrack.output.state==="finalizing"||this._connectedTrack.output.state==="finalized")throw new Error("Output has been finalized.");if(this._connectedTrack.output.state==="pending")throw new Error("Output has not started.");if(this._closed)throw new Error("Source is closed.")}async _start(){}async _flushAndClose(e){}close(){if(this._closingPromise)return;const e=this._connectedTrack;if(!e)throw new Error("Cannot call close without connecting the source to an output track.");if(e.output.state==="pending")throw new Error("Cannot call close before output has been started.");this._closingPromise=(async()=>{await this._flushAndClose(!1),this._closed=!0,!(e.output.state==="finalizing"||e.output.state==="finalized")&&e.output._muxer.onTrackClose(e)})()}async _flushOrWaitForOngoingClose(e){return this._closingPromise??=(async()=>{await this._flushAndClose(e),this._closed=!0})()}}class Ci extends xi{constructor(e){if(super(),this._connectedTrack=null,!Ie.includes(e))throw new TypeError(`Invalid video codec '${e}'. Must be one of: ${Ie.join(", ")}.`);this._codec=e}}class sl extends Ci{constructor(e){super(e)}add(e,r){if(!(e instanceof j))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be added.");if(r!==void 0&&(!r||typeof r!="object"))throw new TypeError("meta, when provided, must be an object.");return this._ensureValidAdd(),this._connectedTrack.output._muxer.addEncodedVideoPacket(this._connectedTrack,e,r)}}class nl{constructor(e,r){this.source=e,this.encodingConfig=r,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastMultipleOfKeyFrameInterval=-1,this.codedWidth=null,this.codedHeight=null,this.resizeCanvas=null,this.customEncoder=null,this.customEncoderCallSerializer=new br,this.customEncoderQueueSize=0,this.alphaEncoder=null,this.splitter=null,this.splitterCreationFailed=!1,this.alphaFrameQueue=[],this.error=null,this.errorNeedsNewStack=!0}async add(e,r,i){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),this.codedWidth!==null&&this.codedHeight!==null){if(e.codedWidth!==this.codedWidth||e.codedHeight!==this.codedHeight){const o=this.encodingConfig.sizeChangeBehavior??"deny";if(o!=="passThrough"){if(o==="deny")throw new Error(`Video sample size must remain constant. Expected ${this.codedWidth}x${this.codedHeight}, got ${e.codedWidth}x${e.codedHeight}. To allow the sample size to change over time, set \`sizeChangeBehavior\` to a value other than 'strict' in the encoding options.`);{let c=!1;this.resizeCanvas||(typeof document<"u"?(this.resizeCanvas=document.createElement("canvas"),this.resizeCanvas.width=this.codedWidth,this.resizeCanvas.height=this.codedHeight):this.resizeCanvas=new OffscreenCanvas(this.codedWidth,this.codedHeight),c=!0);const l=this.resizeCanvas.getContext("2d",{alpha:Ft()});m(l),c||(Ft()?(l.fillStyle="black",l.fillRect(0,0,this.codedWidth,this.codedHeight)):l.clearRect(0,0,this.codedWidth,this.codedHeight)),e.drawWithFit(l,{fit:o}),r&&e.close(),e=new oe(this.resizeCanvas,{timestamp:e.timestamp,duration:e.duration,rotation:e.rotation}),r=!0}}}}else this.codedWidth=e.codedWidth,this.codedHeight=e.codedHeight;this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||await this.ensureEncoderPromise),m(this.encoderInitialized);const s=this.encodingConfig.keyFrameInterval??5,n=Math.floor(e.timestamp/s),a={...i,keyFrame:i?.keyFrame||s===0||n!==this.lastMultipleOfKeyFrameInterval};if(this.lastMultipleOfKeyFrameInterval=n,this.customEncoder){this.customEncoderQueueSize++;const o=e.clone(),c=this.customEncoderCallSerializer.call(()=>this.customEncoder.encode(o,a)).then(()=>this.customEncoderQueueSize--).catch(l=>this.error??=l).finally(()=>{o.close()});this.customEncoderQueueSize>=4&&await c}else{m(this.encoder);const o=e.toVideoFrame();if(!this.alphaEncoder)this.encoder.encode(o,a),o.close();else if(!!o.format&&!o.format.includes("A")||this.splitterCreationFailed)this.alphaFrameQueue.push(null),this.encoder.encode(o,a),o.close();else{const l=o.displayWidth,u=o.displayHeight;if(!this.splitter)try{this.splitter=new al(l,u)}catch(d){console.error("Due to an error, only color data will be encoded.",d),this.splitterCreationFailed=!0,this.alphaFrameQueue.push(null),this.encoder.encode(o,a),o.close()}if(this.splitter){const d=this.splitter.extractColor(o),h=this.splitter.extractAlpha(o);this.alphaFrameQueue.push(h),this.encoder.encode(d,a),d.close(),o.close()}}r&&e.close(),this.encoder.encodeQueueSize>=4&&await new Promise(c=>this.encoder.addEventListener("dequeue",c,{once:!0}))}await this.muxer.mutex.currentPromise}finally{r&&e.close()}}ensureEncoder(e){const r=new Error;this.ensureEncoderPromise=(async()=>{const i=ri({width:e.codedWidth,height:e.codedHeight,...this.encodingConfig,framerate:this.source._connectedTrack?.metadata.frameRate});this.encodingConfig.onEncoderConfig?.(i);const s=$r.find(n=>n.supports(this.encodingConfig.codec,i));if(s)this.customEncoder=new s,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=i,this.customEncoder.onPacket=(n,a)=>{if(!(n instanceof j))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(a!==void 0&&(!a||typeof a!="object"))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");this.encodingConfig.onEncodedPacket?.(n,a),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,n,a).catch(o=>{this.error??=o,this.errorNeedsNewStack=!1})},await this.customEncoder.init();else{if(typeof VideoEncoder>"u")throw new Error("VideoEncoder is not supported by this browser.");if(i.alpha="discard",this.encodingConfig.alpha==="keep"&&(i.latencyMode="quality"),(i.width%2===1||i.height%2===1)&&(this.encodingConfig.codec==="avc"||this.encodingConfig.codec==="hevc"))throw new Error(`The dimensions ${i.width}x${i.height} are not supported for codec '${this.encodingConfig.codec}'; both width and height must be even numbers. Make sure to round your dimensions to the nearest even number.`);if(!(await VideoEncoder.isConfigSupported(i)).supported)throw new Error(`This specific encoder configuration (${i.codec}, ${i.bitrate} bps, ${i.width}x${i.height}, hardware acceleration: ${i.hardwareAcceleration??"no-preference"}) is not supported by this browser. Consider using another codec or changing your video parameters.`);const o=[],c=[];let l=0,u=0;const d=(h,f,p)=>{const g={};if(f){const w=new Uint8Array(f.byteLength);f.copyTo(w),g.alpha=w}const k=j.fromEncodedChunk(h,g);this.encodingConfig.onEncodedPacket?.(k,p),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,k,p).catch(w=>{this.error??=w,this.errorNeedsNewStack=!1})};this.encoder=new VideoEncoder({output:(h,f)=>{if(!this.alphaEncoder){d(h,null,f);return}const p=this.alphaFrameQueue.shift();m(p!==void 0),p?(this.alphaEncoder.encode(p,{keyFrame:h.type==="key"}),u++,p.close(),o.push({chunk:h,meta:f})):u===0?d(h,null,f):(c.push(l+u),o.push({chunk:h,meta:f}))},error:h=>{h.stack=r.stack,this.error??=h}}),this.encoder.configure(i),this.encodingConfig.alpha==="keep"&&(this.alphaEncoder=new VideoEncoder({output:(h,f)=>{u--;const p=o.shift();for(m(p!==void 0),d(p.chunk,h,p.meta),l++;c.length>0&&c[0]===l;){c.shift();const g=o.shift();m(g!==void 0),d(g.chunk,null,g.meta)}},error:h=>{h.stack=r.stack,this.error??=h}}),this.alphaEncoder.configure(i))}m(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}async flushAndClose(e){e||this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call(()=>this.customEncoder.flush()),await this.customEncoderCallSerializer.call(()=>this.customEncoder.close())):this.encoder&&(e||(await this.encoder.flush(),await this.alphaEncoder?.flush()),this.encoder.state!=="closed"&&this.encoder.close(),this.alphaEncoder&&this.alphaEncoder.state!=="closed"&&this.alphaEncoder.close(),this.alphaFrameQueue.forEach(r=>r?.close()),this.splitter?.close()),e||this.checkForEncoderError()}getQueueSize(){return this.customEncoder?this.customEncoderQueueSize:this.encoder?.encodeQueueSize??0}checkForEncoderError(){if(this.error)throw this.errorNeedsNewStack&&(this.error.stack=new Error().stack),this.error}}class al{constructor(e,r){this.lastFrame=null,typeof OffscreenCanvas<"u"?this.canvas=new OffscreenCanvas(e,r):(this.canvas=document.createElement("canvas"),this.canvas.width=e,this.canvas.height=r);const i=this.canvas.getContext("webgl2",{alpha:!0});if(!i)throw new Error("Couldn't acquire WebGL 2 context.");this.gl=i,this.colorProgram=this.createColorProgram(),this.alphaProgram=this.createAlphaProgram(),this.vao=this.createVAO(),this.sourceTexture=this.createTexture(),this.alphaResolutionLocation=this.gl.getUniformLocation(this.alphaProgram,"u_resolution"),this.gl.useProgram(this.colorProgram),this.gl.uniform1i(this.gl.getUniformLocation(this.colorProgram,"u_sourceTexture"),0),this.gl.useProgram(this.alphaProgram),this.gl.uniform1i(this.gl.getUniformLocation(this.alphaProgram,"u_sourceTexture"),0)}createVertexShader(){return this.createShader(this.gl.VERTEX_SHADER,`#version 300 es
			in vec2 a_position;
			in vec2 a_texCoord;
			out vec2 v_texCoord;
			
			void main() {
				gl_Position = vec4(a_position, 0.0, 1.0);
				v_texCoord = a_texCoord;
			}
		`)}createColorProgram(){const e=this.createVertexShader(),r=this.createShader(this.gl.FRAGMENT_SHADER,`#version 300 es
			precision highp float;
			
			uniform sampler2D u_sourceTexture;
			in vec2 v_texCoord;
			out vec4 fragColor;
			
			void main() {
				vec4 source = texture(u_sourceTexture, v_texCoord);
				fragColor = vec4(source.rgb, 1.0);
			}
		`),i=this.gl.createProgram();return this.gl.attachShader(i,e),this.gl.attachShader(i,r),this.gl.linkProgram(i),i}createAlphaProgram(){const e=this.createVertexShader(),r=this.createShader(this.gl.FRAGMENT_SHADER,`#version 300 es
			precision highp float;
			
			uniform sampler2D u_sourceTexture;
			uniform vec2 u_resolution; // The width and height of the canvas
			in vec2 v_texCoord;
			out vec4 fragColor;

			// This function determines the value for a single byte in the YUV stream
			float getByteValue(float byteOffset) {
				float width = u_resolution.x;
				float height = u_resolution.y;

				float yPlaneSize = width * height;

				if (byteOffset < yPlaneSize) {
					// This byte is in the luma plane. Find the corresponding pixel coordinates to sample from
					float y = floor(byteOffset / width);
					float x = mod(byteOffset, width);
					
					// Add 0.5 to sample the center of the texel
					vec2 sampleCoord = (vec2(x, y) + 0.5) / u_resolution;
					
					// The luma value is the alpha from the source texture
					return texture(u_sourceTexture, sampleCoord).a;
				} else {
					// Write a fixed value for chroma and beyond
					return 128.0 / 255.0;
				}
			}
			
			void main() {
				// Each fragment writes 4 bytes (R, G, B, A)
				float pixelIndex = floor(gl_FragCoord.y) * u_resolution.x + floor(gl_FragCoord.x);
				float baseByteOffset = pixelIndex * 4.0;

				vec4 result;
				for (int i = 0; i < 4; i++) {
					float currentByteOffset = baseByteOffset + float(i);
					result[i] = getByteValue(currentByteOffset);
				}
				
				fragColor = result;
			}
		`),i=this.gl.createProgram();return this.gl.attachShader(i,e),this.gl.attachShader(i,r),this.gl.linkProgram(i),i}createShader(e,r){const i=this.gl.createShader(e);return this.gl.shaderSource(i,r),this.gl.compileShader(i),this.gl.getShaderParameter(i,this.gl.COMPILE_STATUS)||console.error("Shader compile error:",this.gl.getShaderInfoLog(i)),i}createVAO(){const e=this.gl.createVertexArray();this.gl.bindVertexArray(e);const r=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,1,1,1,0]),i=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,i),this.gl.bufferData(this.gl.ARRAY_BUFFER,r,this.gl.STATIC_DRAW);const s=this.gl.getAttribLocation(this.colorProgram,"a_position"),n=this.gl.getAttribLocation(this.colorProgram,"a_texCoord");return this.gl.enableVertexAttribArray(s),this.gl.vertexAttribPointer(s,2,this.gl.FLOAT,!1,16,0),this.gl.enableVertexAttribArray(n),this.gl.vertexAttribPointer(n,2,this.gl.FLOAT,!1,16,8),e}createTexture(){const e=this.gl.createTexture();return this.gl.bindTexture(this.gl.TEXTURE_2D,e),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),e}updateTexture(e){this.lastFrame!==e&&((e.displayWidth!==this.canvas.width||e.displayHeight!==this.canvas.height)&&(this.canvas.width=e.displayWidth,this.canvas.height=e.displayHeight),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,this.sourceTexture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,e),this.lastFrame=e)}extractColor(e){return this.updateTexture(e),this.gl.useProgram(this.colorProgram),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(this.vao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),new VideoFrame(this.canvas,{timestamp:e.timestamp,duration:e.duration??void 0,alpha:"discard"})}extractAlpha(e){this.updateTexture(e),this.gl.useProgram(this.alphaProgram),this.gl.uniform2f(this.alphaResolutionLocation,this.canvas.width,this.canvas.height),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(this.vao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4);const{width:r,height:i}=this.canvas,s=Math.ceil(r/2)*Math.ceil(i/2),n=r*i+s*2,a=Math.ceil(n/(r*4));let o=new Uint8Array(4*r*a);this.gl.readPixels(0,0,r,a,this.gl.RGBA,this.gl.UNSIGNED_BYTE,o),o=o.subarray(0,n),m(o[r*i]===128),m(o[o.length-1]===128);const c={format:"I420",codedWidth:r,codedHeight:i,timestamp:e.timestamp,duration:e.duration??void 0,transfer:[o.buffer]};return new VideoFrame(o,c)}close(){this.gl.getExtension("WEBGL_lose_context")?.loseContext(),this.gl=null}}class rs extends Ci{constructor(e){Jc(e),super(e.codec),this._encoder=new nl(this,e)}add(e,r){if(!(e instanceof oe))throw new TypeError("videoSample must be a VideoSample.");return this._encoder.add(e,!1,r)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class vi extends xi{constructor(e){if(super(),this._connectedTrack=null,!_e.includes(e))throw new TypeError(`Invalid audio codec '${e}'. Must be one of: ${_e.join(", ")}.`);this._codec=e}}class ol extends vi{constructor(e){super(e)}add(e,r){if(!(e instanceof j))throw new TypeError("packet must be an EncodedPacket.");if(e.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be added.");if(r!==void 0&&(!r||typeof r!="object"))throw new TypeError("meta, when provided, must be an object.");return this._ensureValidAdd(),this._connectedTrack.output._muxer.addEncodedAudioPacket(this._connectedTrack,e,r)}}class cl{constructor(e,r){this.source=e,this.encodingConfig=r,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastNumberOfChannels=null,this.lastSampleRate=null,this.isPcmEncoder=!1,this.outputSampleSize=null,this.writeOutputValue=null,this.customEncoder=null,this.customEncoderCallSerializer=new br,this.customEncoderQueueSize=0,this.lastEndSampleIndex=null,this.error=null,this.errorNeedsNewStack=!0}async add(e,r){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),this.lastNumberOfChannels!==null&&this.lastSampleRate!==null){if(e.numberOfChannels!==this.lastNumberOfChannels||e.sampleRate!==this.lastSampleRate)throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at ${this.lastSampleRate} Hz, got ${e.numberOfChannels} channels at ${e.sampleRate} Hz.`)}else this.lastNumberOfChannels=e.numberOfChannels,this.lastSampleRate=e.sampleRate;this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||await this.ensureEncoderPromise),m(this.encoderInitialized);{const i=Math.round(e.timestamp*e.sampleRate),s=Math.round((e.timestamp+e.duration)*e.sampleRate);if(this.lastEndSampleIndex===null)this.lastEndSampleIndex=s;else{const n=i-this.lastEndSampleIndex;if(n>=64){const a=new ge({data:new Float32Array(n*e.numberOfChannels),format:"f32-planar",sampleRate:e.sampleRate,numberOfChannels:e.numberOfChannels,numberOfFrames:n,timestamp:this.lastEndSampleIndex/e.sampleRate});await this.add(a,!0)}this.lastEndSampleIndex+=e.numberOfFrames}}if(this.customEncoder){this.customEncoderQueueSize++;const i=e.clone(),s=this.customEncoderCallSerializer.call(()=>this.customEncoder.encode(i)).then(()=>this.customEncoderQueueSize--).catch(n=>this.error??=n).finally(()=>{i.close()});this.customEncoderQueueSize>=4&&await s,await this.muxer.mutex.currentPromise}else if(this.isPcmEncoder)await this.doPcmEncoding(e,r);else{m(this.encoder);const i=e.toAudioData();this.encoder.encode(i),i.close(),r&&e.close(),this.encoder.encodeQueueSize>=4&&await new Promise(s=>this.encoder.addEventListener("dequeue",s,{once:!0})),await this.muxer.mutex.currentPromise}}finally{r&&e.close()}}async doPcmEncoding(e,r){m(this.outputSampleSize),m(this.writeOutputValue);const{numberOfChannels:i,numberOfFrames:s,sampleRate:n,timestamp:a}=e,o=2048,c=[];for(let h=0;h<s;h+=o){const f=Math.min(o,e.numberOfFrames-h),p=f*i*this.outputSampleSize,g=new ArrayBuffer(p),k=new DataView(g);c.push({frameCount:f,view:k})}const l=e.allocationSize({planeIndex:0,format:"f32-planar"}),u=new Float32Array(l/Float32Array.BYTES_PER_ELEMENT);for(let h=0;h<i;h++){e.copyTo(u,{planeIndex:h,format:"f32-planar"});for(let f=0;f<c.length;f++){const{frameCount:p,view:g}=c[f];for(let k=0;k<p;k++)this.writeOutputValue(g,(k*i+h)*this.outputSampleSize,u[f*o+k])}}r&&e.close();const d={decoderConfig:{codec:this.encodingConfig.codec,numberOfChannels:i,sampleRate:n}};for(let h=0;h<c.length;h++){const{frameCount:f,view:p}=c[h],g=p.buffer,k=h*o,w=new j(new Uint8Array(g),"key",a+k/n,f/n);this.encodingConfig.onEncodedPacket?.(w,d),await this.muxer.addEncodedAudioPacket(this.source._connectedTrack,w,d)}}ensureEncoder(e){const r=new Error;this.ensureEncoderPromise=(async()=>{const{numberOfChannels:i,sampleRate:s}=e,n=ii({numberOfChannels:i,sampleRate:s,...this.encodingConfig});this.encodingConfig.onEncoderConfig?.(n);const a=Qr.find(o=>o.supports(this.encodingConfig.codec,n));if(a)this.customEncoder=new a,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=n,this.customEncoder.onPacket=(o,c)=>{if(!(o instanceof j))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(c!==void 0&&(!c||typeof c!="object"))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");this.encodingConfig.onEncodedPacket?.(o,c),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,o,c).catch(l=>{this.error??=l,this.errorNeedsNewStack=!1})},await this.customEncoder.init();else if(ce.includes(this.encodingConfig.codec))this.initPcmEncoder();else{if(typeof AudioEncoder>"u")throw new Error("AudioEncoder is not supported by this browser.");if(!(await AudioEncoder.isConfigSupported(n)).supported)throw new Error(`This specific encoder configuration (${n.codec}, ${n.bitrate} bps, ${n.numberOfChannels} channels, ${n.sampleRate} Hz) is not supported by this browser. Consider using another codec or changing your audio parameters.`);this.encoder=new AudioEncoder({output:(c,l)=>{if(this.encodingConfig.codec==="aac"&&l?.decoderConfig){let d=!1;if(!l.decoderConfig.description||l.decoderConfig.description.byteLength<2?d=!0:d=ui(fe(l.decoderConfig.description)).objectType===0,d){const h=Number(G(n.codec.split(".")));l.decoderConfig.description=ms({objectType:h,numberOfChannels:l.decoderConfig.numberOfChannels,sampleRate:l.decoderConfig.sampleRate})}}const u=j.fromEncodedChunk(c);this.encodingConfig.onEncodedPacket?.(u,l),this.muxer.addEncodedAudioPacket(this.source._connectedTrack,u,l).catch(d=>{this.error??=d,this.errorNeedsNewStack=!1})},error:c=>{c.stack=r.stack,this.error??=c}}),this.encoder.configure(n)}m(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}initPcmEncoder(){this.isPcmEncoder=!0;const e=this.encodingConfig.codec,{dataType:r,sampleSize:i,littleEndian:s}=Ze(e);switch(this.outputSampleSize=i,i){case 1:r==="unsigned"?this.writeOutputValue=(n,a,o)=>n.setUint8(a,te((o+1)*127.5,0,255)):r==="signed"?this.writeOutputValue=(n,a,o)=>{n.setInt8(a,te(Math.round(o*128),-128,127))}:r==="ulaw"?this.writeOutputValue=(n,a,o)=>{const c=te(Math.floor(o*32767),-32768,32767);n.setUint8(a,na(c))}:r==="alaw"?this.writeOutputValue=(n,a,o)=>{const c=te(Math.floor(o*32767),-32768,32767);n.setUint8(a,oa(c))}:m(!1);break;case 2:r==="unsigned"?this.writeOutputValue=(n,a,o)=>n.setUint16(a,te((o+1)*32767.5,0,65535),s):r==="signed"?this.writeOutputValue=(n,a,o)=>n.setInt16(a,te(Math.round(o*32767),-32768,32767),s):m(!1);break;case 3:r==="unsigned"?this.writeOutputValue=(n,a,o)=>oi(n,a,te((o+1)*83886075e-1,0,16777215),s):r==="signed"?this.writeOutputValue=(n,a,o)=>Tn(n,a,te(Math.round(o*8388607),-8388608,8388607),s):m(!1);break;case 4:r==="unsigned"?this.writeOutputValue=(n,a,o)=>n.setUint32(a,te((o+1)*21474836475e-1,0,4294967295),s):r==="signed"?this.writeOutputValue=(n,a,o)=>n.setInt32(a,te(Math.round(o*2147483647),-2147483648,2147483647),s):r==="float"?this.writeOutputValue=(n,a,o)=>n.setFloat32(a,o,s):m(!1);break;case 8:r==="float"?this.writeOutputValue=(n,a,o)=>n.setFloat64(a,o,s):m(!1);break;default:Xe(i),m(!1)}}async flushAndClose(e){e||this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call(()=>this.customEncoder.flush()),await this.customEncoderCallSerializer.call(()=>this.customEncoder.close())):this.encoder&&(e||await this.encoder.flush(),this.encoder.state!=="closed"&&this.encoder.close()),e||this.checkForEncoderError()}getQueueSize(){return this.customEncoder?this.customEncoderQueueSize:this.isPcmEncoder?0:this.encoder?.encodeQueueSize??0}checkForEncoderError(){if(this.error)throw this.errorNeedsNewStack&&(this.error.stack=new Error().stack),this.error}}class is extends vi{constructor(e){el(e),super(e.codec),this._encoder=new cl(this,e)}add(e){if(!(e instanceof ge))throw new TypeError("audioSample must be an AudioSample.");return this._encoder.add(e,!1)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class ll extends xi{constructor(e){if(super(),this._connectedTrack=null,!lr.includes(e))throw new TypeError(`Invalid subtitle codec '${e}'. Must be one of: ${lr.join(", ")}.`);this._codec=e}}const ul=["video","audio","subtitle"],Vr=t=>{if(!t||typeof t!="object")throw new TypeError("metadata must be an object.");if(t.languageCode!==void 0&&!qt(t.languageCode))throw new TypeError("metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code.");if(t.name!==void 0&&typeof t.name!="string")throw new TypeError("metadata.name, when provided, must be a string.");if(t.disposition!==void 0&&En(t.disposition),t.maximumPacketCount!==void 0&&(!Number.isInteger(t.maximumPacketCount)||t.maximumPacketCount<0))throw new TypeError("metadata.maximumPacketCount, when provided, must be a non-negative integer.")};class ss{constructor(e){if(this.state="pending",this._tracks=[],this._startPromise=null,this._cancelPromise=null,this._finalizePromise=null,this._mutex=new ut,this._metadataTags={},!e||typeof e!="object")throw new TypeError("options must be an object.");if(!(e.format instanceof an))throw new TypeError("options.format must be an OutputFormat.");if(!(e.target instanceof Pi))throw new TypeError("options.target must be a Target.");if(e.target._output)throw new Error("Target is already used for another output.");e.target._output=this,this.format=e.format,this.target=e.target,this._writer=e.target._createWriter(),this._muxer=e.format._createMuxer(this)}addVideoTrack(e,r={}){if(!(e instanceof Ci))throw new TypeError("source must be a VideoSource.");if(Vr(r),r.rotation!==void 0&&![0,90,180,270].includes(r.rotation))throw new TypeError(`Invalid video rotation: ${r.rotation}. Has to be 0, 90, 180 or 270.`);if(!this.format.supportsVideoRotationMetadata&&r.rotation)throw new Error(`${this.format._name} does not support video rotation metadata.`);if(r.frameRate!==void 0&&(!Number.isFinite(r.frameRate)||r.frameRate<=0))throw new TypeError(`Invalid video frame rate: ${r.frameRate}. Must be a positive number.`);this._addTrack("video",e,r)}addAudioTrack(e,r={}){if(!(e instanceof vi))throw new TypeError("source must be an AudioSource.");Vr(r),this._addTrack("audio",e,r)}addSubtitleTrack(e,r={}){if(!(e instanceof ll))throw new TypeError("source must be a SubtitleSource.");Vr(r),this._addTrack("subtitle",e,r)}setMetadataTags(e){if(qr(e),this.state!=="pending")throw new Error("Cannot set metadata tags after output has been started or canceled.");this._metadataTags=e}_addTrack(e,r,i){if(this.state!=="pending")throw new Error("Cannot add track after output has been started or canceled.");if(r._connectedTrack)throw new Error("Source is already used for a track.");const s=this.format.getSupportedTrackCounts(),n=this._tracks.reduce((l,u)=>l+(u.type===e?1:0),0),a=s[e].max;if(n===a)throw new Error(a===0?`${this.format._name} does not support ${e} tracks.`:`${this.format._name} does not support more than ${a} ${e} track${a===1?"":"s"}.`);const o=s.total.max;if(this._tracks.length===o)throw new Error(`${this.format._name} does not support more than ${o} tracks${o===1?"":"s"} in total.`);const c={id:this._tracks.length+1,output:this,type:e,source:r,metadata:i};if(c.type==="video"){const l=this.format.getSupportedVideoCodecs();if(l.length===0)throw new Error(`${this.format._name} does not support video tracks.`+this.format._codecUnsupportedHint(c.source._codec));if(!l.includes(c.source._codec))throw new Error(`Codec '${c.source._codec}' cannot be contained within ${this.format._name}. Supported video codecs are: ${l.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(c.source._codec))}else if(c.type==="audio"){const l=this.format.getSupportedAudioCodecs();if(l.length===0)throw new Error(`${this.format._name} does not support audio tracks.`+this.format._codecUnsupportedHint(c.source._codec));if(!l.includes(c.source._codec))throw new Error(`Codec '${c.source._codec}' cannot be contained within ${this.format._name}. Supported audio codecs are: ${l.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(c.source._codec))}else if(c.type==="subtitle"){const l=this.format.getSupportedSubtitleCodecs();if(l.length===0)throw new Error(`${this.format._name} does not support subtitle tracks.`+this.format._codecUnsupportedHint(c.source._codec));if(!l.includes(c.source._codec))throw new Error(`Codec '${c.source._codec}' cannot be contained within ${this.format._name}. Supported subtitle codecs are: ${l.map(u=>`'${u}'`).join(", ")}.`+this.format._codecUnsupportedHint(c.source._codec))}this._tracks.push(c),r._connectedTrack=c}async start(){const e=this.format.getSupportedTrackCounts();for(const i of ul){const s=this._tracks.reduce((a,o)=>a+(o.type===i?1:0),0),n=e[i].min;if(s<n)throw new Error(n===e[i].max?`${this.format._name} requires exactly ${n} ${i} track${n===1?"":"s"}.`:`${this.format._name} requires at least ${n} ${i} track${n===1?"":"s"}.`)}const r=e.total.min;if(this._tracks.length<r)throw new Error(r===e.total.max?`${this.format._name} requires exactly ${r} track${r===1?"":"s"}.`:`${this.format._name} requires at least ${r} track${r===1?"":"s"}.`);if(this.state==="canceled")throw new Error("Output has been canceled.");return this._startPromise?(console.warn("Output has already been started."),this._startPromise):this._startPromise=(async()=>{this.state="started",this._writer.start();const i=await this._mutex.acquire();await this._muxer.start();const s=this._tracks.map(n=>n.source._start());await Promise.all(s),i()})()}getMimeType(){return this._muxer.getMimeType()}async cancel(){if(this._cancelPromise)return console.warn("Output has already been canceled."),this._cancelPromise;if(this.state==="finalizing"||this.state==="finalized"){console.warn("Output has already been finalized.");return}return this._cancelPromise=(async()=>{this.state="canceled";const e=await this._mutex.acquire(),r=this._tracks.map(i=>i.source._flushOrWaitForOngoingClose(!0));await Promise.all(r),await this._writer.close(),e()})()}async finalize(){if(this.state==="pending")throw new Error("Cannot finalize before starting.");if(this.state==="canceled")throw new Error("Cannot finalize after canceling.");return this._finalizePromise?(console.warn("Output has already been finalized."),this._finalizePromise):this._finalizePromise=(async()=>{this.state="finalizing";const e=await this._mutex.acquire(),r=this._tracks.map(i=>i.source._flushOrWaitForOngoingClose(!1));await Promise.all(r),await this._muxer.finalize(),await this._writer.flush(),await this._writer.finalize(),this.state="finalized",e()})()}}const ns=t=>{if(t!==void 0&&(!t||typeof t!="object"))throw new TypeError("options.video, when provided, must be an object.");if(t?.discard!==void 0&&typeof t.discard!="boolean")throw new TypeError("options.video.discard, when provided, must be a boolean.");if(t?.forceTranscode!==void 0&&typeof t.forceTranscode!="boolean")throw new TypeError("options.video.forceTranscode, when provided, must be a boolean.");if(t?.codec!==void 0&&!Ie.includes(t.codec))throw new TypeError(`options.video.codec, when provided, must be one of: ${Ie.join(", ")}.`);if(t?.bitrate!==void 0&&!(t.bitrate instanceof Te)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("options.video.bitrate, when provided, must be a positive integer or a quality.");if(t?.width!==void 0&&(!Number.isInteger(t.width)||t.width<=0))throw new TypeError("options.video.width, when provided, must be a positive integer.");if(t?.height!==void 0&&(!Number.isInteger(t.height)||t.height<=0))throw new TypeError("options.video.height, when provided, must be a positive integer.");if(t?.fit!==void 0&&!["fill","contain","cover"].includes(t.fit))throw new TypeError("options.video.fit, when provided, must be one of 'fill', 'contain', or 'cover'.");if(t?.width!==void 0&&t.height!==void 0&&t.fit===void 0)throw new TypeError("When both options.video.width and options.video.height are provided, options.video.fit must also be provided.");if(t?.rotate!==void 0&&![0,90,180,270].includes(t.rotate))throw new TypeError("options.video.rotate, when provided, must be 0, 90, 180 or 270.");if(t?.allowRotationMetadata!==void 0&&typeof t.allowRotationMetadata!="boolean")throw new TypeError("options.video.allowRotationMetadata, when provided, must be a boolean.");if(t?.crop!==void 0&&gi(t.crop,"options.video."),t?.frameRate!==void 0&&(!Number.isFinite(t.frameRate)||t.frameRate<=0))throw new TypeError("options.video.frameRate, when provided, must be a finite positive number.");if(t?.alpha!==void 0&&!["discard","keep"].includes(t.alpha))throw new TypeError("options.video.alpha, when provided, must be either 'discard' or 'keep'.");if(t?.keyFrameInterval!==void 0&&(!Number.isFinite(t.keyFrameInterval)||t.keyFrameInterval<0))throw new TypeError("options.video.keyFrameInterval, when provided, must be a non-negative number.");if(t?.process!==void 0&&typeof t.process!="function")throw new TypeError("options.video.process, when provided, must be a function.");if(t?.processedWidth!==void 0&&(!Number.isInteger(t.processedWidth)||t.processedWidth<=0))throw new TypeError("options.video.processedWidth, when provided, must be a positive integer.");if(t?.processedHeight!==void 0&&(!Number.isInteger(t.processedHeight)||t.processedHeight<=0))throw new TypeError("options.video.processedHeight, when provided, must be a positive integer.");if(t?.hardwareAcceleration!==void 0&&!["no-preference","prefer-hardware","prefer-software"].includes(t.hardwareAcceleration))throw new TypeError("options.video.hardwareAcceleration, when provided, must be 'no-preference', 'prefer-hardware' or 'prefer-software'.")},as=t=>{if(t!==void 0&&(!t||typeof t!="object"))throw new TypeError("options.audio, when provided, must be an object.");if(t?.discard!==void 0&&typeof t.discard!="boolean")throw new TypeError("options.audio.discard, when provided, must be a boolean.");if(t?.forceTranscode!==void 0&&typeof t.forceTranscode!="boolean")throw new TypeError("options.audio.forceTranscode, when provided, must be a boolean.");if(t?.codec!==void 0&&!_e.includes(t.codec))throw new TypeError(`options.audio.codec, when provided, must be one of: ${_e.join(", ")}.`);if(t?.bitrate!==void 0&&!(t.bitrate instanceof Te)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("options.audio.bitrate, when provided, must be a positive integer or a quality.");if(t?.numberOfChannels!==void 0&&(!Number.isInteger(t.numberOfChannels)||t.numberOfChannels<=0))throw new TypeError("options.audio.numberOfChannels, when provided, must be a positive integer.");if(t?.sampleRate!==void 0&&(!Number.isInteger(t.sampleRate)||t.sampleRate<=0))throw new TypeError("options.audio.sampleRate, when provided, must be a positive integer.");if(t?.process!==void 0&&typeof t.process!="function")throw new TypeError("options.audio.process, when provided, must be a function.");if(t?.processedNumberOfChannels!==void 0&&(!Number.isInteger(t.processedNumberOfChannels)||t.processedNumberOfChannels<=0))throw new TypeError("options.audio.processedNumberOfChannels, when provided, must be a positive integer.");if(t?.processedSampleRate!==void 0&&(!Number.isInteger(t.processedSampleRate)||t.processedSampleRate<=0))throw new TypeError("options.audio.processedSampleRate, when provided, must be a positive integer.")},Lr=2,Wr=48e3;class hn{static async init(e){const r=new hn(e);return await r._init(),r}constructor(e){if(this._addedCounts={video:0,audio:0,subtitle:0},this._totalTrackCount=0,this._trackPromises=[],this._executed=!1,this._synchronizer=new hl,this._totalDuration=null,this._maxTimestamps=new Map,this._canceled=!1,this.onProgress=void 0,this._computeProgress=!1,this._lastProgress=0,this.isValid=!1,this.utilizedTracks=[],this.discardedTracks=[],!e||typeof e!="object")throw new TypeError("options must be an object.");if(!(e.input instanceof Do))throw new TypeError("options.input must be an Input.");if(!(e.output instanceof ss))throw new TypeError("options.output must be an Output.");if(e.output._tracks.length>0||Object.keys(e.output._metadataTags).length>0||e.output.state!=="pending")throw new TypeError("options.output must be fresh: no tracks or metadata tags added and not started.");if(typeof e.video!="function"&&ns(e.video),typeof e.audio!="function"&&as(e.audio),e.trim!==void 0&&(!e.trim||typeof e.trim!="object"))throw new TypeError("options.trim, when provided, must be an object.");if(e.trim?.start!==void 0&&(!Number.isFinite(e.trim.start)||e.trim.start<0))throw new TypeError("options.trim.start, when provided, must be a non-negative number.");if(e.trim?.end!==void 0&&(!Number.isFinite(e.trim.end)||e.trim.end<0))throw new TypeError("options.trim.end, when provided, must be a non-negative number.");if(e.trim?.start!==void 0&&e.trim.end!==void 0&&e.trim.start>=e.trim.end)throw new TypeError("options.trim.start must be less than options.trim.end.");if(e.tags!==void 0&&(typeof e.tags!="object"||!e.tags)&&typeof e.tags!="function")throw new TypeError("options.tags, when provided, must be an object or a function.");if(typeof e.tags=="object"&&qr(e.tags),e.showWarnings!==void 0&&typeof e.showWarnings!="boolean")throw new TypeError("options.showWarnings, when provided, must be a boolean.");this._options=e,this.input=e.input,this.output=e.output;const{promise:r,resolve:i}=ne();this._started=r,this._start=i}async _init(){this._startTimestamp=this._options.trim?.start??Math.max(await this.input.getFirstTimestamp(),0),this._endTimestamp=this._options.trim?.end??1/0;const e=await this.input.getTracks(),r=this.output.format.getSupportedTrackCounts();let i=1,s=1;for(const l of e){let u;if(l.isVideoTrack()?this._options.video&&(typeof this._options.video=="function"?(u=await this._options.video(l,i),ns(u),i++):u=this._options.video):l.isAudioTrack()?this._options.audio&&(typeof this._options.audio=="function"?(u=await this._options.audio(l,s),as(u),s++):u=this._options.audio):m(!1),u?.discard){this.discardedTracks.push({track:l,reason:"discarded_by_user"});continue}if(this._totalTrackCount===r.total.max){this.discardedTracks.push({track:l,reason:"max_track_count_reached"});continue}if(this._addedCounts[l.type]===r[l.type].max){this.discardedTracks.push({track:l,reason:"max_track_count_of_type_reached"});continue}l.isVideoTrack()?await this._processVideoTrack(l,u??{}):l.isAudioTrack()&&await this._processAudioTrack(l,u??{})}const n=await this.input.getMetadataTags();let a;if(this._options.tags){const l=typeof this._options.tags=="function"?await this._options.tags(n):this._options.tags;qr(l),a=l}else a=n;const o=(await this.input.getFormat()).mimeType===this.output.format.mimeType,c=n.raw===a.raw;if(n.raw&&c&&!o&&delete a.raw,this.output.setMetadataTags(a),this.isValid=this._totalTrackCount>=r.total.min&&this._addedCounts.video>=r.video.min&&this._addedCounts.audio>=r.audio.min&&this._addedCounts.subtitle>=r.subtitle.min,this._options.showWarnings??!0){const l=[],u=this.discardedTracks.filter(d=>d.reason!=="discarded_by_user");u.length>0&&l.push("Some tracks had to be discarded from the conversion:",u),this.isValid||l.push(`

`+this._getInvalidityExplanation().join("")),l.length>0&&console.warn(...l)}}_getInvalidityExplanation(){const e=[];if(this.discardedTracks.length===0)e.push("Due to missing tracks, this conversion cannot be executed.");else{const r=this.discardedTracks.every(i=>i.reason==="discarded_by_user"||i.reason==="no_encodable_target_codec");if(e.push("Due to discarded tracks, this conversion cannot be executed."),r){const i=this.discardedTracks.flatMap(s=>s.reason==="discarded_by_user"?[]:s.track.type==="video"?this.output.format.getSupportedVideoCodecs():s.track.type==="audio"?this.output.format.getSupportedAudioCodecs():this.output.format.getSupportedSubtitleCodecs());i.length===1?e.push(`
Tracks were discarded because your environment is not able to encode '${i[0]}'.`):e.push(`
Tracks were discarded because your environment is not able to encode any of the following codecs: ${i.map(s=>`'${s}'`).join(", ")}.`),i.includes("mp3")&&e.push(`
The @mediabunny/mp3-encoder extension package provides support for encoding MP3.`)}else e.push(`
Check the discardedTracks field for more info.`)}return e}async execute(){if(!this.isValid)throw new Error(`Cannot execute this conversion because its output configuration is invalid. Make sure to always check the isValid field before executing a conversion.
`+this._getInvalidityExplanation().join(""));if(this._executed)throw new Error("Conversion cannot be executed twice.");if(this._executed=!0,this.onProgress){this._computeProgress=!0,this._totalDuration=Math.min(await this.input.computeDuration()-this._startTimestamp,this._endTimestamp-this._startTimestamp);for(const e of this.utilizedTracks)this._maxTimestamps.set(e.id,0);this.onProgress?.(0)}await this.output.start(),this._start();try{await Promise.all(this._trackPromises)}catch(e){throw this._canceled||this.cancel(),e}if(this._canceled)throw new dl;await this.output.finalize(),this._computeProgress&&this.onProgress?.(1)}async cancel(){if(!(this.output.state==="finalizing"||this.output.state==="finalized")){if(this._canceled){console.warn("Conversion already canceled.");return}this._canceled=!0,await this.output.cancel()}}async _processVideoTrack(e,r){const i=e.codec;if(!i){this.discardedTracks.push({track:e,reason:"unknown_source_codec"});return}let s;const n=si(e.rotation+(r.rotate??0)),a=this.output.format.supportsVideoRotationMetadata&&(r.allowRotationMetadata??!0),[o,c]=n%180===0?[e.codedWidth,e.codedHeight]:[e.codedHeight,e.codedWidth],l=r.crop;l&&pi(l,o,c);const[u,d]=l?[l.width,l.height]:[o,c];let h=u,f=d;const p=h/f,g=x=>Math.ceil(x/2)*2;r.width!==void 0&&r.height===void 0?(h=g(r.width),f=g(Math.round(h/p))):r.width===void 0&&r.height!==void 0?(f=g(r.height),h=g(Math.round(f*p))):r.width!==void 0&&r.height!==void 0&&(h=g(r.width),f=g(r.height));const k=await e.getFirstTimestamp(),w=!!r.forceTranscode||k<this._startTimestamp||!!r.frameRate||r.keyFrameInterval!==void 0||r.process!==void 0;let b=h!==u||f!==d||n!==0&&(!a||r.process!==void 0)||!!l;const y=r.alpha??"discard";let T=this.output.format.getSupportedVideoCodecs();if(!w&&!r.bitrate&&!b&&T.includes(i)&&(!r.codec||r.codec===i)){const x=new sl(i);s=x,this._trackPromises.push((async()=>{await this._started;const P=new Qt(e),C={decoderConfig:await e.getDecoderConfig()??void 0},R=Number.isFinite(this._endTimestamp)?await P.getPacket(this._endTimestamp,{metadataOnly:!0})??void 0:void 0;for await(const M of P.packets(void 0,R,{verifyKeyPackets:!0})){if(this._canceled)return;const A=M.clone({timestamp:M.timestamp-this._startTimestamp,sideData:y==="discard"?{}:M.sideData});m(A.timestamp>=0),this._reportProgress(e.id,A.timestamp),await x.add(A,C),this._synchronizer.shouldWait(e.id,A.timestamp)&&await this._synchronizer.wait(A.timestamp)}x.close(),this._synchronizer.closeTrack(e.id)})())}else{if(!await e.canDecode()){this.discardedTracks.push({track:e,reason:"undecodable_source_codec"});return}r.codec&&(T=T.filter(M=>M===r.codec));const P=r.bitrate??es,_=await il(T,{width:r.process&&r.processedWidth?r.processedWidth:h,height:r.process&&r.processedHeight?r.processedHeight:f,bitrate:P});if(!_){this.discardedTracks.push({track:e,reason:"no_encodable_target_codec"});return}const C={codec:_,bitrate:P,keyFrameInterval:r.keyFrameInterval,sizeChangeBehavior:r.fit??"passThrough",alpha:y,hardwareAcceleration:r.hardwareAcceleration},R=new rs(C);if(s=R,!b){const M=new ss({format:new cn,target:new Gc}),A=new rs(C);M.addVideoTrack(A),await M.start();const W=await new Kr(e).getSample(k);if(W)try{await A.add(W),W.close(),await M.finalize()}catch($){console.info("Error when probing encoder support. Falling back to rerender path.",$),b=!0,M.cancel()}else await M.cancel()}b?this._trackPromises.push((async()=>{await this._started;const A=new pa(e,{width:h,height:f,fit:r.fit??"fill",rotation:n,crop:r.crop,poolSize:1,alpha:y==="keep"}).canvases(this._startTimestamp,this._endTimestamp),z=r.frameRate;let W=null,$=null,Q=null;const q=async Z=>{m(W),m(z!==void 0);const ie=Math.round((Z-$)*z);for(let dt=1;dt<ie;dt++){const Le=new oe(W,{timestamp:$+dt/z,duration:1/z});await this._registerVideoSample(e,r,R,Le),Le.close()}};for await(const{canvas:Z,timestamp:ie,duration:dt}of A){if(this._canceled)return;let Le=Math.max(ie-this._startTimestamp,0);if(Q=Le+dt,z!==void 0){const tr=Math.floor(Le*z)/z;if(W!==null)if(tr<=$){W=Z,$=tr;continue}else await q(tr);Le=tr}const Ei=new oe(Z,{timestamp:Le,duration:z!==void 0?1/z:dt});await this._registerVideoSample(e,r,R,Ei),Ei.close(),z!==void 0&&(W=Z,$=Le)}W&&(m(Q!==null),m(z!==void 0),await q(Math.floor(Q*z)/z)),R.close(),this._synchronizer.closeTrack(e.id)})()):this._trackPromises.push((async()=>{await this._started;const M=new Kr(e),A=r.frameRate;let z=null,W=null,$=null;const Q=async q=>{m(z),m(A!==void 0);const Z=Math.round((q-W)*A);for(let ie=1;ie<Z;ie++)z.setTimestamp(W+ie/A),z.setDuration(1/A),await this._registerVideoSample(e,r,R,z);z.close()};for await(const q of M.samples(this._startTimestamp,this._endTimestamp)){if(this._canceled){q.close(),z?.close();return}let Z=Math.max(q.timestamp-this._startTimestamp,0);if($=Z+q.duration,A!==void 0){const ie=Math.floor(Z*A)/A;if(z!==null)if(ie<=W){z.close(),z=q,W=ie;continue}else await Q(ie);Z=ie,q.setDuration(1/A)}q.setTimestamp(Z),await this._registerVideoSample(e,r,R,q),A!==void 0?(z=q,W=Z):q.close()}z&&(m($!==null),m(A!==void 0),await Q(Math.floor($*A)/A)),R.close(),this._synchronizer.closeTrack(e.id)})())}this.output.addVideoTrack(s,{frameRate:r.frameRate,languageCode:qt(e.languageCode)?e.languageCode:void 0,name:e.name??void 0,disposition:e.disposition,rotation:b?0:n}),this._addedCounts.video++,this._totalTrackCount++,this.utilizedTracks.push(e)}async _registerVideoSample(e,r,i,s){if(this._canceled)return;this._reportProgress(e.id,s.timestamp);let n;if(!r.process)n=[s];else{let a=r.process(s);a instanceof Promise&&(a=await a),Array.isArray(a)||(a=a===null?[]:[a]),n=a.map(o=>o instanceof oe?o:typeof VideoFrame<"u"&&o instanceof VideoFrame?new oe(o):new oe(o,{timestamp:s.timestamp,duration:s.duration}))}for(const a of n){if(this._canceled)break;await i.add(a),this._synchronizer.shouldWait(e.id,a.timestamp)&&await this._synchronizer.wait(a.timestamp)}for(const a of n)a!==s&&a.close()}async _processAudioTrack(e,r){const i=e.codec;if(!i){this.discardedTracks.push({track:e,reason:"unknown_source_codec"});return}let s;const n=e.numberOfChannels,a=e.sampleRate,o=await e.getFirstTimestamp();let c=r.numberOfChannels??n,l=r.sampleRate??a,u=c!==n||l!==a||o<this._startTimestamp,d=this.output.format.getSupportedAudioCodecs();if(!r.forceTranscode&&!r.bitrate&&!u&&d.includes(i)&&(!r.codec||r.codec===i)&&!r.process){const h=new ol(i);s=h,this._trackPromises.push((async()=>{await this._started;const f=new Qt(e),g={decoderConfig:await e.getDecoderConfig()??void 0},k=Number.isFinite(this._endTimestamp)?await f.getPacket(this._endTimestamp,{metadataOnly:!0})??void 0:void 0;for await(const w of f.packets(void 0,k)){if(this._canceled)return;const b=w.clone({timestamp:w.timestamp-this._startTimestamp});m(b.timestamp>=0),this._reportProgress(e.id,b.timestamp),await h.add(b,g),this._synchronizer.shouldWait(e.id,b.timestamp)&&await this._synchronizer.wait(b.timestamp)}h.close(),this._synchronizer.closeTrack(e.id)})())}else{if(!await e.canDecode()){this.discardedTracks.push({track:e,reason:"undecodable_source_codec"});return}let f=null;r.codec&&(d=d.filter(k=>k===r.codec));const p=r.bitrate??es,g=await ts(d,{numberOfChannels:r.process&&r.processedNumberOfChannels?r.processedNumberOfChannels:c,sampleRate:r.process&&r.processedSampleRate?r.processedSampleRate:l,bitrate:p});if(!g.some(k=>Ut.includes(k))&&d.some(k=>Ut.includes(k))&&(c!==Lr||l!==Wr)){const w=(await ts(d,{numberOfChannels:Lr,sampleRate:Wr,bitrate:p})).find(b=>Ut.includes(b));w&&(u=!0,f=w,c=Lr,l=Wr)}else f=g[0]??null;if(f===null){this.discardedTracks.push({track:e,reason:"no_encodable_target_codec"});return}if(u)s=this._resampleAudio(e,r,f,c,l,p);else{const k=new is({codec:f,bitrate:p});s=k,this._trackPromises.push((async()=>{await this._started;const w=new qi(e);for await(const b of w.samples(void 0,this._endTimestamp)){if(this._canceled){b.close();return}b.setTimestamp(b.timestamp-this._startTimestamp),await this._registerAudioSample(e,r,k,b),b.close()}k.close(),this._synchronizer.closeTrack(e.id)})())}}this.output.addAudioTrack(s,{languageCode:qt(e.languageCode)?e.languageCode:void 0,name:e.name??void 0,disposition:e.disposition}),this._addedCounts.audio++,this._totalTrackCount++,this.utilizedTracks.push(e)}async _registerAudioSample(e,r,i,s){if(this._canceled)return;this._reportProgress(e.id,s.timestamp);let n;if(!r.process)n=[s];else{let a=r.process(s);if(a instanceof Promise&&(a=await a),Array.isArray(a)||(a=a===null?[]:[a]),!a.every(o=>o instanceof ge))throw new TypeError("The audio process function must return an AudioSample, null, or an array of AudioSamples.");n=a}for(const a of n){if(this._canceled)break;await i.add(a),this._synchronizer.shouldWait(e.id,a.timestamp)&&await this._synchronizer.wait(a.timestamp)}for(const a of n)a!==s&&a.close()}_resampleAudio(e,r,i,s,n,a){const o=new is({codec:i,bitrate:a});return this._trackPromises.push((async()=>{await this._started;const c=new fl({targetNumberOfChannels:s,targetSampleRate:n,startTime:this._startTimestamp,endTime:this._endTimestamp,onSample:async d=>{await this._registerAudioSample(e,r,o,d),d.close()}}),u=new qi(e).samples(this._startTimestamp,this._endTimestamp);for await(const d of u){if(this._canceled){d.close();return}await c.add(d),d.close()}await c.finalize(),o.close(),this._synchronizer.closeTrack(e.id)})()),o}_reportProgress(e,r){if(!this._computeProgress)return;m(this._totalDuration!==null),this._maxTimestamps.set(e,Math.max(r,this._maxTimestamps.get(e)));const i=Math.min(...this._maxTimestamps.values()),s=te(i/this._totalDuration,0,1);s!==this._lastProgress&&(this._lastProgress=s,this.onProgress?.(s))}}class dl extends Error{constructor(e="Conversion has been canceled."){super(e),this.name="ConversionCanceledError"}}const os=5;class hl{constructor(){this.maxTimestamps=new Map,this.resolvers=[]}computeMinAndMaybeResolve(){let e=1/0;for(const[,r]of this.maxTimestamps)e=Math.min(e,r);for(let r=0;r<this.resolvers.length;r++){const i=this.resolvers[r];i.timestamp-e<os&&(i.resolve(),this.resolvers.splice(r,1),r--)}return e}shouldWait(e,r){this.maxTimestamps.set(e,Math.max(r,this.maxTimestamps.get(e)??-1/0));const i=this.computeMinAndMaybeResolve();return r-i>=os}wait(e){const{promise:r,resolve:i}=ne();return this.resolvers.push({timestamp:e,resolve:i}),r}closeTrack(e){this.maxTimestamps.delete(e),this.computeMinAndMaybeResolve()}}class fl{constructor(e){this.sourceSampleRate=null,this.sourceNumberOfChannels=null,this.targetSampleRate=e.targetSampleRate,this.targetNumberOfChannels=e.targetNumberOfChannels,this.startTime=e.startTime,this.endTime=e.endTime,this.onSample=e.onSample,this.bufferSizeInFrames=Math.floor(this.targetSampleRate*5),this.bufferSizeInSamples=this.bufferSizeInFrames*this.targetNumberOfChannels,this.outputBuffer=new Float32Array(this.bufferSizeInSamples),this.bufferStartFrame=0,this.maxWrittenFrame=-1}doChannelMixerSetup(){m(this.sourceNumberOfChannels!==null);const e=this.sourceNumberOfChannels,r=this.targetNumberOfChannels;e===1&&r===2?this.channelMixer=(i,s)=>i[s*e]:e===1&&r===4?this.channelMixer=(i,s,n)=>i[s*e]*+(n<2):e===1&&r===6?this.channelMixer=(i,s,n)=>i[s*e]*+(n===2):e===2&&r===1?this.channelMixer=(i,s)=>{const n=s*e;return .5*(i[n]+i[n+1])}:e===2&&r===4?this.channelMixer=(i,s,n)=>i[s*e+n]*+(n<2):e===2&&r===6?this.channelMixer=(i,s,n)=>i[s*e+n]*+(n<2):e===4&&r===1?this.channelMixer=(i,s)=>{const n=s*e;return .25*(i[n]+i[n+1]+i[n+2]+i[n+3])}:e===4&&r===2?this.channelMixer=(i,s,n)=>{const a=s*e;return .5*(i[a+n]+i[a+n+2])}:e===4&&r===6?this.channelMixer=(i,s,n)=>{const a=s*e;return n<2?i[a+n]:n===2||n===3?0:i[a+n-2]}:e===6&&r===1?this.channelMixer=(i,s)=>{const n=s*e;return Math.SQRT1_2*(i[n]+i[n+1])+i[n+2]+.5*(i[n+4]+i[n+5])}:e===6&&r===2?this.channelMixer=(i,s,n)=>{const a=s*e;return i[a+n]+Math.SQRT1_2*(i[a+2]+i[a+n+4])}:e===6&&r===4?this.channelMixer=(i,s,n)=>{const a=s*e;return n<2?i[a+n]+Math.SQRT1_2*i[a+2]:i[a+n+2]}:this.channelMixer=(i,s,n)=>n<e?i[s*e+n]:0}ensureTempBufferSize(e){let r=this.tempSourceBuffer.length;for(;r<e;)r*=2;if(r!==this.tempSourceBuffer.length){const i=new Float32Array(r);i.set(this.tempSourceBuffer),this.tempSourceBuffer=i}}async add(e){this.sourceSampleRate===null&&(this.sourceSampleRate=e.sampleRate,this.sourceNumberOfChannels=e.numberOfChannels,this.tempSourceBuffer=new Float32Array(this.sourceSampleRate*this.sourceNumberOfChannels),this.doChannelMixerSetup());const r=e.numberOfFrames*e.numberOfChannels;this.ensureTempBufferSize(r);const i=e.allocationSize({planeIndex:0,format:"f32"}),s=new Float32Array(this.tempSourceBuffer.buffer,0,i/4);e.copyTo(s,{planeIndex:0,format:"f32"});const n=e.timestamp-this.startTime,a=e.numberOfFrames/this.sourceSampleRate,o=Math.min(n+a,this.endTime-this.startTime),c=Math.floor(n*this.targetSampleRate),l=Math.ceil(o*this.targetSampleRate);for(let u=c;u<l;u++){if(u<this.bufferStartFrame)continue;for(;u>=this.bufferStartFrame+this.bufferSizeInFrames;)await this.finalizeCurrentBuffer(),this.bufferStartFrame+=this.bufferSizeInFrames;const d=u-this.bufferStartFrame;m(d<this.bufferSizeInFrames);const p=(u/this.targetSampleRate-n)*this.sourceSampleRate,g=Math.floor(p),k=Math.ceil(p),w=p-g;for(let b=0;b<this.targetNumberOfChannels;b++){let y=0,T=0;g>=0&&g<e.numberOfFrames&&(y=this.channelMixer(s,g,b)),k>=0&&k<e.numberOfFrames&&(T=this.channelMixer(s,k,b));const x=y+w*(T-y),P=d*this.targetNumberOfChannels+b;this.outputBuffer[P]+=x}this.maxWrittenFrame=Math.max(this.maxWrittenFrame,d)}}async finalizeCurrentBuffer(){if(this.maxWrittenFrame<0)return;const e=(this.maxWrittenFrame+1)*this.targetNumberOfChannels,r=new Float32Array(e);r.set(this.outputBuffer.subarray(0,e));const i=this.bufferStartFrame/this.targetSampleRate,s=new ge({format:"f32",sampleRate:this.targetSampleRate,numberOfChannels:this.targetNumberOfChannels,timestamp:i,data:r});await this.onSample(s),this.outputBuffer.fill(0),this.maxWrittenFrame=-1}finalize(){return this.finalizeCurrentBuffer()}}export{gl as A,kl as B,hn as C,ml as F,Do as I,cn as M,ss as O,bl as Q,Kc as a,wl as b,es as c,pl as f,ts as g};

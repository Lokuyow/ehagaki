import{B as E}from"./baseCompression-DThwcD4_.js";import{a as W,d as f,c as I}from"./index-BNG84_vA.js";import{g as V,I as k,A as B,B as O,a as L,O as _,M as H,C as N,Q as P,b as U,c as Q}from"./vendor-video-BBTp-AV6.js";import"./vendor-ui-Dfbvke9w.js";import"./vendor-nostr-CSSTtp-a.js";import"./vendor-zap-DuBBJg9r.js";import"./vendor-editor-DymEIdpa.js";import"./vendor-image-DhZoa7y2.js";function S(p){if(p!=null){if(p===.3)return P;if(p===1)return U;if(p===2)return Q}}async function Z(){if(!(typeof VideoEncoder<"u"&&typeof VideoDecoder<"u")||/Android.*Firefox/.test(navigator.userAgent))return!1;try{const o=(await V()).includes("opus");return W("MediaBunnyCompression","MediaBunny supported - Video encoding available, Opus codec available:",o),!0}catch{return!0}}async function T(){if(typeof AudioEncoder>"u")return!1;try{const p={codec:"opus",sampleRate:48e3,numberOfChannels:2,bitrate:128e3};return(await AudioEncoder.isConfigSupported(p)).supported||!1}catch{return!1}}async function z(p,e,t){if(typeof AudioEncoder>"u")return!1;try{const o={codec:"opus",sampleRate:p,numberOfChannels:e,bitrate:t};return(await AudioEncoder.isConfigSupported(o)).supported||!1}catch{return!1}}function g(p,e,t=!1){if(p)try{p.dispose()}catch{}if(e&&t)try{e.finalize()}catch{}}class $ extends E{constructor(e,t,o){super("MediaBunnyCompression"),this.parseAudioBitrate=e,this.mergeVideoAndAudioWithFFmpeg=t,this.compressWithFFmpeg=o}abortController=null;abort(){this.log("Abort requested"),this.resetProgress(),this.abortController&&(this.log("Aborting Mediabunny conversion"),this.abortController.abort(),this.abortController=null)}async cleanup(){this.abortController=null}async findSupportedOpusConfig(e,t,o,l){const d=Math.max(l,64e3),a=Array.from(new Set([o,48e3,24e3,e.sampleRate])).filter(u=>Number.isFinite(u)&&u>0),s=[{sampleRate:o,bitrate:l},...a.map(u=>({sampleRate:u,bitrate:d}))];for(const{sampleRate:u,bitrate:c}of s){if(!Number.isFinite(u)||u<=0||!Number.isFinite(c)||c<=0)continue;const i=Math.round(u),r=Math.round(c),n=await z(i,t,r);if(this.log("Opus encoding support probe:",{trackId:e.id,codec:e.codec,targetChannels:t,sampleRate:i,bitrate:r,supported:n}),n)return{sampleRate:i,bitrate:r}}return null}async validateMediabunnyAudioConfig(e,t,o){const l=new Map;let d=await T(),a=o?null:this.parseAudioBitrate(t?.audioBitrate),s=o?null:typeof t?.audioSampleRate=="number"?t.audioSampleRate:null;if(this.log("Opus encoding supported (global check):",d),d&&e.length>0)for(const u of e){const c=t.audioChannels??u.numberOfChannels,i=t.audioSampleRate??u.sampleRate,r=o?64e3:this.parseAudioBitrate(t.audioBitrate)??128e3,n=await this.findSupportedOpusConfig(u,c,i,r);if(!n){d=!1,this.log("Opus encoder does not support requested settings; will copy audio track as-is via Mediabunny.",{trackId:u.id,preferredSampleRate:i,preferredBitrate:r,targetChannels:c});break}l.set(u.id,{sampleRate:n.sampleRate,bitrate:n.bitrate,channels:c}),(n.sampleRate!==i||n.bitrate!==r)&&this.log("Adjusted Mediabunny audio target due to encoder support limitations.",{trackId:u.id,preferredSampleRate:i,preferredBitrate:r,resolvedSampleRate:n.sampleRate,resolvedBitrate:n.bitrate}),o||(s=n.sampleRate,a=n.bitrate)}return{canEncodeOpus:d,audioConfigByTrack:l,desiredAudioSampleRate:s,desiredAudioBitrate:a}}buildConversionOptions(e,t,o,l,d,a,s,u){return{input:e,output:t,video:i=>{const r={codec:"avc",...a?{bitrate:a}:{}},n=o.maxSize;return typeof n=="number"&&Number.isFinite(n)&&(i.displayWidth>i.displayHeight?r.width=Math.min(i.displayWidth,n):r.height=Math.min(i.displayHeight,n),this.log("Applying video resize:",{originalWidth:i.displayWidth,originalHeight:i.displayHeight,maxSize:n,targetWidth:r.width,targetHeight:r.height,bitrate:a||"custom"})),r},audio:s?l&&d?{codec:"opus",bitrate:d,forceTranscode:!0}:i=>{const r=u.get(i.id),n=r?.channels??o.audioChannels??i.numberOfChannels,h=r?.sampleRate??o.audioSampleRate??i.sampleRate;this.log("Configuring audio track for compression:",{inputCodec:i.codec,inputChannels:i.numberOfChannels,inputSampleRate:i.sampleRate,targetChannels:n,targetSampleRate:h});const b=r?.bitrate??this.parseAudioBitrate(o.audioBitrate)??128e3;return{codec:"opus",forceTranscode:!0,...typeof n=="number"?{numberOfChannels:n}:{},...typeof h=="number"?{sampleRate:h}:{},bitrate:b}}:i=>{this.log("Copying audio track as-is (Opus encoding not supported):",{trackId:i.id,codec:i.codec,channels:i.numberOfChannels,sampleRate:i.sampleRate})},showWarnings:!1}}validateConversion(e,t,o,l){if(e.discardedTracks.length>0){this.log("Discarded tracks:",e.discardedTracks.map(a=>({type:a.track.type,reason:a.reason})));const d=e.discardedTracks.filter(a=>a.track.type==="video"||a.track.type==="audio");if(d.length>0&&(console.warn("[MediaBunnyCompression] Important tracks discarded:",d.map(s=>({type:s.track.type,reason:s.reason,codec:s.track.type==="audio"?s.track.codec:void 0}))),d.some(s=>s.track.type==="audio"&&s.reason==="no_encodable_target_codec")&&l))throw f(this.context,"Mediabunny cannot encode audio for this environment, falling back to FFmpeg."),g(t,o,!0),new Error("mediabunny-unsupported-audio-codec")}return e.isValid?null:(f(this.context,"Conversion is not valid:",e.discardedTracks),g(t,o,!0),{file:new File([],""),wasCompressed:!1,wasSkipped:!0})}async executeConversion(e,t){const o=new Promise(l=>{this.abortController.signal.addEventListener("abort",()=>{this.log("Mediabunny conversion aborted"),e.cancel().then(l)})});return await Promise.race([e.execute(),o]),this.checkAbort(t)}async compressWithMediabunny(e,t){let o=null,l=null,d=null;const a=typeof t?.mediabunnyAudioQualityFactor=="number",s=S(t?.mediabunnyAudioQualityFactor),u=S(t?.mediabunnyVideoQualityFactor)||s;try{this.log("Starting Mediabunny compression"),this.abortController=new AbortController,o=new k({source:new O(e),formats:B}),d=new L,l=new _({target:d,format:new H({fastStart:"in-memory"})});const c=await o.getAudioTracks(),i=c.length>0;this.log("Input audio tracks:",c.length),c.length>0&&this.log("First audio track codec:",c[0].codec);const r=await this.validateMediabunnyAudioConfig(c,t,a);let{canEncodeOpus:n,audioConfigByTrack:h,desiredAudioSampleRate:b,desiredAudioBitrate:w}=r;const x=this.buildConversionOptions(o,l,t,a,s,u,n,h),C=await N.init(x),v=this.validateConversion(C,o,l,n);if(v)return this.abortController=null,v;C.onProgress=m=>{this.onProgress&&this.onProgress(Math.round(m*100))};const F=await this.executeConversion(C,e);if(F)return g(o,null),this.abortController=null,F;const R=d.buffer;if(!R)throw new Error("Output buffer is null");let A=new Blob([R],{type:"video/mp4"});if(g(o,null),!n&&i){this.log("Attempting to mux original audio track via FFmpeg copy");const m=await this.mergeVideoAndAudioWithFFmpeg(A,e),M=this.checkAbort(e);if(M)return this.abortController=null,M;if(!m)return f(this.context,"Audio mux failed; falling back to FFmpeg compression."),this.abortController=null,await this.compressWithFFmpeg(e,t);A=m,this.log("Successfully muxed original audio track.")}const y=I(A,e,this.context);if(!y.wasCompressed)return this.abortController=null,y;if(n&&i&&(w||b)){if(!(await this.verifyMediabunnyAudio(y.file,b,w)).passed)return this.abortController=null,await this.compressWithFFmpeg(e,t)}else!n&&i&&this.log("Audio was copied as-is, skipping audio verification");return this.onProgress&&this.onProgress(100),this.abortController=null,y}catch(c){g(o,null);const i=this.checkAbort(e);return i?(this.abortController=null,i):(console.error("[MediaBunnyCompression] Mediabunny compression failed:",c),this.abortController=null,{file:e,wasCompressed:!1,wasSkipped:!0})}}async verifyMediabunnyAudio(e,t,o){const l=typeof o=="number"&&Number.isFinite(o),d=typeof t=="number"&&Number.isFinite(t);if(!l&&!d)return{passed:!0};let a=null;try{a=new k({source:new O(e),formats:B});const s=await a.getAudioTracks();if(s.length===0)return f(this.context,"Mediabunny output lost audio track; falling back to FFmpeg"),{passed:!1};const u=s[0],c=await u.computePacketStats(120),i=u.sampleRate,r=c.averageBitrate;if(this.log("Mediabunny audio verification:",{expectedBitrate:o,actualBitrate:r,expectedSampleRate:t,actualSampleRate:i}),d&&Math.abs(i-t)>1)return f(this.context,"Audio sample rate mismatch detected, falling back to FFmpeg"),{passed:!1};if(l){const n=o*1.25;if(!Number.isFinite(r)||r>n)return f(this.context,"Audio bitrate exceeds expected range, falling back to FFmpeg",{actualBitrate:r,allowedUpperBitrate:n}),{passed:!1}}return{passed:!0}}catch(s){return f(this.context,"Audio verification error, falling back to FFmpeg:",s),{passed:!1}}finally{a?.dispose()}}}export{$ as MediaBunnyCompression,g as cleanupMediabunny,Z as isMediaBunnySupported,z as isOpusEncodingConfigSupported,T as isOpusEncodingSupported};
